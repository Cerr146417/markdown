# **第1章 开篇**

## **01 开篇词： 找寻测试的乐趣，做更好的Tester！**

大家好，我是风落。目前在蚂蚁金服工作，之前也曾在 Office Depot 任职。虽然职业背景很巧合地横跨了实体产业、互联网以及金融，同时自己也曾经做过开发、运维、产品经理、DBA、测试等等，只能笑称自己叫 “全占工程师”，但是主要的技术方向从未改变，就是测试开发，包括功能测试、探索性测试、自动化、安全、性能等等。

我从大学开始就一直做一些技术上的探索，譬如挖比特币、汇编完成巡线机器人、制作文化节网站等，直到今天有 10 多年的时间了。可能跟大家想象的技术人不同，我还是一个有丰富爱好的人，比如我热爱旅游，直到现在仍然不时的出去浪；喜欢球类运动，也曾经在篮球足球场上一起拼杀，甚至参加过网球非职业组公开赛、做过羽毛球教练（摸摸已经胖了的自己）；崇尚围棋的思想，大学时候还创立了学校的第一个大型棋社等等。

我是一个喜欢就努力就去做的人，之所以还在写代码做测试，也是出于对测试的兴趣和喜爱。从 2011 年开始在网上公开课分享自己关于各项测试技术的见解和心得体会，到后来开始在慕课上开设了第一门实战课程，再到现在，已经是慕课网的资深讲师，在慕课网实战栏目中出品了四门课程，覆盖[功能](https://coding.imooc.com/class/277.html)、[性能](https://coding.imooc.com/class/305.html)、[自动化](https://coding.imooc.com/class/238.html)等测试方向。

开始分享以来，出乎意料地获得了很多朋友的认可，也得到了很多大佬的帮助，在这期间，还跟朋友一起出版了一本《LoadRunner 性能测试巧匠训练营》的测试书籍，收获了大家很多好评，当然，也有很多批评。或褒或贬，这些也都帮助了我自己的成长，我也相信，我的分享大约也的确或多或少帮助了一些朋友收获到了东西。

在很多人的眼里，我是一个幸运的人，有一个尚可的学历背景，有一份不错的工作，甚至还有个让人尊敬的称谓 —“风落老师”。所以很多学员私下问我，怎么才能成为下一个你？然而奋斗的路上其实没有捷径，我能帮助大家的，其实是帮大家斩除道路上的一些荆棘。

过去的十年中，我不断的收到类似这样的讯号：“我觉得开发不好找工作，想转行测试”、“开发太累了，换测试比较轻松”、“测试工作多简单” 等等。我确定一定以及肯定的相信，这绝对不是个例，如此想法大有人在。不得不承认的是，就门槛而言，测试的确是远远低于开发，只要我们有一定的理解能力和计算机能力，都可以开始上手做 “捉虫” 的工作，“捉虫” 的目的在于让编写好的程序不会出错，能够正常的运行。或许这是一个入门的软件测试工程师，我们可以称之为 “会测试”。

然而仅仅是 “会测试” 的人，至多算是个 “青铜”，到哪里都是个坑。世界也是在不断变化的，tester 们也在不断提升自己，所以我们会开始去学习代码、跟踪日志、分析问题、学习自动化、分析性能、了解安全等等。不断修炼，终于，我们成为了优秀的测试工程师，经过了 “白银”、“黄金” 达到了 “钻石” 的级别。

一个优秀的测试工程师，他们不会冒出测试很简单的想法，他们不仅仅把测试当做一份工作，更当做一种乐趣和艺术，他们会不断提升自己的测试技能、测试方法和效率。在我看来，这个时候的测试，已经超越了传统意义上的测试，所以出现了一种新的岗位命名 — 测试开发。

随着互联网行业的发展，优秀的测试工程师已经不能满足于测试领域的要求了，我们需要一些能够参与系统架构设计、能够统筹规划测试系统结构、引导测试技术发展的卓越的软件测试工程师，这就是测试架构的职责，也才是真正的 “王者”。

那区别卓越与优秀最根本的特质在哪里呢？我觉得关键在于两个字：眼界。有很多优秀的测试工程师，往往缺少了更开阔的视野而止步不前，于是，他们成为了世界的跟随者。当然，我也不敢自诩是这个世界的创造者，但是我希望能够让大家在通往卓越的道路上走得更光明一点。

坦白的说，我在出品这个专栏之前犹豫了很久，也跟我的很多学员聊过，曾经想把测试中的所有内容从零基础到架构做成一个全栈测试专栏。但是经过反复的思考，觉得一些测试方法、测试技术可能很难通过文字完全演绎出来。也许未来，当我找到一个好的办法的时候，会把这个主题重新做起来。在这个付费专栏中，我希望能够更多地给大家一些指导性、更有价值的东西，做一个不一样的测试专栏。

这个开篇我写了这样一个标题，“找寻测试的乐趣，做更好的 Tester”。这是我对自己的总结，也是对大家的希望。所以，在这个专栏中我会介绍的内容可能会包括：



### 学习方法

我印象中很深的一件事情，是在我读大学的时候，班上一个学习很好的哥们在竞选学习委员的时候说了一句非常经典的话：“为什么我要竞选学习委员，是因为我学习有方法！” 一时传为美谈。学习方法、记忆方法这些是我们在成长过程中遇到的最困难的事情。

在我长达数年的讲师经历中，见到了很多擅长学习、擅长解决问题、擅长提问的同学，当然更见过很多同学，遇到困难就懵，提问也难以 get 到重点，让他人无以为继。由此，我在这里要介绍的学习方法，其实是泛指我们的思维模式、提问方式、解决方案。也许，你可以一点就透，但是这不是个速成的东西，是需要花费时间和精力去体会的。



### 技术方向

这个专栏中可能会提及非常多的知识点，但是不会非常长篇大论展开来讲它们的使用，因为这些大家可以非常轻松地通过 Google 或者 Baidu。我们会一起讨论一下现阶段流行的测试方法，谈谈测试框架平台，放眼当前测试领域的探索，也会探讨下测试未来的无限可能性。

我会在这个专栏中能够给大家一个测试体系化的知识，所以将会从功能、自动化、性能、安全、测开、架构等角度进行一个全面的梳理。当然，这其中还会穿插了一些其它内容，比如一些热点事件，又或者是行业内测试圈的一些动态和趣事，能够让大家看到不一样的世界。

聊了这么多，我想说，没有一条真正的前进之路，但是我愿意把我这些年的所知所得分享给大家，希望能够对大家有所启迪。同样，专栏的形式我也是第一次进行，所以我非常希望你能够跟我分享你的感受与体会，我也将根据大家的反馈做出调整，努力提高专栏的质量。

最后，欢迎加入本专栏，我是风落，让我们一起从测试人的视角去看看世界。

## **02 导读 ： 拾吾初心- 我的测试进阶之路**

![图片描述](http://img.mukewang.com/5d6b6837000190c908990563.png)
大家看到这篇专栏的时候，要知道我是躺在这样一个位置上捧着笔记本完成的。为了避免大家看到我开始逐渐衰老并且变胖的面庞，所以还是不放本人照片啦。当然，这绝对没有让大家羡慕嫉妒恨的意思，而是恰好我觉得这样一个放空的环境更加适合我去回味自己过去的经历。实际上我发现自己回顾的过程很多画面一闪而过，就像很多电影电视里演绎的那样，但真的落笔下来，却发现又很难说清。

首先说明，我只算个普通的 IT 男，也算不上是一个成功的人，所以我的回忆也并不是什么成功学备忘录。引用不知道曾经在哪儿看到过的一句话：“活了 30 多年，生活只告诉了我一件事情：我只是一个智商正常、耐力一般、身体凑合、相貌平平的最一般的人。” 在这里把自己的过往做一个总结，一方面是对过去多年的梳理，另一方面也希望我的经历能够给大家带来一些参考和或许那么一丝丝帮助。



### 大学生涯关键字：时间规划

由小到大，我都是一个任性的人。小时候不太喜欢其他活动，而是喜欢在路边与大爷大叔们一起下围棋，到后来拜了师傅学了围棋还参加了不少比赛，再到大学期间建立了学校第一个棋社，名 “星河棋社”，兴趣一直是支撑我自己前进的源动力。

如果要准确地给大学生活一个定位的话，在当时的感受是一个字：忙；现在想来，却是两个字：精彩。希望开拓眼界，所以参加了学生会和科协；喜欢哈利波特，所以加入了英协还组织了哈利波特文化节；酷爱羽毛球和网球，所以时常在球场上看到我曾经 “精瘦” 的身影，还闯入了地区级网球业余比赛八强；乐于 “抬杠”，所以不仅担当了校辩赛的队员，还自告奋勇在下一年成为了领队；为了体验人生，所以在情人节的牛排馆里卖过玫瑰花、酷暑的太阳下做过问卷调查、街边的商铺中的拉过赞助、毕业季的湖畔兜售过书本杂物等等。我非常清晰地记得，曾经有过那么一段时间，我几乎是没有时间去上课，全部在校内校外忙碌。同时，作为 985 高校学生的一员，学的又是电子信息工程这样的综合性专业，基础课程多、难度大、更可气的是还有纯英文教材。一时之间觉得自己无论何时都感觉时间不够用，想做要做的事情还有很多，用 IT 的话来说，恨不得自己能够多线程并行甚至是异步地处理各种事情。

摆在面前的有两个选择：放弃一些活动或者想办法平衡这些活动之间的关系。接下来的选择是我觉得我在大学时代得到的很重要的一笔财富：时间规划的意义。具体来说，是把每天要做的事情分级，包括：a 必须要做的事情（比如上课、开会）； b 当天要完成的事情 ； c 无需当天完成但需要有进度的事情； d 当天不紧急的事情 ；e 娱乐休息。

在原计划中呢，本来是想以周为单位来规划，实际操作了一段时间，发现不可控的事情会很多，反而容易变乱，不如每天晚上拿出一段时间来规划下一天。首先，先把必须要做的事情所占用的时间占上，就像这样：

![图片描述](http://img.mukewang.com/5d6b686f0001310705580621.png)
接下来就按照顺序将当天要完成的、需要当天有进度的和自己的娱乐休息放进去，最后再加入当天不紧急可做可不做的事情，这样把一天排满。好处呢，是一方面能够把重要事情优先做完，同时也让自己更有条理地安排自己的时间，更提前准备好了自己的休息和娱乐。这也是我想跟大家分享的第一个经验吧，做自己时间的管理和安排者，而不要成为时间的奴隶。工作中也是一样，做事有计划，任务分主次，这样才能乘势待时，事半功倍。



### 兴趣 VS 职业：成为 IT 男

初中毕业时候才第一次接触到网络，第一次有了自己的 QQ，记得那个时候 QQ 刚刚从 OICQ 更名过来，也依稀记得那个时候 QQ 古老的界面，记得 QQ 上的第一个好友，也记得一直在询问我哥：“为什么这个叫 QQ 的东西可以不花钱互相说话”（当然，后来才知道，网吧 “居然” 也是要花钱的 -_-||）这大概是我对互联网最初的认识。

虽然本人长相粗犷，但是却有另外一个小资的爱好：散文。喜欢看也喜欢写，高中时期进入了当时还赫赫有名的榕树下，开始自己的散文之旅。这或许是我跟网络文学的首次亲密接触吧。接下来的一段时间内，随着博客的火爆，又建立了自己的博客，还收获了一批粉丝。PS： 刚刚偷偷去看了看自己的博客，发现当初幼稚的文青散文已经把年老的自己吓坏了…… 也因为这样，对能够搭建一个像榕树下这样的论坛或者是博客这样的平台非常向往。

于是乎，大学就选择了电子信息工程系。但是上学以后突然发现，这个专业跟想象之中的 “网络”、“信息” 似乎毫无关联，学习的也都是偏向物理、数学方面的基础理论，动手机会都很少，更不要说是创造什么了。幸好，除了枯燥的学习，大学还提供了非常丰富的能力培养机会和广阔的个人发展空间，所以有了上述如此多的校园活动，也随之有了我自己的第一次 “编程” 尝试。

不知道有没有同学看过《这就是铁甲》，我在大学时候就参与了一个类似的机器人大赛。与遥控机器人不同的是，我们要做的机器人是全自动巡线机器人，这时候用的是汇编语言和 C 语言。尽管是边做边学，但是当机器人在实验室里第一次正常跑起来的 “一刹那”，突然有一种 “触电” 一般的幸福感，感觉依靠着一些代码加上传感器等硬件，就可以让一台机器跑起来，非常不可思议。于是，也对代码的神秘产生了更大的兴趣，毕业设计时候也选择了一个现在看来依然非常流行的课题：“基于神经网络的车牌识别系统”。
犹记得当时孜孜不倦地到处收集车牌样本、完善神经网络算法、在各大论坛中到处求大神指教，而收获得让我最开心的评价是在毕业答辩时候系主任的一个评价：“这个系统不错啊，可以拿出去卖钱了。” 这句话给我的 IT 生涯打下了坚实的一步。
所以在毕业时候，我倾向于加入一个 IT 企业，在当时我们的专业里，其实去做 IT 是比较另类的选择，绝大多数同学都去做电子线路、移动运营商或者华为中兴等硬件企业。但是就像我前边说过的，我是一个任性并且以兴趣驱动的人，由于跨专业的限制，我错过了一些大公司，最后初步进入了一家外包公司，成为了一名 IT 男。

现在回头看，其实互联网改变了很多事情，10 年前我们还在用 1 毛 1 条的短信互相联系、查资料还需要到图书馆里、初到陌生城市还需要先买一份地图；现在呢，有方便实时沟通的微信，有无所不知的百度，有遍及各地的地图，当然更有出门几乎不用带钱的支付宝。想来，互联网真的是可以改变世界了，看看我自己，也改变了我自己很多。



### 转型：从 DEV 到 Tester

进入了一家外包公司，很多人觉得福利差、没有归属感、也没有技术大牛带，我倒是觉得更加容易锻炼自己，外包公司更加让人有紧迫感。比如说我自己，开始是做开发的，语言呢是用 Flex + Java（Flex 是做 flash 动画的），初入公司的我还对 Flex 一窍不通，对 Java 也是一知半解，然而就是这样，在简单学习了一周后就被任命独立去做一个紧急项目的开发工作。于是经过了多达 7 个通宵，才勉强完成了项目的工作，尽管那个代码在我后来看来真的是 “不堪入目”，但是对于一个刚毕业的学生来说，已经是一个莫大的锻炼和安慰了。

走上测试的道路却是一个意外：当时自己完成的一个自认为代码很健壮的项目被测试团队发现了很多缺陷，所以对测试工作产生了好奇，同时也在一些技术论坛中了解了一下测试的相关工作。突然发现，测试跟想象之中的不完全相同，在当下，测试工作同样需要技术，而且对技术的要求越来越高，需要了解的知识领域甚至会比研发更加宽广。

在 IT 圈中流传着这样一句话：有的人喜欢创造世界，他们做了程序员，有的人喜欢拯救世界，他们做了测试员！相比于 “创造世界” 的研发人员，我似乎突然一下子对 “拯救世界” 有了很浓厚的兴趣。后边一次很偶然的机会，我转到了测试工作上，主要负责的也是与代码有关的测试，包括自动化、性能方面。当时的自动化测试还是以 QTP 为主，而我也是逐步将公司的 QTP 代码转换为了 Selenium，尽管当时还是 Selenium1.0，但是我觉得这种代码的模式会比 QTP 拥有更好的扩展性。所以想来，用今天的话来说，我是直接进入了测试开发领域，尽管当时没有人这么称呼它。

随着工作的深入，骨子里的好奇心和兴趣驱使我更加深入挖掘测试相关联的技术，从自动化技术的探索，性能场景、监控、分析等方向的研究到后来安全渗透测试的挖掘、框架平台的搭建，MOCK 平台再到 DOCKER、DEVOPS 的应用等等，到现在已经有接近 10 年的时间了，一直走在这条路上，不断前进。而且，到现在仍然没有看到自己潜力的终点。

在这儿也多谈几句展望，我自己觉得，未来开发和测试是统一的，界限也会越来越模糊。开发的压力往往在于工期紧，有些需要技术研究等，目的在于建设实现上。测试的压力也有工期的问题，但测试的责任压力是非常重的，如果有问题发生往往第一责任人是测试，因此要求测试特别细致，同时需要考虑的功能也要全面，工作量并不比开发少。



### 回归初心

未来开发和测试是统一的。开发的目标是创造、建设和实现，随着技术的成熟，开发人员的压力往往在于工期紧。测试的压力除了工期的问题，还要保证的就是我们的质量。质量才是我们测试人员的 “初心”。所以无论是通过自动化、性能还是安全，最终的目标都是质量二字。未来对于测试人员首要的要求是 “质量高”，接下来的才是 “效率快”。而我们的技术呢，也是围绕着在保证质量的基础上提升测试的效率，这就是现在大家聊得更多的测试开发甚至是测试架构。

大概从 11 年开始，由于常在各大论坛中与人探讨测试相关的技术，所以与一些志同道合的伙伴开始在网络上进行测试技术的分享。从最初的论坛讨论到后来的在线公开课分享、《LoadRunner 性能测试巧匠训练营》的编写出版再到成为慕课网的讲师以及今天大家看到的专栏，最本质的目的都是为了能够把自己走过的一些路分享给大家，让大家能够尽可能少走自己走过的一些弯路。

回顾过去的十几年，我认识了很多朋友，他（她）们对我有很大的帮助。让我从一个对计算机并不开窍的小菜鸟，逐步成长为现在算是真正的技术 tester。在这十几年中，经过一次又一次地思考、实践与挫折，我找到了适合自己的方向，发现了自己的优势，也不断调整自己的目标与方向。现在的我，愿意把自己走过的一些弯路、自己的一些心得与技术沉淀，通过这篇专栏分享给每一个正在看这个故事的朋友，希望大家能够找到自己的 “本心”，不忘自己的 “初心”，成为一个优秀而快乐的测试人。

# **第2章 学习方法**

## **03 从码农到“匠人”-论测试人的自我修养**

### 何为优秀的测试人

经常有同学私下问我：“风落老师，怎么样才能算作一个优秀的测试工程师？” 即便是工作了十几年的我也很难一时之间妄下这个定义。被问得多了，最近很是认真地思考了一下。当然，作为一个还在 “路上” 的测试人员妄谈 “什么叫优秀” 似乎有点不知天高地厚，所以大家仅可当一家之言，或者叫 “风落眼中的测试人”。

聊什么是优秀，先要聊聊我们自己对测试人的定位。就像标题中写到的，如果你把自己定位成一个码农、一个屌丝程序员，那你或许奋战在 IT 一线，可能衣食无忧，但最终也只是个浑浑噩噩、无所追求的屌丝。眼中的世界有多大，你就有多大的空间。换言之，你的眼界在某种程度上决定了你的未来。所以，相比之下我更愿意用 “匠人” 来形容一个好的测试人。书接前言，测试并不是一个毫无技术的领域，现阶段的测试对技术的依赖更广更全面。所以，当你不断打磨自己的技术和能力，拯救了一个又一个影响世界的产品时，你就会发现，在别人眼中，你也不再是屌丝、码农，而是大神。这是我对 “优秀” 最简单的定义。



### 聊聊测试人的 “段位”

上大学的时候曾经有一段时间 Dota 风靡，我也加入了 Dota 大军，工作以后实在没空打开电脑开一局 Dota 了，但也短暂地玩过一段王者荣耀。也许是因为有 Dota 基础的原因吧，我很快一路爬升到了钻石段位，可是想再进一步却也很难了。这么一想，似乎王者与软件测试的 “段位” 有异曲同工之妙，那今天我们不妨就以王者荣耀的几个段位来看看测试人。

**青铜** – 初入测试大门，对测试的整体认识还不够，只能跟着老测试人员后边手指舞动，负责执行一些测试用例。拘泥于招式，不求有功但求无过。这是第一层境界：学招求技。

**白银** – 大概工作学习了一段时间，开始能够照猫画虎地编写一些测试用例，能够在测试团队已有的框架下完成部分测试工作。对于自己所测试的软件呢，也有了一定的了解，对常见的易出错的情况有了自己的整理和总结，测试过程开始有了自己的主见，会进行一些超出测试用例的测试，发现一些 Bug。但是仍然局限于已有的框架，有想法却没有太大变化。此为第二境界：循前人所创，中规中矩。

**黄金** – 对基本的功能测试用例设计和测试技巧已经能够融会贯通，就像王者荣耀到了黄金段位会开始嫌弃 “猪队友” 一样，测试人员到了这个阶段也开始评价吐槽开发人员。同时，对基础测试方法的低效感到不满意，但是无奈自身功力不够，只能想些 “另辟蹊径” 的小方法提升自己，迂回战术解决问题。此为第三境界：旁门左道，剑走偏锋。

**铂金** – 这是测试人提升自己最快的阶段，这个时期大家开始认识到团队配合的重要性，也能完全 hold 住自己的工作内容。同时，认识到了技术的重要性，在自动化、性能、安全亦或是代码等某一个或者两个以上的领域进行了突破和学习，基本能够将网络上、在线课程中的技能知识为己所用，将这些技术融于项目中，提升测试的质量与效率。此为第四境界：天下之术，皆为我用。

**钻石** – 到这个时候的测试人已经有了相当丰富的经验，同时也是测试人提升自我的疲惫期。自己可能会感觉到对于各项技术已经成竹在胸，似乎对自己努力的方向和前景产生了迷茫。如果能够度过自己的迷茫期，就会发现与其综合天下之术，更有效果更有成就的是根据项目的实际情况建立属于自己的测试架构，又或者是可以根据自身和团队的需要开发相应的测试工具。这个时候已经告别的纯测试阶段，走上了测试架构的道路。此为第五境界：盖世神功，深不可测。

**星耀** – 星耀级别的测试人，都已经是可以独当一面的大人物了。这个时候的你，已经迈出了自己职业生涯关键的一步：或是成为了测试架构师，又或是成为了成功的管理者。除了自己能解决问题给出方向外，还需要全盘考虑整个部门甚至是公司的技术方向或者是管理方法。

由于我自己是个绝对的技术崇拜者，那么从架构方向上可以多跟大家聊一聊。在这个阶段，你所知所能的就不仅仅是已有的框架、已有的技术，而是开始研读一些开源框架组件的源码，不甘于仅仅运用，而是突破现有，从 “拯救者” 到 “创造者” 转变。此为第六境界：自创武功，成就一派。

**王者** – 王者已经是这个世界上顶尖的、被人仰望的存在了。这时候已经无所谓技术了，测试与开发的边界也已经不存在了，这时候应该考虑的是项目的架构如何实现？怎样进行高可用设计？如何推进 Devops/Testops？重要的不再是技术，而是沟通能力、带队能力。当然，不是说技术不重要了，而是要在拥有技术的基础上能够做更多。此为第七境界：无招胜有招。

**荣耀王者** – 似乎荣耀王者不是个段位，而是个称号了。所以对于测试人来说，这个境界可以算是 “你不在江湖，江湖上却有你的传说” 。无需出手，只需运筹帷幄，此为第八境界：不武而胜。

到这儿，估计好多武侠迷们发现我一不小心借用了金大侠的武学境界。其实不论武学、游戏又或者是我自己更加熟悉的围棋段位，跟我们在测试上的进阶方向都是一致的。我自问已经走上测试道路十余载，也不敢说自己完全达到甚至突破了星耀级别。测试的道路上没有代练，但是有良师、有队友，不贪心、不着急、不放弃，路要一步一步走下去。



### 再谈优秀测试人的 “自我修养”

如果非要按照前边的段位给 “优秀” 设定一个门槛的话，我认为达到铂金是从普通到优秀的标志。环顾四周，想来我身边、朋友中可以达到这个标准的还不少，既然开篇就提到，不敢妄谈 “优秀”，我就简单总结一下优秀测试人所共有的品质素养：



#### 敏感

软件测试最本质的特征是要善于发现产品中的问题与不足。一个优秀的测试人员要对被测内容保持一种敏锐的感觉。这种感觉不仅仅是从产品的正面角度，也要从客户维度考虑，甚至有些时候还要保持对架构的敏感。比如说，我们的架构设计中包含了缓存、消息队列，那么我们在考虑测试方案时还需要充分考虑缓存清理、消息队列消费、超时重发等异常场景。这样的敏感度除了职业上的特征，还需要对测试经验和扎实技术基础的掌握，才能如猎狗般快速嗅探出其中的 “不对劲”。



#### 好奇心

工作之中不可避免的就是发现问题，而一个优秀的测试人员不仅仅停留在发现问题上，而是进一步好奇：问题的根源在哪里？问题是怎么发生的？又应该如何解决？有个 “王者” 曾经说过：软件测试的最高境界就是教开发写代码。我一直深以为然。而好奇心就是探索未知、探索深入的 “本心” 所在。

当然，这是好奇心的一个方面，另外一方面则是对技术的好奇心。软件测试的日常工作是枯燥的，保持技术的好奇心，才能提高自己工作中的积极性，也能够促使自己用技术的手段提高测试效能。



#### 脸皮厚 + 幽默感

既然测试工作就是给别人找 “毛病” 的，那冲突自然不可避免。这就好比，你在路上看到一个美女，走过去告诉她：妹子，你这样上身羽绒服下身丝袜的穿法是不对的，不但冷热不均，还容易得老寒腿。我估计美女不是自己揍你一顿就是让身边的男青年揍你一顿。

而事实上，测试人员做的就是这样的工作，当开发人员把自己呕心沥血的得意作品提交给我们之后，一转眼到我们这里一会一个致命错误，一会就是操作性有问题，这种打击估计很多开发人员都要在心里默默问候测试了。那怎么办呢？不要觉得丢脸。脸皮厚一点，同时也要保持嘴甜，再加之以你自身的幽默感，足够让开发不好意思拒绝你的各种问题和要求。



#### 自信乐观

自信是一种心态，“自信人生二百年，会当水击三千里”。生活工作难免遇到困难，首先自己心中要有信念，相信自己，才能克服一切艰难险阻。这不是一句鸡汤，而是一种生活态度。

乐观亦然，无论处境多么悲惨、境遇如何恶劣、道路几多坎坷，都需要一种乐观的心态。乐观不仅仅是一种态度，更是乐观之下更冷静、自信地去处理问题。

我自己也好，认识的一些朋友也好，工作中困难过、被排挤过，但是咬牙坚持、直面处理，或化干戈为玉帛，或化悲痛为力量，当你经过那一道坎，自然也蜕变出了更加自信、乐观的气质。



#### 热爱生活

人大概可以分为三类，第一类是极为热爱生活，第二类不上不下，第三类则是愁云密布，对生活毫无热情。大多数成功人士身上都有一种特质，就是对生活极其热爱，给人的印象更多是阳光、积极的。所以除了热爱我们的工作以外，在工作的八小时（或者更多一点）之外，去寻找自己的兴趣爱好，丰富自己的生活。

我所熟识的 IT 友人中，如意者大多是对生活充满热情的，像小说或电视上演绎的书呆子型的 IT 男 / 女着实是很不多见，工作之余有人插花、做菜、布置，也有人健身、徒步、旅行，丰富多彩得很。就以我自己来说，忙碌的工作之余，每年我一定会抽出时间旅行，而且更喜欢自然风光的旅行，从风情小镇的瑞士到恬静静谧的马代、从空气清新的云南到逛吃逛吃的台湾，到处都留下了我的脚印。同时，我还是个吃货，每到一个新地方，第一时间一定是挖掘各路美食。加上不时去打个羽毛球、戳一杆台球、玩会儿手游，不断充实自己的生活。不要说没有时间，我相信测试人中十有八九不会忙过我了……

还有，练习怎样用更动人的语言来赞美你的另一半，这会让你的生活更加美好（无论男女，这都是我们最基本的素养）。

Ok，以上呢是我的一些个人总结和感悟，那么各位看官，你觉得自己现在是什么 “段位” 呢？测试人还有哪些自我修养？欢迎大家一起讨论。

## **04 努力≠高效-测试高效学习浅谈**

### 学习与努力

最近有个学员私下跟我聊天：风落老师，我觉得我很努力了啊，怎么这个内容还是学不会记不住啊？“努力” 是我们经常听到的一个词，从小时候我们就开始背 “少壮不努力，老大徒伤悲”，到后来 “业精于勤，荒于嬉”。在高考的路上，也不乏很多努力的人，提前准备、通宵学习，各种习题册做到手软，但是最后考试的时候却意外落榜，难道是他不够努力吗？答案是否定的。

也有同学问我：老师，我感觉我听课时候都明白了啊，怎么一做时候就不知道怎么做了呢，我是不是太笨了啊？！答案自然也是否定的。

智商差异可能存在，但是没有想的那么夸张，天才太少了，至少在我的人生中见识到的天才几乎没有，所有所谓 “天才” 的背后都付出了大量的努力和思考来成就。但是，努力与努力不同，努力更不等于高效，在这上面更重要的是方法。高效的学习方法能够提高你的效率，将宝贵的时间用在最需要它的地方。

所以，如果要把努力和高效之间必须做一个方程式的化，那么应该是：

**努力 + 方法 = 高效**



### 拿来主义

拿来主义是我们从小学开始带来的学习方法。学习数学，我们要背相应的数学公式而不去考虑它的推导过程；学习物理，无论是牛顿、欧姆还是左右手定律，我们都直接死记硬背下来就好；学习语文，老师告诉我们作文应该怎样通过写议论文稳稳拿分等等，我们一直都在用拿来主义的方法学习。这样对么？到大学为止，拿来主义当然是没有问题的，我们自然没有必要把数学家、物理学家总结过的方程定律重新推演，我们直接拿来结果就好。

到了测试工作中，其实也是一样，我们尽可以把已有的工具，比如 LoadRunner、Jmeter、Postman 等等拿来而用，亦或是一些已有的开源框架：Selenium、Appium 等等。所以拿来主义带来高效是没有问题的。

其实我们在这里默默的给拿来主义划了一个范围，也就是已有的知识已有的工具框架。然而现在很多人把拿来主义的概念混淆了，不管是公司里、还是各种 QQ 群中，都有很多同学抱着 “拿来主义带来高效” 的想法，只要自己有问题，立刻马上在群里问。所以我收到了很多这种请求：“最新的 jdk 版本是啥，在哪里下载”，“Java 环境变量怎么配”，“公司给我布置了一个任务，我不会，谁帮我做一下发给我”。

Ok，拿来主义到这里一下子变成了懒惰主义。事实是，别人可以帮你一次两次，却不能永远时刻帮你，而一直以拿来主义为宗旨的人，也很难真的学到知识和能力。

所以，拿来主义是一种很好的快速学习的方法，但是一定不是一种很好的提问方式。后边，我们会有机会跟大家一块好好讨论下 “提问” 的那些事儿。



### 技能掌握的层次

知识的掌握是分层次的，而在我们的测试领域亦然，我们一起由浅至深逐步探讨一下：



#### 第一层：死记硬背

假设你明天要参加一场笔试，一家你非常心仪的公司。但是由于时间问题，你几乎没有做太多的准备，而你要笔试的内容是你几乎没有太多了解的领域。而你想在这场笔试中拿到高分，恰巧不久前刚刚有朋友参加了这场笔试，还全程记录了下来。于是，你找到了朋友中这个领域的专家，帮你做出了标准答案。你呢，花了一夜的时间把答案拼命背了下来。第二天你笔试的成绩，甚至可以比那些日常工作就是这个领域并且花了很多时间准备的人答的还要好。

当然，这样做的坏处就是这些所谓的知识，除了可以用在你这场笔试的卷子上，在其他情况下，这些知识就是完全无用的。想来高考补习班、考研押题班大多用的是这种方法，应试教育中标准答案的存在，给了人走捷径的可能。



#### 第二层：记忆储备、理解、可检索

到了这一层，其实就是了解技术的背景是什么，在什么场景下运用，以及其中一些概念的含义，但可能在具体场景使用上的细节不太清楚，通俗来说，就是知道学了这个可以干什么，大体怎么做，但是落到具体实践上可能做不出来。

再举一个例子，今天你看到了一篇文章，是讲解关于 Jmeter+Beanshell 的使用，于是你明白了什么情况下可以使用 Beanshell，清楚了实际上 Beanshell 就是在 Jmeter 里执行 Java 类，但是具体怎么在 Jmeter 里配置使用就不是特别清楚了。

这天，有个朋友和你说：XX 啊，今天我想用 Jmeter 接口测试的过程中想额外地调用开发编写的一个 Java 类，可是不知道怎么做才好。

这时候，你提取到 Jmeter 和 Java 的相关信息了，根据之前记住的理解的，跟朋友说：你这个可以用 Beanshell 直接写一个 Java 类，然后在 Jmeter 里边调用啊。

朋友一听，非常高兴：XX，你好棒啊！

仔细分析了一下，其实呢这个时候你的头脑中对于 Beanshell 还只有一个大体的理解，当朋友说到 Jmeter、Java 一些关键字的时候，你自动检索了相关的知识出来，尽管并不太清楚细节，但至少是可以开始操作的。

当然，如果这时候朋友再多问一句的话就很尴尬了：那能教教我怎么做么？



#### 第三层：消化、可为己用

如果说在第二层还仅仅停留在求 “知” 阶段的话，那么到这一层，就应该可以算作是由求知突破到了学技。简单来说，到了这一层，已经理解并消化了应该怎么做，并可以把自己的知识应用到解决实际问题上。

这一天，另一个朋友又和你说：XX 啊，今天我想用 Jmeter 接口测试的过程中对数据库进行备份还原处理，本来是可以用 DBUnit 来做的，但是在 Jmeter 里就不知道怎么把它们集成到一起了。

这时的对话里已经没有 Java 的相关信息了，但是你知道这是类似的场景，是可以处理的，于是跟朋友说：你这个可以用 Beanshell 引用 DBUnit 写一个数据库处理的类，然后在 Jmeter 里边添加 Beanshell 的处理器调用。

朋友一听，惊喜到：XX，你果然是 Jmeter 问题的解决专家啊，太给力了！能教教我怎么弄么？

你很自信的说：没问题，我一会帮你写个 demo 出来给你。

看，到这个时候，你的学习内容已经可以自由使用了，或者换句话说，只有到这里，你所学的知识才变成你自己的，而不是那些你只能检索的文字信息流了。当然，涉及到经验和熟练度的问题，当我们对知识使用考虑得越多，那么解决各种相关问题的速度就会越快。



#### 第四层：深化、归纳、创新

到目前为止，我们的知识使用还仍然停留在模仿阶段，只是模仿的程度有高有低。从模仿到创造之间还需要一个归纳的过程。

还以刚才的例子，你发现原来 Beanshell 相关的需求有这么多，公司里组件使用非常频繁。与此同时，使用过程中还发现很多 Jmeter 不能兼容的场景。你发现当前的知识仅仅是掌握已经不够了，还要更进一步，所以你开始仔细研究 Jmeter 的底层代码，归纳总结自己的各种需求，最终二次开发增加了一个组件”Beanshell2.0”，使用这个组件可以完美兼容。

再后来，为了解决很多同事觉得 Jmeter 这些组件化不太便捷的情况，所以针对自己公司的现状，在 Jmeter 之上搭建了一条平台，可以简单配置进行接口自动化测试，并且兼容各种组件和”Beanshell2.0”。

这样，我们就通过了深化、归纳和创新，对知识和技能进行了进一步的整理，不仅仅变成了自己的，还创造出了前所未有的技能，也成为了新一轮知识的源头。



### 记忆方法

在小时候我曾经去学过一些快速记忆的方法，想来比大家来说对记忆的理解更深入一点。可能有的同学看过一个节目叫做《最强大脑》，无不对里边选手超强的记忆能力叹为观止，我们就从这里聊起。这种记忆方法我们称之为联想记忆法，无论是现在的记忆训练、早教市场还是到节目中的记忆竞赛，都是使用联想记忆法中的一个分支，称之为 “记忆桩”。核心的原理呢，是用已知的一些信息对未知的、零散的、没有逻辑关联的信息进行加工，通过故事的方式进行记忆。关于记忆桩的记忆方法可能最有名的就是记忆宫殿了，据传亚里士多德经常使用记忆宫殿的方式来记录演讲稿等内容，我个人感觉记忆宫殿之所以出名，大概是因为多年前的一部港剧中有一个记忆宫殿杀人的场景，所以让大家印象深刻。关于联想记忆的资料网上应该很多，感兴趣的同学可以自行搜索。

这种方法由于比较适用于去记忆一些没有逻辑关联、随机的、无序的信息。而因为很多人对记忆力的评价是，短时间内能记住多少随机的信息，所以这种方法非常受推崇和欢迎，然而实际上，尽管我很深入地学习研究过，仍然认为这种记忆法只适用于表演或者比赛，对于我们日常生活中的记忆毫无作用，因为这始终是第一层 “死记硬背” 的学习方法。

**那么，什么才是适合我们现阶段记忆的方法呢？**

其实我们最常用的记忆方法就是**反复记忆**。从上学开始，无论是背课文还是背单词，都是先不断朗读，逐步加深记忆。但是很快，我们发现这种记忆方式的效果不好，为什么呢？因为人如果机械重复地记忆一件事，很容易走神，毕竟读是不需要调用太多注意力的。

在这样记忆基础之上，我们会引用**回忆记忆**。什么是回忆记忆呢？通俗一点来说，比如我们要背单词，那就先朗读两到三遍，然后闭上眼睛，默默用手指写一遍，看看是否能写下来；如果不行，再重复这个过程。

这样做的好处就是，通过回忆来迫使大脑认真的记。我猜可能很多同学都看过一些高考学霸的采访，很多人都提到每天睡觉前会把当天学过的知识点重新回忆一遍，这就是再次把回忆记忆升级，变成主动回忆，帮助他们把知识记得更牢。

不知道有没有同学有这种体验，比如我们去看演唱会，有的人会拿着手机、摄像机全程拍录，而有的人只是全程去享受，往往后者会比前者更容易回忆起演唱会的各种细节和场景。因为有了录像的人，会下意识地反应已经录制好了，就没有必要花大力气用在记忆中了。这就是回忆记忆带来的压力。

仅仅是记忆实际上只能让我们把知识技能掌握到第一层到第二层之间，为了达到更好的效果，我们尝试着去边学边做。这就好像我们上学时候，为什么每学一个知识点，老师都要留一些作业给你呢？目的就是为了不仅仅要记住知识，还要能应用。你会主动地去了解它更多的细节，提出问题和尝试回答，查找资料。这种方法其实已经超过了纯记忆，是记忆 + 理解的综合体，用这种方法得到的技能和知识，往往能够掌握到 2-3 层之间。我一向比较推崇这样的记忆方法，比如我们去看一本书或者学习一个实战课程，希望大家不仅仅是听，而是边听边学边练，加深理解性的记忆。

在场景记忆的基础之上，还有一种更深刻的记忆方法，我们称之为特殊场景记忆。大家可能会有一种特殊体验，某些在特殊场景下说过的话特别容易回忆起来，你犯过错误的地方再次改正之后会记得特别牢，这就是特殊场景记忆的优势。



### 测试高效学习

有了对技能掌握层次和记忆方法的铺垫，接下来我们可以聊聊高效学习了。在聊学习的过程之前，有一个前提很重要，就是 “**学习的仪式**”。

也许有人发现过，在不同环境下学习的效率是不一样的。我在上学时候复习功课时，在宿舍 - 湖边 - 图书馆 - 自习室这四个地点学习的效率相差很大，后来自己做了培训讲师，有了线上线下的学员，才真正搞清楚 “学习的仪式” 的重要性。

所以，我们在去看一本测试书籍、或者是在慕课上学习一门测试课程之前，应该做下面几件事：



#### 1. 使用电脑，完整时间

尽管现在移动端非常便捷，但是测试学习更多的是技术上的学习。就像前边说的，仅仅是听和记忆还不够，需要去动手去做。这就决定了我们使用电脑的效果会远大于其它终端。如果有条件的话，甚至推荐笔记本 + 显示器的组合，这样能够边听讲边进行笔记记录和试验。同时，技术的学习是排他的而连贯的，我们尽量把同一部分内容放在一起集中学习，达到 1+1 大于 2 的效果。毕竟技术学习不是看电视剧，我们不但需要精准记忆，还需要深入理解，所以一段完整时间是必要的。



#### 2. 处理好其他琐碎的杂事

在开始学习之前，先把诸如上厕所、拿杯子、接水这些琐事做好，防止在学习的过程中因为这些事情分心。



#### 3. 解决掉你的手机

之所以单独把手机提炼出来，是因为当下而言，手机的干扰性太强了。朋友信息、软件推送、游戏、小游戏活动，甚至手机本身都会影响到你贫乏的自制力。所以，我的建议是把放到远远的看不到的地方去，除非有紧急联络人的特殊电话，否则其他情况下一概不理。



#### 4. 保持整洁的桌面

我自己本身就有个不好的习惯，学习看书的过程中特别容易因为周边的东西分神，所以经常出现在我看书或者研究什么的时候，边上的一个摆件突然吸引了我的注意力，让我的思维停止几秒钟。就因为短暂的中断，可能我需要十分钟甚至半小时才可以找回之前的头绪。整洁的桌面以及伸手可得的学习工具都可以帮你减少干扰，保持状态。



### 怎么让学习的效率能达到最大化

完成了这些，我们可以开始学习了。我举个例子来介绍怎么让学习的效率能达到最大化：比如我们今天要在慕课实战课程中学习 LoadRunner 的 Vugen 使用。学习的过程是我们整个高效学习中最核心的部分。

在这里，我们尽量遵循 “**预习 — 听课 — 自我实践 — 回想**” 这样的过程来学习。



#### 1. 预习

相信很多同学是很少做预习的，甚至上学时候老师布置的预习也很少完成。但是我却觉得越是到了工作中的学习，预习就愈加重要。预习的过程不是为了弄懂某些知识，而是了解重点，做好准备，不求甚解。所以，学习 LoadRunner 的 Vugen 使用，我们通过预习会把 LoadRunner 安装破解完成，避免因为后续的安装工作而分散学习课程的注意力；

我们会提前了解一下 Vugen 中各菜单、功能的名称，避免因为课程中提到的某些按钮功能，自己没办法快速 get 到；我们会事先了解一下课程的概要内容，方便自己把精力分配到不同的阶段内容中去。这样，当你听课的时候，就会意识到，老师要讲的 “参数化” 部分可能比较重要，要仔细去听，我们预习的目的也就达到了。



#### 2. 听课

一般来说，目前的视频课程每个段落都不会超过一小时，即便如此，人的注意力也很难均匀的分配到一个小时之中，所以前边预习的意义就体现出来了。对于重点和难点的部分，以及老师提到的 “敲黑板” 的部分，提高自己的专注度，去学习一节课中最有价值的部分。

如果说 “听” 是一个输入的过程，那么记录笔记就是一个输出的过程。所谓好脑子不如烂笔头，笔记是一定要做的。

但是这里边笔记不是说把视频的 PPT 内容记录下来就好，整理笔记其实是一个理解的过程。推荐大家通过思维导图的方式进行总结，通过课程的学习理解提取出重点难点，并绘制到思维导图上。

这样，未来再复习笔记的时候，会多花时间去从记忆中提取这部分的知识，那么这又是一个巩固的过程。通过多次的复习，你对知识点的记忆和理解也会加强。



#### 3. 自我实践

听课只是在帮助你学习，但是如何将技能通汇贯通，熟练地去运用它，还需要自我实践的。听课的同时或者是之后，一定要实际去做一遍。比如 Vugen 脚本的录制、修改、参数化、校验点等等，只靠视频讲解是远远不够的，只有你理解一遍操作成功一次，才能够把技能的掌握程度提升到第三层。在操作的过程中你也会发现更多在听课过程中发现不到的细节问题，接下来解决问题的过程也是对知识的特殊场景记忆。

同时，移动端和零散时间也可以再次利用起来，把一些第一次没有听懂的内容，或者实践中有问题的地方，带着问题去二次学习，能够获得更大的收获。



#### 4. 回想

回想其实是我们思考的过程，建议大家在学习之后要把学过的内容回忆思考一遍，这是回忆记忆方法的一种，也间接帮助我们进行更好的学习理解。

我相信，如果大家能够做到以上几点，学习的效率应该能够更上一层楼。当然，学习和理解的过程中一定会遇到问题，那遇到问题该怎么办呢？且听下节分解～

## **05 你不是一个人在战斗 - 遇到问题的正确姿势**

在我们实际测试学习的过程中，不管你是在进行功能测试、环境部署、代码编程、工具使用、框架搭建等等，都不可避免的遇到各种各样的问题。遇到问题，一有不顺利了就去找别人请教，这样是不可取的，非但透支了与他人的关系，更是对个人的学习和记忆不利。就像我们前边聊过的，懒惰的拿来主义并不能带来效率上的提高。

然而实际面对问题的时候，很多人都会突然不知所措，找不到任何头绪。那么应该怎么办呢？我在这里简单总结一下测试遇到问题的一些常见的排查方法。



### 确认是否环境问题

在大家实际遇到的问题中，我大致总结了一下，大约有 50% 的问题是由于环境引发的。比如，有的同学在启动 WAMP 的时候发现 MySQL 启动异常，于是非常生气地告诉我：这个 WAMP 不能用，启动报错。其实仔细排查一下就会发现，由于本地已经存在一个运行中的 MySQL 服务，占用了 3306 端口导致启动失败。

再例如，我们使用 LoadRunner 录制脚本时，无法弹出 IE 浏览器，这时候需要考虑的环境因素就比较多了，包括操作系统版本、LR 版本、浏览器版本以及浏览器设置。当然，我了解，大家很多对这些环境问题不甚了解，自己很难排查。我这里推荐大家一个很简单的判断方法，就是当遇到工具安装和基础使用的问题，而明明网上以及老师都可用只有你不可用时候，那么八成就是环境问题，先去查询排查一下。



### 错误日志的作用

不知道是不是因为我的要求过高导致的，我在去很多企业做内训、以及线上线下学员沟通都发现一个通病，80% 以上的测试人员不去看日志。很多人回答我说：测试为什么还要看日志，找开发不就好了？这是一种很浅显的理解，觉得测试人员最重要的就是发现问题，至于找问题，NoNo，那就交给开发人员搞定吧。

我们从两个角度来说日志的作用。先说我们在测试的过程中发现了 Bug，既然测试人员不需要修正 Bug，那么到底还需不需要能看懂日志，需不需要找到问题发生的点和原因呢？我个人觉得是十分必要的。在中小型公司里，之所以测试不受重视主要在于测试只去做 “测” 的工作，而实际上在一线互联网公司里，测试人员需要承担的职责更多，不仅仅是发现问题，还包括定位问题、指明解决问题的方法。

通过对日志的分析，也能更进一步了解发现问题到底是由于环境、数据、上下游系统还是系统本身的 Bug，也避免了提出更多的无效问题。举个例子来说，当我们系统异常难以排查时候，我们发现日志中包含如下问题：

![图片描述](http://img.mukewang.com/5d6c8f5600014d9c12500547.png)
Ok，这是我们在前端看不到的错误信息，通过这里，我们确定，这个错误是由于后端分库分表算法计算异常引起的。那我们可以更深入定位一下算法的问题，也可以直接将该算法存在问题提给开发，这样呢，就减少了很多开发排查问题的工作量，也更容易赢得开发的尊重。

上面的第一个角度，换个角度来说，我们测试人员自己也会在工作过程中碰到自己的问题，有的是代码端的，有的是工具端的。比如 Selenium 执行报错，比如 LoadRunner 录制报错，这个时候请求开发明显是更加不靠谱的，还是需要自己首先解决问题。Selenium 脚本执行时候有时候会遇到错误如下：

![图片描述](http://img.mukewang.com/5d6c8f6c0001309412490141.png)
我们找到核心关键字，有经验的同学这时候就知道了 elment not visible 可能出现的情况有两种，一是定位的标识不唯一，二是元素之间有所遮挡，所以我们要开始分别排查两种情况的可能性，这就是我们分析问题的过程，处处离不开对日志的分析。Jmeter、LoadRunner 这样的商用工具同样有自己的错误提示，同样可以帮助我们去分析问题。



### 善用搜索引擎

其实这一点算是前边内容的延伸，既然要独立解决问题，就少不了搜索相关问题和解决办法。曾经跟测试圈里的某资深专家聊天时候提到过：其实现在绝大多数的人不会用搜索引擎，现在回想一下，深以为然。我猜可能有很多同学会觉得不服气，但是最近至少几年我遇到的很多学员的问题都是由于 “不会搜索” 造成的，比如说：最近有个同学问我，他想找一段随机产生手机号的代码，可是怎么搜都搜不到。我觉得比较好奇，就追问他自己是怎么搜的，他说搜索 “随机手机号”，出来都是什么生成器啊之类的，没有可用的代码。我告诉他，试着在前边加个 Java？果然，很快找到了。

这个例子很小，但是却反映了大家使用搜索引擎的最大的问题：**不会找关键字**。



#### 不够精简

有很多人很喜欢直接在搜索引擎里边搜 “如何…”、“怎么办…”、“怎么才能… 呢” 这样的关键字，尽管一般的搜索引擎都会过滤一些语气词，也能够搜到一些结果，但是精简检索式无疑是提高检索效率最好的方法。

至于方法可以比较简单，把你想提问的问题写下来，把其中的形容词、疑问词都筛掉，只留下大多数的名词就可以了，可以填充一些必要的修饰。比如你要搜索 “哪个自动化测试工具最好用”，可以直接筛选成为 “自动化测试 好用” 就可以了。



#### 缺少信息

和不够精简相对的，就是缺少信息。其实最前边的 “随机手机号” 就是很好的例子。在搜索过程中一定要标识自己的需求。如果我们要搜索某一个算法，一定要加上语言或者 “算法” 等字样标识，类似 “Java XXX”、“XXX 算法” 或者 “XXX 代码”，这样会准确很多。



#### 筛除杂质

很多同学找到日志中或者是控制台的报错，看不懂直接就扔到了搜索引擎里边去搜，发现找不到任何结果。这是为什么呢？搜索前一定要筛选掉你报错信息里的杂质，拿最纯正的错误去搜索。什么是杂质？我们特有的类名、变量名、参数值、报错信息中的中文都会是一些杂质，需要筛除掉。我们简单来看一个报错：

![图片描述](http://img.mukewang.com/5d6c8f9f00019c9611050084.png)

在这个报错里，需要筛选掉的信息包括各种 ip 等等，实际更好的搜索内容为：No connection could be made because the target machine actively refused it。这样才能获得最适合的结果。



#### 专业精准

当我们寻找某个领域的内容时候，越是用大而泛的词语，搜索出来的结果多而浅，而越是用专业而精准的关键词，得到的结果少而精。比如我们现在要测试的是一个大数据模型，可是现在不知道如何去测，当你搜索 “大数据测试” 的时候，你会得到很多宽泛的结果，而当你了解了你的模型，转而去搜 “Hadoop 测试”、“MapReduce 验证” 等关键字时候往往能够得到更精确的信息。

除了不会找关键字的问题以外，其实我们在搜索问题时可以尝试不同的搜索引擎。“兼听则明偏信则暗”，兼容 Google 和百度才是技术人的大成，因为 Google 更容易搜索到国外一些论坛的解决方案，而百度中国内的论坛 — 知乎、CSDN、简书等的权重更高。

![图片描述](http://img.mukewang.com/5d6c8fb60001a01504190210.png)

![图片描述](http://img.mukewang.com/5d6c8fc20001a07506290194.png)
当然，即便是搜索的结果，也不可尽信。老话讲 “择其善者而从之，其不善者而改之” 是十分有道理的，所以搜索到解决方案了，最重要的是分析是否适用和尝试是否可以解决。在网上找东西是一个愉快的过程，有一点像在 “淘宝”，不但需要火眼金睛，还需要与浩瀚的信息斗智斗勇。

我在这里简单列一下我自己觉得搜索结果相对可靠的一些网站，仅供参考：

1） 国外论坛

Stack Overflow、Reddit、CodeProject、Bytes

2） 国内网站

CSDN、简书、知乎

排名不分先后，如果大家在查询问题时候发现上述网站的结果，可以优先点开看看（访问不了的网站需要翻墙，这个就不细节讨论了，大家懂的）。其实我们工作中测试中 80% 的问题，都已经被别人遭遇过了，我们会搜索就可以解决其中的大半，剩下的 20% 才是研究，世上无难事，只要会搜索。



### 寻求帮助

如果经过我们的分析、查找、尝试仍然没有解决的话，那么就有必要向他人求助了。求助也就是提问，关于向他人提问的过程，我有很多话想跟大家聊，所以将在下边一个小节好好跟大家聊聊 “提问的艺术”。

## **06 提问的艺术**

### 写在前边的话

之所以把提问单独拎出来，是因为我自己大约每天在各种学员群、慕课答疑、私聊要答的问题不下百个，对大家的提问有很深的感触，也确实有很多想跟大家一起聊一聊的内容。

就像大家都能理解的，你的提问是否能够得到完美的解答，很大程度上取决于你提问的方式，当然，问题的难度也是一方面，但是怎么清楚地让其他人明白你表述的问题就不是一件容易的事情了。我们先把 “遇到问题该怎么提问” 放到一边，从被提问人角度想一想。



### 换个角度想一想

我算是一个既在论坛厮混也在群里潜水的互联网老鸟，我自己不止一次看到或者听到同学们的抱怨：在网上提问或者在群里问问题甚至是 @大神都没有人回答，甚至还会收到一些不太友好的回复。但事实真不是这样。我自己每天也处理很多的提问，不管提问是什么和态度如何，我都会一一给予回复，但即便这样，也有人投诉我说：老师的态度不好。

Fine，其实我在看到问题的时候一般会有四种状态：**郁闷**、**抓狂**、**愤怒**和**会心一笑**。80% 以上的问题都让我保持着前三种状态。不知道抱怨或者投诉的朋友有没有想过：为什么别人不愿意帮助我们呢？有没有换位思考一下？有看过这么一段话分享给大家一下：

> 你有一个儿媳
>
> 你嫌儿媳不懂事
>
> 你有一个女儿
>
> 你希望她掌管婆家大权
>
> 你开车时讨厌行人
>
> 你走路时讨厌车
>
> 你打工时觉得老板太强势太抠门
>
> 你当老板后觉得员工太没责任心没执行力
>
> 你是顾客认为商家太暴利
>
> 你是商人觉得顾客太挑剔

其实我们都没错

只是我们站的位置不同

—— 记得换位思考

你的人生才会更好

深以为然，我们换个角度，大家都是做 IT 的，不知道有没有碰到过这样的对话：

> 甲：你是学计算机的吧？
>
> 乙：是的
>
> 甲：哎呀，太好了，我家那个电脑啊不亮了，你给看看去呗
>
> 乙：那个… 我是学计算机编程的，不懂修电脑
>
> 甲：还大学生呢，就小气吧，算了，我不求你了还不行
>
> 乙：…

当你是乙的时候，你会有什么感想？然而你有没有想过你自己变成了甲？你以为理所当然应该被解答的问题可能由于你的提问有问题、态度不好或者对方很忙而未能收到回复；更有很多人在提问前不知道思考，只知道索取，不愿意做任何付出，导致回答者无以为继，也不愿意浪费自己的时间去帮助他人。

所以，在提问之前，要摆正自己的心态：别人回答帮助了我，我应该心怀庆幸和感激；别人没有帮助我们，我们也不要抱有怨言，因为别人没有义务和责任牺牲自己的时间帮助我们。

当然，当你学习一个课程时候，可以就课程的问题无条件地询问你的老师。但是，也请体谅一下他，因为他可能同时在处理 N 个问题，他也可能正在工作开会，我相信作为一名老师，他一定会在看到问题的第一时间想办法回复你的。

或许你本来有可能获得帮助，因为程序员们是世界上最单纯的群体，甚至也是这个世界上最乐于分享的一群人，但是一定要注意你自己的提问方式。



### “坏味道” 的提问方式

“坏味道” 这个词最早还是来源于代码中，所谓 “坏味道” 的代码是指不太符合规则，但是又不会影响我们的业务逻辑，简单来说就是颗定时炸弹的这类代码，我们推而广之，把这个 “流行” 的形容词放到 “提问方式” 的身上。所谓坏味道就是那些让回答者不舒服、不想回答的问题。我总结一下我在日常见到的比较让人不舒服的几种问题类型。

#### STFW 类问题

STFW（Search The Fucking Web），我相信大家都懂的。这种问题是我见过最多的，也是我觉得最浪费回答者时间的，问题类似于：“我要从哪里下载 XXX 安装包”、“Chrome XX 版本应该装哪个版本的 driver”、“报了一个 XXX 的错这是什么意思”、“Python 我想获取当前日期怎么做” 等等。这种问题往往让回答者感觉气愤，因为你至少浪费了他看问题的时间。

#### 超级宽泛的问题

这种问题虽然不会让人生气，但是会让人非常郁闷，不知道从何说起。我经常遇到的问题包括 “测试好学么”、“怎么做自动化测试 / 性能测试 / 安全测试”、“大数据测试是要干什么” 等等，这类问题的感觉是让我立刻像哆啦 A 梦一样拿出一片记忆面包，把你要学的内容直接印上去吃进肚子里，如果真的那么容易回答，我觉得我就不会准备上几个月来做一个新的视频课程，也不会有大家今天看到的专栏了。PS：如果有谁见过这样的面包，麻烦给我留上几片……

#### 不是问题的问题

人世间最让人痛苦和无语的问题就是缺少细节的问题，这几乎无法解答。我们一起来看一下这种的问题的代表性 “人物”： 老师，我写的代码运行报错了！！

So 发生了什么？你计划让我回答什么？我想我能做出的最有姿态的回答就是：那太遗憾了，祝你好运！

#### 懒汉型问题

二话不说，我们直接来看这样的场景：

> A：XXXX 这种场景应该怎么做？
>
> 我：BalaBala…
>
> A：好的，我明白了，能给我写一个例子么，按照我这个要求？
>
> 我：你不是明白了么？
>
> A：我明白了，可是你能帮我写出来么？
>
> 我：那你还是不明白呗？
>
> A：我真明白了，就是你帮我写出来吧。
>
> 我：……

像上面这种需要别人远程、别人去帮你写代码的问题几乎是分分钟让人暴走，所以遇到这种问题我一般只能以无言回复……

#### 堆砌现场

如果说前边的类型都是无法解答的，那最让人烦躁的就是一种大型 “车祸” 现场了。有的人问问题时候，把多个问题混在一起，截图多达六七个。收到如斯问题时候，需要回答者立刻化身为福尔摩斯，在一堆线索中剥茧抽丝，最终在所有可能性中，找出 “真相” 只有一个。说真的，我是最怕遇到这样的问题，一来不能说问题问的不全面，二来解决这样的问题不但需要耐心，还需要很长时间去分辨，而且更多时候，这种情况下是问题套问题的，不会只有一个问题，也增大了解决问题的难度。

#### 特殊问题

还有一种比较特殊的问题就是：老师，你做过安全，能告诉我怎么盗别人的 QQ 号么？或者你帮我盗个 QQ 号……

我只能说，对此我只能拉黑处理，这种问题不但暴露了提问的智商，也拉低了我自己的智商，所以再见不如不见。



### 提问的前置工作

书接上一回，我们聊到了面对问题的正确姿势，所以提问前你一定要问自己如下几个问题：

1. 是不是由于环境问题导致的？
2. 有没有对错误原因进行排查？
3. 尝试搜索了么？
4. 自己动手试着去根据搜索结果解决了么？

编程圈有这么两个词：RTFM、STFW，如果你碰到别人如此回复你，就真的要想一想你到底有没有自己尝试努力过。毕竟，在勤奋的程序员的圈子里，不劳而获基本上是最不足挂齿的品格。



### 什么是好的提问

一个好的提问，应该具备的特质是：**简洁、清晰、准确**。我比较喜欢的也乐于回答的问题是包含下面内容的：

1. 问题的状况和重现方式
2. 语言 / 版本 / 平台 / IDE 等环境信息
3. 代码、报错及调试信息的截图
4. 提问前曾经做过哪些研究和尝试

不需要在提问之前询问 “在吗” 或者 “我有个问题能帮我解决一下吗” 之类无用的信息，直接把包含上面重要信息的问题发出来。一旦能回答你问题的人看到，一定会更有思路更有条理的帮你解决。

坏味道的问题：

我在 Selenium 执行自动化脚本时候报错了，怎么办？

稍微好一点的调整：

我在用 Selenium 执行脚本的时候报错了，版本是 Selenium 3.0，语言应用为 Python3，错误信息为：Element is not currently visible。代码如下：

```python
from selenium import webdriver

driver = webdriver.Firefox()

url_vip = 'https://XXX.com/'

 

\#打开网址并跳转到发帖页面

driver.get(url_vip)

driver.find_element_by_link_text(u"会员首页").click()

driver.find_element_by_id('15').click()

driver.switch_to.frame('ContainerFrame')

driver.find_element_by_css_selector("a.qz_btn").click()

driver.switch_to.frame('ContainerFrame')

driver.switch_to.frame('ContainerFrame')

 

\#修改发布地址（遇到问题）

driver.find_element_by_link_text(u"点击发布到其他地区").click() #成功

driver.find_element_by_id('seleCompCirc').click()    #失败
```

请问应该如何解决？

更好一点的问法：

我在用 Selenium 执行脚本的时候报错了，版本是 Selenium 3.0，语言应用为 Python3，错误信息为：Element is not currently visible。代码如下（略），经过排查，“seleCompCirc” 这个 id 是没有重复的，这个按钮是需要等待上一步点击完成才可以的，所以我也尝试增加了延时，但是仍然报同样错误。尝试了一下只进行定位不进行点击，是没有报错的，所以判断错误原因在点击动作上。看到有一些搜索信息讲到可能与 JS 有关系，但是本人不太懂 JS，所以求助。（调试代码 + 截图）

我喜欢这样的提问因为条理更清晰，而且很多时候，我们在自己梳理问题的过程中，就会不自觉地发现这样那样的遗漏（参考小黄鸭调试法，自行搜索），所以提问其实不仅仅是向别人求助的过程，也是自己思考的过程。不思考而直接提问，不仅仅是对自己的不负责，更难以得到满意的答复。对于回答你问题的人最好的尊重就是不要提糟糕的问题。



### 提问的态度

其实我相信大家都可以理解，礼貌一些的提问总能给予别人更多的好感。对给予你帮助的人表示感谢，无论问题是否被解决。我曾经进入过一个特殊的测试技术群，群里面当有人提出问题并被其他人解决后，都会发一个金额不限的红包表示感谢，而回答者会欣然接受。当然，这并不是告诉大家要用红包的方式来交换答案，而是说，表达感谢是必要的，也算是让回答人舒服的一种方式。比如说我自己，我非常开心在慕课课程的答疑里看到同学诸如 “谢谢老师的解答” 之类的回复，我会有一种被认可和被需要感。

说了这么多，不是要大家不要提出问题，而是告诉大家，如何更好地提问和如何提问才能更有可能得到满意的答案。当然，聊的是测试，实际上不止于测试，生活亦然。

# **第3章 软件测试基础**

## **07 项目全流程中，tester们都在做什么？**

### 测试 VS 开发

前段时间在下课时间跟同学沟通了一下，收到了这样的反馈：风落老师，明明咱们测试要学这么多东西，感觉很牛逼啊，为什么在公司里测试还是不受重视？我觉得很多朋友都有同样的感受：测试不如开发，而且似乎也受到了很多人包括很多测试人的认可。到底是什么原因造成了这样的想法或者现状呢？我觉得是有两点原因：一是由于**国内测试行业的基础**，二是源于**我们自身**。

每次聊起测试都避免不了把国内外拿到一起比较，难免有 “崇洋媚外” 之嫌。事实上我们要正视认可，不说整体互联网，仅仅就**测试**这个行业上的认知，我们还是落后真正的世界级一个台阶的。

举个例子来说：我们对测试的认识是什么？圈子里比较认可的一种解释是 “测试是产品最后一道防线，使用人工操作或者软件自动运行的方式来检验它是否满足规定的需求或弄清预期的结果与实际结果之间的差别的过程”，总结来说软件测试就是为发现软件错误而执行程序的过程。

当然，这样的认识无可厚非，就像很多人都是从《软件测试》这本书中得到的类似定义一样。我也认识一些在 Google、Facebook 做测试的朋友，甚至还请他们为我当时出版的书籍做了短序，在他们看来，TE（Test Engineer | 测试工程师）的本质意义在于：保护用户和业务的利益，使用户不受糟糕的设计、令人困惑的用户体验、功能 BUG、安全和隐私等问题的困扰。

发现了不？这里边最大的差别就在于对于测试理解的角度不同，我们更多认为的测试是 “捉虫师”，所以我们负责的是项目、是开发，是服务提供者，而更高级一点，则会将测试看做 “用户” 的 **“保护者”**，是为客户而存在的。我觉得这是最根深蒂固的认知上的差异。

也因为此，在我们行业里，一直充斥着 “理科我学不好才去学文”、“开发我做不到只好做测试” 之类的符合了中庸之学的想法基础。所以，不仅仅是局外人，包括中小公司的领导、项目经理、开发甚至是求职者测试人员自己都认为 “测试不如开发”。

这是大环境的因素，但是同时，更关键的还是在我们自己。很多 tester 的级别止步在 “白银” 到 “黄金” 之间，并且没有找到自我提升的路，甚至很多 tester 并没有欲望去继续提升下去。同时，tester 介入项目中的环节过少，导致在项目中起到的作用不足。

我跟很多同学、朋友都聊过，发现至少三分之二的测试人员都在做着最传统的测试–设计用例、执行、回归等工作，这样其实只有在项目提测之后测试人员才开始启动，所以体现着测试人员在整个项目中的参与感很低，大多时候对需求的了解、对设计方案的了解全部来源于文档甚至是口口相传。同时，测试人员这些最传统的工作，也正在逐步或者将要被一些更简单、成本更低的形式所取代。

目前来说，国内的一线 IT 企业已经在悄然改变了，对于经验、技能的要求越来越多，对测试的招聘逐步从白银、黄金向铂金、钻石方向大跨步的前进。而敏捷开发、DevOps、TestOps 的普及和实践也意味着对测试有了更进一步的要求，而传统的测试方式也不再适应于当前的环境。所以，测试工作已经开始融入项目的每一个环节。



### 需求阶段



#### 头脑风暴

一般来说，任何产品的来源可能只是一句话、一个念头。比如，大家非常熟知的微信红包，初始就是来源于一个简单的想法：能不能把每年发红包利是的行为变成一款互联网产品？然而把一个念头变成实际可执行的需求，是一个非常复杂的过程，很多时候都需要 n 多次头脑风暴的碰头会议。而在很多大公司中，头脑风暴的过程也会邀请一些研发、测试加入，需要大家评估某些想法的可行性以及是否会对现有的业务、逻辑产生大的分歧。所以往往在需求诞生之初，就需要我们测试人员的参与，这时候，我们是需求产生的 “把关人”。



#### 需求分析

记得当我第一次跟我的团队小伙伴谈**测试需求分析**的时候，大家的第一反应是：what？测试还要做需求分析？答案是肯定的。古人云：墙高基下，虽得必失。再高的墙如果没有好的基础，那早晚会倒塌的，测试工作也是一样，如果没有更早的清晰、明确需求，没有坚实的基础，其后患无穷。所以我们的工作则是要根据总结出的每个需求点，归纳出我们需要的测试要点，分析需求的合理性，从而大致确定我们的测试范围和测试工作的优先级，同时，找出需求中不明确的场景，查缺补漏。

还拿微信红包举例，很多时候业务方、产品方非常容易忽略红包未完全发放退款到底是要退回发红包的银行卡呢还是回到零钱余额，这就需要我们帮助需求人员整理、完善，也同时可以避免开发阶段的遗漏。你看，测试的需求分析其实很重要，而我们发现的问题和疑问呢，也尽可以在后面的**需求评审会议**上–我们也称之为**撕逼大会**–尽情发泄讨论开来。



### 设计阶段



#### 测试模块划分

很多同学在需求阶段完成后，到了设计阶段，就开始拿上需求、设计文档甚至是 UI 设计开始了自己的测试用例设计之旅，实际上这样不是最好的方法。就像大家看过的很多武侠小说一样，几乎所有的武功秘籍都是有一个**总纲**的，所以我们在正式大展拳脚之前，也要为自己的设计提供一个**总纲**，这个总纲就是测试模块划分。直观一点，我给大家看一下微信红包项目的部分模块划分：

![图片描述](http://img.mukewang.com/5d75b56c0001a26305190435.png)
截取了全图的很小一部分。我比较习惯于使用思维导图的模式来进行模块划分，会觉得更清晰完整，当然，大家也可以有其它的方式，比如线框图等等。这样的总纲目的只在于让你做到心中有数，一个产品、项目的测试阶段究竟有哪些测试点，而哪些更重要，哪些可以次要，哪些可以忽略，通过一个思维导图一览无余。



#### 测试计划 & 用例设计

这部分是大家的老本行了，相信不肖我说，大家也都知道需要做这两件事。测试计划是描述测试项目和测试任务之间的关系。它用来说明要测什么，如何测，如何协调测试资源和测试时间等。测试计划制定的是否合理高效会对测试项目的进度产生很大的影响。测试设计则是将概括的测试目标转化为具体的测试条件和测试用例的一系列活动。尽管我很轻描淡写，但实际上测试计划的设计和用例的设计编写是最考验我们对整体需求的理解和分析能力了。当然，这其中还要包括：是否需要进行性能测试？安全测试？哪些部分需要进行自动化？



#### 用例评审

![图片描述](http://img.mukewang.com/5d75b57c0001491107930646.png)
我总是喜欢在大家容易忽略的地方多说几句，所以在用例评审上也想再聊一下。上面这个是用例评审的全过程，当然，也许很多人会觉得用例评审是个很流程化，不大有意义的过程，而实际上呢？用例评审最关键的是 “**换个角度想问题**” 这七个字上。

我自己曾经遇到过这样一件事情，明明是一个很明显的测试点，但是由于我们团队几个人持续保持着共同讨论、共同设计、共同执行的状态，全部都忽略掉了这个方向。我相信在当时，如果做过用例评审的话，其他对这个业务熟悉的同学基本可以想到我们的遗漏点在哪里。这也就是我建议大家引用测试评审的意义，讲用例、做评审不是重要目的，“旁观者清” 才是用例评审的意义所在。



### 执行阶段



#### 冒烟测试

敲黑板！对于冒烟测试，历来存在着很多的误解。比如很多人觉得，进入了冒烟测试就证明进入了测试阶段。其实呢，冒烟测试应该只是做为一个提测的检查点而不算做一个阶段。“冒烟” 这个术语源自硬件行业，对一个硬件或硬件组件进行更改或修复后，直接给设备加电。如果没有冒烟，则该组件就通过了测试。冒烟测试应该是一个固化的校验工作，结果是过不不过两种，通过则我们进入测试阶段，不过，那么直接返工，等待下一次的提测。如此看来，冒烟测试是对我们测试工作的一个保障，千万不要觉得他没有用，很多余，当然，因为冒烟测试的属性是校验，所以最佳实践一定是通过自动化搞定。



#### 测试执行

这里边会包含用例的执行、测试缺陷的提出、回归测试验证等。这算是咱们测试人的基本功了。如果需要进行性能测试、安全测试，也要在这个阶段进行。



#### 测试总结

测试总结不仅仅是要 **“通过”** 和 **“不通过”** 的结论，总结是我们测试阶段的一个重要过程，与冒烟测试相反，它不是一个校验点。在这里，你需要总结项目的整体测试情况、测试周期、缺陷分析、测试结果、风险和遗留问题等等。我们可以一起看一下下边的模板：

![图片描述](http://img.mukewang.com/5d75b58b000155a602530320.png)



### 项目上线

俗话说：行百里者半九十。只要项目没有上线成功，那项目的意义就约等于无。很多人觉得项目上线就是运维的工作范畴，需要测试人员做什么？让我们一块看看下边的图：

![图片描述](http://img.mukewang.com/5d75b5980001276416561024.png)
实际上，到了项目上线阶段，测试人员的角色仍然非常重要。上线前要核实准备事项，发布顺序；上线中要做好线上的验证测试；上线后要跟踪线上问题，如果发生问题需要修改发布，一定要保证完善的回归测试，以及后续将出问题的点总结补充在测试用例之中，做好相应的总结工作。



### 其他



#### 自动化测试

之所以把自动化测试单独罗列出来，是因为在敏捷的短迭代下，可能很难在一个迭代周期中间进行自动化脚本的开发。所以，更多的自动化工作我们会放到 sprint 与 sprint 的间隔期，在下一个 sprint 工作正式开始之前或者是在下一个 sprint 的需求阶段（测试人员不太繁忙的时间段）来补充上一个迭代中我们需要自动化的部分。



#### 监控

系统尤其是大型系统上线后，可能很多线上问题难以在第一时间暴露，为了保证系统的稳定性以及异常的及时反馈，所以很多时候我们希望能够增加一些监控。当然，监控的工作更多是由运维或者开发人员来完成的，不过在测试与开发越来越模糊的今天，测试也开始逐渐上手去进行监控工作。我们的系统中就是这样，使用 python 对文件、数据库的部分状态和行为进行预警和监控，这样便于我们更好的进行线上问题监控，让我们能够在问题发生的第一时间得知，降低问题发生的概率。



#### 自我总结

这不是个必要的工作，但是我觉得很有意义，所以在一些特定的项目中我会把自己工作的得失、排查问题的步骤、业务的总结全部记录下来，分析哪些工作是不必要的，又走了哪些弯路，善于总结，那么走这些弯路吸取的经验和教训，都能够成为自己的宝贵经验，让以后的路能走得更顺利。测试的工作，尤其在大家经验还不够丰富的时候，本身就是一个学习的过程，总结确实是对于学习中遇到问题、分析问题、解决问题的自我梳理和提升的过程。



### 结语

看到这儿，请大家自问一下：**上面的这些内容你在项目中做到多少？有多少可以增加可以改进的？** 记得奇葩说上有一句很有意思的话：我每天晚上都会问自己一句话：你比昨天更博学了吗？我们不谈博学，只让自己多做一点，更优秀一点。也许测试的受重视程度仍然不如开发，但是优秀的你，早已超过当初跟你站在同一起跑线的开发；又或许当我们都优秀了一点点，测试行业也会变得更加美好优秀一点。

## **08 厉兵秣马：如何设计优秀的测试用例**

作为软件测试里最基本最通用的技能，测试用例的设计相信大家都有概念，但是你真的能设计出优秀的测试用例么？我想应该打一个问号。我们把这个主题 “庖丁解牛” 一下，“设计优秀的测试用例” 包含一个名词，一个动词还有一个形容词。最基本的首先是 “测试用例” 这个名词，我们从这里聊起。



### 测试用例

什么是测试用例？比较通用的解释：测试用例是通过使用在测试计划中确定的测试技术，对于已确定的测试条件进行逐步推敲，精炼而设计出来的重点说明如何具体操作产生何种结果的文档。翻译成通俗易懂的话就是你要把想要测试的动作变成在什么情况下，做什么动作，用什么数据方式去做，最后想得到什么样的结果归集成一条测试用例。所以，每个测试用例应该有它的前置条件，应该有它的事件和对应的参数，最后有期望结果。这样就是一条合格的测试用例了。

举个例子，我们就拿最常用最通俗易懂的登录功能来说。基本上每个网站、每个 APP 都需要登录，那怎么成功登录呢？找一个已经存在的用户，在界面上输入正确的用户名和密码，点击一下登录按钮，看看有没有登录成功。OK，这是一个最最简单的操作，也构成了我们的第一个最正常的测试用例。仔细看看，其实也包含了前边说的几个要素：

- 前置条件：一个已经存在的用户
- 动作和参数：输入正确的用户名、密码，点击登录
- 期望结果：登录成功

这当然是一个完整的测试用例，但是对于一个登录模块来说，这就够了么？当然不，这只是这个模块里合格的测试用例之一。那该怎么写出更多的测试用例呢？这时候就要去看我们的动词了：设计。设计其实对应的是一套方法，只有有正确的方法，才能设计出合格的测试用例。



### 用例设计方法

工欲善其事必先利其器，做好一件事情的前提先找到有利的武器，磨刀不误砍柴工说的是同样的道理。在测试用例的设计上，比较常用的有下边几种武器：

- 等价类划分法
- 边界值法
- 因果图设计法
- 判定表设计法
- 正交实验法
- 错误推测法
- 场景法

具体每种方法到底是什么原理，原则是什么，怎样去设计，我相信聪明的你已经知道应该去 **STFW** 了。因为到处都讲的很多很清晰，但是几乎都是分开来说的，很多同学在学习了这些方法之后有一个疑问：测试的方法也太多了，我到底该怎么抉择呢？这里有一首非常好听的歌说明了这个问题：

> 输入分类选等价，给定范围加边界，条件组合出因果，条件孤立想判定，无限穷举取正交，业务复杂场景法，错误推测靠经验，测试充分全覆盖。

有没有跟着一起愉快的唱起来？好吧…… 其实我也没有，实在是找不到适合唱出来的曲调，但是实际上我们在真实设计用例的时候真的用得上这么多方法么？答案是否定的，在我相对还算漫长的测试生涯里，我觉得用的最多的就是**边界值**、**等价类**、**场景法**和**错误推测**这样几个方法。所以归纳总结一下，真正工作中我们设计的思路大概是：

- 用等价类划分方法划分大部分场景设计测试用例
- 任何情况下都必须使用边界值分析方法，经验表明用这种方法设计出测试用例发现程序错误的能力最强
- 程序业务复杂度比较高，则适当使用场景法补充一部分测试用例
- 如果你对该业务非常熟悉，可以根据经验在容易出错的地方补充一些测试用例

基于这样的设计方法，同样还是当初的那个登录界面，我们大体可以设计出下边的测试用例：

1. 已存在的用户，输入正确的用户名和密码，点击登录，验证是否登录成功；
2. 不输入任何内容，直接点击登录，验证是否登录失败，提示信息正确；
3. 已存在的用户，输入正确的用户名和错误的密码，点击登录，验证是否登录失败，提示信息正确；
4. 已存在的用户 A 与 B，输入 A 的用户名和 B 的密码，点击登录，验证是否登录失败，提示信息正确；输入不存在的用户名和任意密码，点击登录，验证是否登录失败，提示信息正确；
5. 已存在但状态异常的用户（如停用、冻结、锁定），输入正确的用户名和密码，点击登录，验证是否登录失败，提示信息正确；
6. 已存在的用户，用户名为小写，输入大写的用户名及正确的密码，点击登录，验证是否登录失败；
7. 已存在的用户，密码为小写，输入正确的用户名及大写的密码，点击登录，验证是否登录失败；
8. 密码是否自动加密显示或包含隐藏 / 显示功能，验证是否可以正常使用；
9. 用户权限是否区分，管理员及普通用户登录成功跳转是否正确；
10. 用户名及密码输入框是否具有长度限制，与注册时长度要求是否一致；
11. 登录失败到达一定次数，是否会自动显示验证码；
12. 有验证码情况下，输入正确的用户名密码及正确的验证码，验证是否登录成功；
13. 有验证码情况下，输入正确的用户名密码及错误的验证码，验证是否登录失败；
14. 有验证码情况下，点击验证码图片（或换一张按钮）是否更换验证码，更换后的验证码是否可用；
15. 有验证码情况下，点击验证码图片（或换一张按钮）更换验证码，使用更换前验证码登录，验证是否登录失败；
16. 刷新页面验证码是否跟随刷新；
17. 验证码超过可用时效，输入当前验证码，验证是否登录失败；
18. 登陆失败后，用户名是否保存，密码为空；
19. 是否有记住用户名功能和记住密码功能，是否可用；
20. 快捷键是否可用，密码是否不可以通过粘贴粘入；
21. TAB、ENTER 是否可以自动跳转控件及自动提交；
22. 是否支持第三方登录（微信、支付宝、QQ、微博等），登录验证是否正确；
23. 是否支持手机验证码登录，手机是否可以收到短信，是否可以登录成功；
24. 手机验证码超时，使用已超时验证码登录，是否可以登录成功；
25. 用户 session 失效后是否重新跳转登录页；
26. 用户登出后，通过后退按钮，是否可以继续操作；
27. 是否具有忘记密码功能，是否可用。

OK，简单列出了一些，但是如果这时候要我给这套用例打个分的话，那我可以打个 80 分。一定有小伙伴要实名 diss 我了，已经这么全面了，还要什么？为什么只有 80 分？这就涉及我们今天讨论主题的第三个维度了，形容词 “优秀的”。



### 谈优秀的测试用例

大家都清楚的一个道理，当你的分数是不及格的时候，要把自己提升到及格很容易，可以当你自己已经比较优秀了，想从 80 分提升到 90 分，那就很难了，这需要更深入的知识掌握。用例设计也是如此。同时，既然要谈 “优秀” 这个形容词，就要聊聊很多人的错误认知。很多人觉得对测试用例的评价在于表达清晰、条件 & 过程 & 预期覆盖完整、设计方法使用得当，这当然没有问题，但是当你用 “优秀” 的标准来评判的时候，就不要再看某一条用例了，而是要从整体上去考量。这就好像这两年火起来的一档节目《这就是街舞》，当你单人 battle 的时候，考量你的是你的技术难度够不够高，够不够契合音乐，是不是炸，但是当齐舞比拼的时候，那考核的就是整体编舞、整齐度、故事性等等，对于一组测试用例来说，只有完备的、可重复的、可验证的、需求覆盖全面的测试用例才是最优秀的测试用例。

所以，作为老测试猿们，一定这时候明白了我要说什么。所谓的需求覆盖全面，所谓的完备一定不仅仅包含我们刚才的纯黑盒功能测试的内容，测试人员需要考虑的更多。一般情况下，我们还需要考虑数据日志测试、界面 UI 测试、兼容性测试、性能测试和安全测试等方面。我们分开来看：



#### 数据日志测试

所谓的数据日志测试主要包含我们在前端，在页面或者 APP 上看不到的测试项，我举几个例子：

- 数据库密码字段验证是否加密
- 登录失败次数是否记录在数据库、缓存中，逻辑是否正确
- 登录失败冻结等场景数据库是否正确修改状态
- 错误日志是否完备，是否便于排查问题
- 对象是否容易定位，便于自动化
- 是否有增加埋点，进行用户行为分析



#### 界面 UI 测试

日常测试来说，界面和用户体验的测试也是非常必要的，像我们前边关于 TAB 和 ENTER 的使用其实就是用户体验的一种，所以如果要更全面地进行测试覆盖，就一定也要考虑到界面的测试。

- 布局是否合理，是否对齐
- 界面设计是否与需求、UI 设计文档一致
- 是否有错别字、标点错误缺失
- 页面颜色搭配是否得当
- 错误文字是否明确易懂
- 界面视觉效果是否恰当，界面动画展示是否流畅



#### 兼容性测试

- 不同操作系统下，是否可以兼容（Windows、MAC OS、LINUX）
- 同一操作系统不同版本下，是否可以正常显示及功能正确性
- 不同浏览器下（Chrome、IE、FireFox 等）下是否可以兼容
- 同一浏览器不同版本下是否可以兼容
- 移动端是否兼容
- 放大缩小界面时是否兼容展示
- 不同语言下，界面展示是否正确
- 是否具有高对比读模式（为视力不好的人准备）



#### 性能测试

性能测试又可以分为服务端性能和前端性能，也需要综合考虑，同时，针对性能的指标和场景也伴随着不同模块、不同企业、不同需求而有所不同，我在这里简单举几个比较通用的例子：

- 用户登录接口的最大并发数（响应时间 3s 内）
- 特定负载测试下服务器的性能指标
- 压力测试过程中服务的稳定性和性能指标
- 服务的分布式处理逻辑，负载均衡逻辑、缓存及队列的使用
- 能够支持的接口最大并发量
- GC 处理，是否有内存溢出等情况
- 高并发下数据库是否有慢 SQL 和死锁
- 页面加载速度
- 页面资源大小，是否应用雪碧图
- YSLOW 分析，静态性能



#### 安全测试

最后，也是我们最容易忽略的安全测试。很多时候我们容易忽略安全带来的威胁，但是实际上一旦发生安全问题，产生的损失会远远大于某一个 Bug 带来的影响。我们先就登录界面简单介绍一下应该采取的安全检测措施，后边有机会我们再细致聊一下安全测试的方方面面。

- 验证关键数据通过 HTTP 还是 HTTPS 传输
- 是否包含弱密码
- 是否容易被暴力破解
- 是否使用多因子认证
- 登录是否采用互斥性验证
- 产生的会话令牌（sessionID）强度
- 传输中是否存在会话令牌泄露情况
- 是否包含越权漏洞
- 使用万能密码是否可以登录成功
- 是否可以进行 SQL 盲注
- 密码存储加密安全性
- 是否具有 XSS（跨站脚本）攻击防御
- 是否包含 CSRF 攻击漏洞
- Token 或密码传输中防中间人攻击

到这里，我可以给上边的测试用例打上一个 95 分了，有 4 分是兼容可能存在的遗漏，最后 1 分是怕自己骄傲。可以看到，一个大家眼中很简单的登录功能，我们列出了如此多的测试用例，同时大家也可以看到，只有当你的 “自我修养” 足够强大，级别足够高，才能设计出更全面、更完整的优秀的测试用例，否则停留在黄金、白银阶段的你很难去设计出诸如性能、安全等测试用例。回到我们自己身上，只有足够优秀的你，才能有机会设计出足够优秀的测试用例。

当然，我刚刚也说了，可能还会存在这些那些的遗漏，甚至有的同学会说：老板说测试时间紧，要很快上线，根本不可能执行这么多测试用例啊。这里我想说，没有人能够覆盖完整所有的场景，所以才会有如斯的用例设计方法；我们也没办法保证经过我们测试的项目、模块一定不出现任何问题，我们需要在**产品质量**与**人力成本**之间权衡，我们也需要在测试执行以前进行权衡，所以现在的测试用例增加了一个 **“优先级”** 的字段，便于我们更好的进行测试规划。

更可能有同学说：风落啊，你写这个很多我都不知道该怎么去测试啊，怎么办？不要着急，现阶段我们仅仅是抛砖引玉，继续看下去，希望在几个月之后，在这个专栏结束的时候，你可以找到更好的自己，也不要忘了前边介绍过的，“STFW”。最后，欢迎大家留言给风落，聊聊你在用例设计过程中有哪些 “惊心动魄” 的故事。

## **09 论高质量的BUG**

### 从一个 “不完美” 的 bug 聊起

这次的主题源于我曾经的一次**发火**，在项目总结会议上，我们在做 BUG Review 的时候，发现了类似这样一个 BUG： XXX 充值接口调用报错，XXX 购买接口调用报错。完了，就这么简单，我仔细观察了一下 BUG 的详情，神马都木有。并且这样的一个 BUG 还是由一个有着几年工作经验的同学提出的，顿时很想说一句：你的 BUG 提的这么棒棒的，你家里人知道吗？

“捉虫”、找 BUG 是测试人员必须具备的能力，不管在任何公司，测试人员在执行测试任务的过程中，发现 BUG、提出 BUG 以及跟踪 BUG 都是十分必要且重要的工作。可以说，BUG 是我们与开发人员沟通的必备桥梁，但是呢，总是会有这样一种现象发生：我们提出的 BUG 质量不高，让开发人员无法一下子弄明白。这样就需要更多的线下沟通，经常会出现这样的对话:

- *DEV：* 小风小风，你来描述下这个 BUG？
- *TESTER：*BLABLA…（此处省略 200 字）
- *DEV：* 你那存了日志么？还是在哪台服务器上我能看一下？
- *TESTER：* 等会啊，我回去发给你。
- *DEV：* 算了算了，你在我本地操作下我看看吧。

如此一来折腾也增加了沟通成本，浪费了时间，光是讲明白一个问题大概 5 到 10 min 就过去了，更重要的是，在非常忙碌的情况下，大家也会感到很烦躁，影响心情。所以提 BUG 不仅仅是我们测试人员的技能，更应该考虑我们 BUG 的面向对象：开发人员。开发人员需要什么信息，我们就自然应该在提出时候包含。



### 编写高质量的 BUG

我们先换位思考一下，假如我们是开发，会让我们觉得无法理解弄清楚的几种情况：

1. BUG 过于简单，只有一句话，描述不清

   开发人员最怕的就是这种类型的 BUG，举个例子：

![图片描述](http://img.mukewang.com/5d770b5a0001d80606870123.png)
这时候心里的 OS 就有了 “灵魂三问”：有什么问题？怎么操作出来的问题？给个问题的截图好不好？

1. 发现 BUG 的场景过程没有完全保留，重现困难
2. 多个问题合并成一个，开发不容易定位，也有可能漏过问题

我们知道了自身的症状，那么就从这里开始，一起聊一聊一个优秀的 BUG，应该包含哪些方面的内容呢？

- #### 标题

  其实每一个 BUG 也都是一个小的文档，既然是文档，我们首先就要做好一个 “标题党”，当然，此 “标题党” 非彼标题党。作为一只优秀的标题，要清晰明确简洁的说明两个 “W”：

  1. **Which**： 哪个系统的哪个功能？
  2. **What happened**：出现了什么样的问题？

  也记住另外一个规范：每条缺陷报告只包括一个缺陷。就像刚刚说的，这样可以让开发认真的定位和对待单一的 BUG，对于测试人员自己来说，也只需要每次校验一个 BUG 是否修正。像最开始我提到的让我发火的 BUG 就实不足取。

- #### 环境配置

  如果涉及环境因素的话，比如，有些兼容性问题只在某个浏览器、某个手机系统甚至是某个型号的机器上等等，就需要指明问题复现所在的环境配置信息。

- #### 前置条件

  有时候，有些问题是需要在某些特殊条件、特殊操作或者特殊数据下才会引发的，这时候最好添加上这部分的描述，便于问题的复现。

- #### 重现步骤

  从用户角度出发来描述重现步骤，步与步之间不应该有太大的业务跳跃。每一个步骤尽量只记录一个操作，保证快速准确的重复缺陷，确认步骤完整，准确，简短：“完整” 就是说没有缺漏，“准确” 是步骤正确，“简短” 则是要没有多余的步骤，直指问题的核心。

- #### 结果

  这里的结果其实包含两方面，一是 “期望结果”，二是 “实际结果”，之所以会产生 BUG，一定是实际结果不符合期望而导致的，所以对于结果一定要描述清楚，否则的话就会变成：

  *W：你错了没？*

  *M：我哪儿错了？*

  *W：你自己哪儿错了你都不知道？！*

  相信各位童鞋都深有体会（OS：榴莲键盘主板便宜出售，量大从优）。

- #### 优先级

  凡事都有轻重缓急，所以对于 BUG 来说也是一样，表示自己对于该 BUG 的紧急程度的评估。一般情况下，我们分为下边几级：

  1. **Critical**：非常紧急，需要开发人员立即解决的 BUG，大多数情况下是**阻断性的 BUG**，不解决的话无法继续测试
  2. **High**：高优先级 BUG，希望尽快解决，一般属于比较大的核心业务功能缺陷，但暂时不影响后续测试。
  3. **Medium**：一般优先级，大多数情况下是非核心业务缺陷，建议在发布前要解决的 BUG。
  4. **Low**：低优先级 BUG，如果能够在发布前解决更好，实在工时紧张可以酌情向后推迟修改，大多数属于优化、用户体验等建议。

- #### 附件

  附件是非常非常重要的！为了更加方便开发人员定位修改问题，也是方便测试人员自己去回归测试 BUG，适当的附件内容是很有益处的，附件的内容可以多种多样，比较常见的包括：

  1. **截图**：发生问题时的截图对于重现问题有着很重要的意义，也是问题真实存在的证据。
  2. **视频**：有很多时候，单单依靠截图也很难重现 BUG，这时候如果在缺陷发生或者测试重现的时候能够录制一个短视频，那么对于开发人员来说，简直就是一场 “及时雨”。
  3. **错误日志**：如果你能够找到 BUG 发生时候的具体日志，那对于你自身的提升和开发人员定位问题的好处都是显而易见的。开发人员可以通过此找出报错的打码，测试人员也可以学到更多关于服务器、中间件包括项目业务和部署深入的内容。

- #### 发生原因分析

  这里就需要大家有一定的代码基础了。如果我们可以自己通过日志等内容定位发生问题的代码和大体原因，我们对于当前系统的理解和测试就可以算是更上了一层楼。当然，这不是必须的，需要大家量力而为。

如果你能够完美的做到上边几点，那么这就诞生了一个个出自于你的高质量的 BUG 了，不仅仅有助于提高项目组中定位和修复问题的效率，同样也锻炼体现了你自己的能力，也更容易得到开发和领导的认可。那么问题来了，刚刚提到了那么多方面，如果每个都这么做，这要耗费多少精力啊？所以，回到我们最初的想法，提出缺陷的意义是更好、更有效的服务于开发和测试团队之间的沟通和未来的回顾，大可不必拘泥于某种特定的格式，适合你的适合当前缺陷的才是最好的，并不是每一个项目都需要覆盖完美，只是一旦需要，我们希望能够看到它们。



### 难以重现的 BUG

在漫长的测试生涯中，我们总会碰上一些难以理解的 “诡异” 事情。偶尔我们发现了一个问题，又按照之前的步骤重新操作了一遍，咦，发现很诡异的事情发生了：刚刚的问题无法重现了！再次尝试多次，仍无法重现。于是，我们心安理得的骗自己：可能是刚才网络异常了吧。可是不知道什么时候，又偶遇了同样的问题，可是又难以重现，这时候该怎么办呢？

首先，尽量在第一时间截图留痕，如果在问题第一次偶发时候没有在意，那么一旦重现失败后续又再次出现的时候，一定要截图存档。

其次，尝试多次（我们暂定 20 次左右）仍然不能重现，不要继续浪费时间，尽快的去看当时发生问题时的日志，通过日志来追溯当时可能发生的情况，例如多人同步操作，数据库死锁，服务器断线等情况。

接下来，通过当时的数据、环境、配置、特殊操作等再尽量多尝试几次，同时，可以与组内其他测试人员交叉测试，不管是否可以发现，都要把问题提出，并且通知开发，标识该问题为难以重现的 BUG，请开发人员与自己一同通过白盒或代码走查的方式尝试定位。

最后，如果仍难以发现并修改，那么就需要及时评估该问题的影响范围，影响较小的留存后续跟踪，影响较大的则上报项目经理协调解决。



### 提出 BUG 的四重境界

就如同我们打游戏一样，同样一个英雄，在不同的玩家手里可以用出不一样的效果，测试亦然。同样是发现 BUG，不同的 tester 同样会有不同的境界。



#### 第一重：筑基。

顾名思义，这一重境界还是铸造基础阶段，我们能够找出问题，但是可能描述不太清楚。如：

在进行添加购物车、结算操作时，报错。上述的 BUG 描述仅仅能够做到发现问题，至于是什么操作，什么报错，并不能够指引开发人员去具体复现和定位。所以如果要打分的话，这样的 BUG 我可以给打 30 分。



#### 第二重：灵寂。

在武侠中，这是能力大提升后的平稳阶段，也是步入更高殿堂的前阶段。在这重境界中，我们开始不但能够找到问题，也能够描述清楚问题。

添加商品进入购物车，点击结算未发生跳转，错误信息页面提示：“error:null”。截图及日志见附件。

这样的描述加上附件已经基本能够达到让开发人员看懂并着手解决了，在没有代码能力的前提下，可以算是将功能测试做到了不错的境界。所以，这样的描述可以打到 60 分。



#### 第三重：元婴。

这是真正步入修真殿堂的一步，对于测试来说，也是更进一步的体现。在这重境界中，我们开始去阅读、去审查代码，去尝试找出代码存在的问题。

添加商品进入购物车，点击结算未发生跳转，错误信息页面提示：“error:null”。截图及日志见附件。根据日志排查，在 XX 类中 XX 行位置，报空指针异常，可能由于前边对 XX 参数未赋值。

这样我们做到的不仅仅是发现问题，描述问题，同时定位错误发生的原因。这样我们可以达到 80 分。



#### 第四重：大乘。

巩固修为的果实，慢慢累积力量，直到圆满，也就意味着我们测试能力的大成，对我们的要求也就更高了，基本可以做到：**教开发人员写代码**。这也是我觉得测试的最高境界了。

添加商品进入购物车，点击结算未发生跳转，错误信息页面提示：“error:null”。截图及日志见附件。根据日志排查，在 XX 类中 XX 行位置，报空指针异常，分析由于前边对 a 参数未赋值。建议修改：从前边调用用户信息查询接口的返回对象中，将其中的 b 参数赋值到 a 参数中，再调用结算接口。

在这重境界里，对我们的要求是：找到问题、描述清楚、定位问题且提供解决思路。能做到这样的话，我们可以打个 99 分了。教开发写代码，是我们做功能测试的巅峰，也是大家不断提升自己能力的体现。



### BUG 的后续跟踪

BUG 提交完不是结束，只是一个流程的开始。你仍然需要实时跟踪 BUG 的进展，甚至对于一些优先等级高的 BUG，还需要去关注修改的进度。通常请款下一个 BUG 的生命周期是：

![图片描述](https://raw.githubusercontent.com/woshiamiaojiang/image-hosting/master/5d770b750001640005910638.png)

所以，按照上边来说，我们的状态变化就会是：**New -> Open -> Fixed -> Close** 。

当然，除此之外，任何一个大型项目结束后，还需要对 BUG 进行分析和汇总，分析问题出现的原因及未来避免方案。总结开来，BUG 是我们测试生涯中不可缺少的一部分，同时也不是非常简单的工作，我们需要不断磨砺自己的技术能力，提出高质量的 BUG，也让我们未来的测试道路越走越好，越走越宽。

## **10 从青铜到黄金：功能测试进阶路上还需要哪些非测试技能**

在开始今天的内容之前，我想请问大家一个问题：已经走上测试道路的你，觉得想成为一名优秀的测试工程师都需要哪些技能呢？

这个问题我问过很多 tester，包含我的学生、同事、测试网友，大多数得到的回答类似于我们测试生涯的方向：功能测试基础、接口测试、自动化测试、性能测试、安全测试。当然，这都是我们必须要掌握的测试技能，对于我们未来的发展有着战略性的价值。但是这就够了么？

今天要跟大家聊一聊关于非测试技能的事情，也许这些技能并不足以让你写在简历里光彩照人，也不能让你在面试官面前侃侃而谈，但是，他们却实实在在能够在实际工作中让我们提升很多，也让你能够更快速的掌握甚至精通相关的测试技能。



### 沟通能力

之所以把沟通能力排在第一位，也是因为测试工作的特殊属性。见过不少技术不错、能力不凡但是沟通能力很弱的测试，往往在发现了问题而开发不接受的时候，可能会与开发针锋相对，无法产生有效的沟通，不仅仅工作效率低，还容易产生失落感，严重的甚至会怀疑自我或者质疑一切。

我认识这样一个朋友，性格耿直，自信爆棚，面对开发、项目经理、测试领导的劝解和询问，只有一个字：怼。怼天怼地怼空气，把自己也弄成了 “怨妇”，动不动就慨叹自己换了多份工作却没有一次碰到好的团队，更加听不进去我们的劝说，明明技术能力很强，却一直没有很好的地方发挥，最后自己也无心工作，转行放弃。

诚然，这里边有个人性格的因素，但是更多的是沟通的方式方法。作为测试人员，我们很多时候要面对与各种各样的人去沟通，有的善于言谈、有的眼高于顶、有的沉默寡言，出色的沟通方式和良好的表达能力能够让测试人员在很多时候事半功倍。

在测试圈里有个笑话：如果你发现了一个问题，那么你跟开发说：你的代码有 BUG 了！开发的第一反应就是：你的环境有问题！你是不是傻，不会用！但是如果你跟开发说：** 你这个程序和预期的有点不一样，你看是不是我的使用方法有问题？** 开发的反应一般都是：擦，是不是出 BUG 了！虽然是个笑话，但是也的确说明了沟通的重要性。

如果做不到拥有优秀的沟通表达能力，那么请至少做到 “**好好说话**”。这里的好好说话是说如果你不知道如何能够更好的开展沟通，那么请保持谦逊、温和的态度，这会让对方感觉更舒服一些。



### Linux 基础

我们前边有提到想要提出更有质量的 BUG，还需要针对日志进行深入的分析。实际上，不仅仅是日志，由于现在 Linux 服务器的普及，很多测试的工作都要在 Linux 上开展。从简单的日志查询，到一些大文件的处理，甚至到未来我们使用的 docker 服务安装等等，都需要我们对 Linux 有一定的认知。当然，我觉得我们不需要把 Linux 学到服务器管理员的水平，所以简单列一下我们日常工作中可能会应用到的需要学习的知识：

- 远程连接工具 xshell，ssh 的使用
- Linux 常用命令
- 文件、文件夹的查看、删除、修改
- Vi、Vim 的使用
- Linux 中环境部署（Tomcat、Mysql）
- 用户与权限管理
- Linux 定时任务 Crontab 处理

这是我们比较常用的基础知识，不需要太深入，熟练会使用即可满足 90% 的工作场景需求。另外，有两个方面是我们在 Linux 使用上可以提升进阶的地方：

- Linux Shell 编程
- Linux Docker 基础

Shell 编程有助于我们增加对系统脚本、文件处理等编程打下基础，学习 Docker 则是我们与时俱进，赶上行业流行技术。



### 数据库

对于测试人员来说，纯黑盒只看页面展示的测试已经是上个世纪的流行趋势了，现在我们需要了解的更多，其中就包括对于数据库的校验。每一次测试执行，每一条 case 的结果我们很多时候不仅要看页面的展示，更要观察数据库的数据处理是否得当，毕竟，数据库才是我们一个系统用户真正留存下来的数据，而现在的大数据分析也更多源于对用户数据的探索。所以，对于数据库的测试很重要。我们也不能仅仅限于了解数据库的增删改查，还需要学习更多。我们就以目前比较流行的 MYSQL 为例：

- 客户端 Navicat 的使用
- 主外键、索引等基础知识
- 基础 SQL 语句（增删查改）
- 复杂查询（多表查询、子查询、分组查询、统计等）
- Mysql 内置函数
- 存储过程

随着现在大数据的使用，我们可能还需要了解分库分表逻辑的使用，也会包含 ODPS 等的使用与操作。



### 协议扩展

为了未来我们更好的去做接口测试和性能测试，所以对于请求、协议的理解是很重要的。我在学员中经常见到有同学因为完全不理解 HTTP 协议而对各种性能测试所截取的请求无法理解，更无法判断哪些请求是有用的，哪些代表了什么请求内容、返回值是什么，这会大大影响我们后续的学习效率。所以，针对协议，我们需要至少了解：

- HTTP 请求基础知识、Request & Response
- HTTP 与 HTTPS 区别
- RESTFUL 接口风格
- COOKIE 与 SESSION
- WEB-SERVICE
- WEBSOCKET
- RPC 接口协议
- 浏览器开发者工具
- Fiddler 抓包工具使用
- Wireshark 使用
- 手机抓包



### 敏捷管理

“敏捷开发以用户的需求进化为核心，采用迭代、循序渐进的方法进行软件开发。在敏捷开发中，软件项目在构建初期被切分成多个子项目，各个子项目的成果都经过测试，具备可视、可集成和可运行使用的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。” 上面是敏捷的官方解释，正是由于敏捷以用户为核心、迭代交付的思想，成为了最适应当前时代发展的项目管理模式，是当前甚至是未来的核心，目前 80% 以上的公司都在践行敏捷。敏捷也对测试人员的要求越来越高，所以在走上测试 “黄金” 等级之前，认识敏捷、掌握敏捷是很重要的一课：

- 敏捷核心原则 & 宣言
- 敏捷流程
- 敏捷测试
- 持续集成
- Jenkins 使用
- Sonar 使用与集成

对敏捷的学习也是为我们未来进行 DevOps、TestOps 打下基础。



### 学习一门语言

我想一定有人猜到了，也有人要发出惊呼。很多转行来到测试的同学都在跟我说：风落，你说测试还要学习代码？我从开发转过来就是为了不写代码啊！！

我认为是必须的。测试不仅仅需要看开发的代码，自己也需要编写一些代码，包括自动化测试、测试工具，都需要代码能力的辅助。所以我认为代码学习在我们的测试进阶道路上是必不可少的。当然，我们不需要学的非常非常深入，所以以 Python 为例，建议大家可以先从下面几个方面开始学习：

- Python 基础语法：环境、变量、运算、循环、函数等
- Python 编程基础：类与对象、集合、数组、文件操作、Excel 读写等
- 单元测试：UNITTEST 使用
- 其他：日志、异常处理等



### 业务

对业务的学习是非常关键的，尤其对于我们刚刚跨入测试行业来说。熟悉了业务才能更好地做好测试，而对很多项目来说，测试人员可能更需要在项目的开始就介入参与需求讨论与分析，需要很快熟悉业务进入角色。所以也需要大家花更多的时间与业务人员去沟通学习。



### 辅助工具的使用

测试其实是离不开工具的，我们前边也提到了很多工具，包括抓包工具、远程工具等等，除此之外呢，我们也需要熟悉掌握一些其他基本工具的使用，包括但不限于下边一些：

- GIT、SVN 等版本控制工具客户端的使用，方便我们去更容易追踪开发人员代码修改的情况。
- Eclipse、IDEA 等 IDE 的使用，便于我们更接近底层，熟悉代码逻辑。
- Beyond Compare、UE 等文本处理工具的应用，让我们可以更好的处理文件及数据。
- 禅道、JIRA 等项目及缺陷管理工具

这里边提及的主要是一些辅助能力，同时我们测试仍然需要兼备逻辑思维能力、学习能力等软实力。也许有的同学觉得没想到测试要学习这么多东西，但是凡事要趁早，尤其作为 IT 行业，一定要在最初的阶段打下良好的基础，这对未来发展的好处是显而易见的。当然，对于我们来说最重要的自动化、接口、性能、安全测试能力等硬技术实力，且听我后续徐徐道来。

## **11 对测试来说，看懂代码重要？or 不重要？**

上一篇文章聊到测试也应该要学习一门语言，读懂一些代码，引起了不少同学的 “轰鸣”。之所以说 “轰鸣” 而不是 “共鸣”，大抵是很多人觉得让测试人员学代码是一件很困难并且得不偿失的事情，非计算机专业的，没接触过；计算机专业的，没学好；做过开发转行测试的，隔了几年也忘的差不多了。所以，今天我特意单独跟大家谈一谈这个话题。

先从我自己说起，我大概做了有 10 年左右的测试，从一个硬件行业转型过来的小白到现在掌握多个核心系统的业务；从毕业当初连数据库、Linux 都不熟悉的小男孩，到现在能够熟练 hold 住数据库调优、服务器监控，感悟很多，工作方式转换也很多。

最当初打开界面手动，到处点，偶尔发现问题，就兴奋的记录 BUG 到后来开始通过日志定位问题，再到现在，如果有新的业务和迭代修改，我的习惯一般是先通过 GIT 查看程序变动，review 代码的修改是否覆盖完整、是否可以解决现有问题，更多的时候，是结合着我对系统整体代码的了解，看研发人员的修改是否跟我所想的一样。如若不同，则先在心中分析哪种方式更好，是否有未关注的遗漏之处。当对代码 review 结束，有确认存在的问题直接跟开发讨论，有些存在疑问，则后续在功能测试中重点关注。

这是我发展到现在最常用的测试方式，当然不是所有人都适用，但是我觉得通过代码看本质，做基于代码的、偏白盒的测试是未来发展的方向之一。**所以我的观点自然是正方：对测试人员来说，看懂代码很重要。甚至不只是重要，而且很必要。** 接下来我作为正方的 “一辩”，从几个方面阐述一下看懂代码的必要性：



### 看懂代码的必要性



#### 生产问题复现

作为测试人员，很多情况下需要跟生产问题打交道，负责第一手的排查。这些问题都是通过客服或者运维反馈而来的，而有时候客户返回的信息并不完备，根据这些不完备的信息很难重现问题。例如：

*某天，客服人员向测试组反馈：有客户投诉在下单过程中，支付成功完成后发现除了一笔付款成功的订单，还出现一笔待支付的订单，客户担心重复扣款问题，所以投诉询问。*

结合这样的投诉，测试人员先从灰度环境下手，下单支付成功，查看订单，仅有一笔付款成功订单，复现失败。

由于有图有真相，测试人员开始从代码逻辑入手分析。我们可以确定客户调用的是购买接口，所以顺着代码去跟踪，发现可能存在这样的问题：如果第一次扣款超时或者失败，换卡重新支付的时候，由于幂等校验逻辑有误，会重新创建一笔订单并进行支付，这样前一个订单就始终为待支付状态了。由此，我们通过客服与客户确认，果然客户第一次选择的银行卡余额不足，所以换卡支付出现了这个问题。

看，如果你懂代码，能够更快的重现问题，而不是无头苍蝇一样的重复测试。即便你拥有很好的探索式测试技巧，也会浪费大量时间。



#### 提升测试效率

如果说在测试过程中，我最烦躁的一件事情，那莫过于不断的返工。可能开发调整修改的代码很少，但是对于测试来说，每一次回归测试所带来的工作量是巨大的。所以，如果在开发提测了某个修改之后，能够在第一时间通过代码变化来评估是否修改的完整，那么效率岂不是大大的提升？这也是我经常会先读代码的原因之一。

除了进行 review 的工作，阅读代码也可以很好的帮助我们对测试用例进行完善，取长补短。很多时候我们会不自觉的忽略一些由于开发的组件原因带来的错误，比如：

*我们系统设计思路为 - 如果支付调用银行超时，则异步通过消息队列的方法，将异常信息发送至队列，同时实时有监听程序一旦发现队列中有超时的消息，则获取下来重新调用，成功则继续执行后续业务，继续超时则再次推送回队列中。*

针对这样队列设计的异常，我们可能会由于不熟悉不了解而忽略漏掉相关的测试用例，这时候通过代码 review 的方式能够让我们更好的 get 到这些点，从而完善用例中对于消息异步推送的验证点，更好的保证系统不出现问题。

更重要的一点是，我们在阅读代码过程中会带着一些对于代码设计上的不确定和疑问，从而在测试时候更加有所侧重。根据我自己的实际经验，这样在测试时发现问题的可能性也会更高。



#### 定位问题

这一点咱们前边就聊过，提 BUG 的最高境界是什么？**发现问题、描述问题、定位问题并且给出解决方案**。对于一些简单的问题，相信大家如果能够读懂掌握代码，完全可以自己通过日志的报错信息轻易的定位到代码报错的地方，进行后续的分析，而不是仅仅把截图和日志扔给开发。

对于我们来说，工作中有时候由于日志的缺失，不方便定位，我们还会自己去增加打印一些日志来帮助我们定位，所以如果你能掌握程序日志的写法，将会很有帮助。



#### 后续进阶

测试不需要写代码的时代已经成为过去，未来不管事要做自动化、测试开发、接口测试等，不管是去写个小工具、编写一套框架或者写个测试平台都需要你真正动手去编写大量的代码，这时候对你能力的考验就可想而知了。从这个角度看，代码的学习也是十分必要的。

我这里也多聊一点关于代码学习的方法。前一篇我介绍了一下觉得必须要学习的内容，而在这之后我们真正要进行开发，我自己比较推崇的方式是边做边学。很多同学一听说要学写代码，OK，先买上一堆《从零开始学 PYTHON》、《20 天 JAVA 速成》（书名纯属虚构，如有雷同估计就是巧合），抱着书从头学到尾，然后感觉什么都没学会。而在有一定基础之后，边做边学能够在实战的过程中更加深刻的领会这些代码知识，这也是在慕课上各种课程答疑里我都强调大家不要只是看，一定要动手去实战的原因，这也是为什么我更愿意去做一些大型的实战课程，避免大家对知识的掌握浮于表面。



#### 提升业务能力

代码还能提升业务能力？这是必须的。代码是所有业务的底层，只有对于底层业务更熟悉，那么你才能对业务掌握的更加炉火纯青，也能够更好的在需求阶段就介入项目中去，评估需求的可行性和影响范围。

以我们自己为例，其实任何一个庞大系统，不管测试用例做的再全面，真正到了一些细节的逻辑，一定还是要通过代码去整理的。



#### 完善思维方式和提升个人形象

码农的世界我们也可以懂，经常性的关于程序，关注代码逻辑，可以非常有效的完善自己的思维方式。同时，我们也会跟开发的沟通更加顺畅，也更容易理解开发的设计，理解架构的思维。这样，在开发同胞的眼中，我们的地位也会上升很多。

综上所述，"我方" 认为：对于测试来说，看懂代码很重要！

那么你呢？你认为看懂代码重要还是不重要？欢迎大家给我留言，发表你的观点。

## **12 别人家的tester：一线互联网测试现状**

小时候我觉得自己最大的敌人，就是 “别人家的孩子”，我相信很多同学都跟我一样深有体会。当我想要玩会游戏的时候，“别人家的孩子” 一定在认真学习；当我考试考了全班第二，“别人家的孩子 “每次都考第一；当我考上了 “985” 大学，“别人家的孩子” 却都考上了北大清华。OK，只要清晨的第一缕阳光来临，山有棱，天地分，” 别人家的孩子 “就一定会闪耀在我们的生命里，成为我们的榜样。

![图片描述](http://img1.sycdn.imooc.com/5d804f06000117b203000257.jpg)
那时候的我一直是不忿的，直到我长大了，工作了，我自己也会不自觉的有这种想法：为什么 XXX 跟我差不多大，已经都是高级架构师了？怎么 XXX 什么都会？慢慢的我觉得，似乎一直以来 “别人家的” 成为了，我自己的奋斗目标，我会下意识的选择一个比我自己强，但是又强的不太多的人，作为我阶段性的目标，希望自己能够逐步追上他。PS：当然，我不会选 “马爸爸” 作为我的目标，这个 “别人家的爸爸” 太厉害了，有点遥不可及……



### 一线互联网公司要什么样的 Tester？

之所以聊了这么久 “别人家的孩子”，是因为作为测试猿的我，也想跟大家一块去探索一下 “别人家的 Tester”。前边跟大家说我们该学 A，要学 B，然而工作中呢？测试人员的工作难道只是通过各种手段去测试、去找 BUG 么？

![图片描述](http://img1.sycdn.imooc.com/5d804f170001345403070281.jpg)
我们先从各大企业的招聘 JD 上略窥一二：

![图片描述](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)

![图片描述](http://img1.sycdn.imooc.com/5d804f3c0001106406850444.jpg)

我们很惊讶的发现，似乎一线互联网里很多对于测试的要求更高，不仅仅处于 “找 BUG” 的阶段了，而是开始要求部分编程、生产力提升、流程管控等能力。在我十余年的测试经验里，从过去的传统行业到现在的互联网，测试的职责和方法一直在发展。
历史上的测试工作是死板的、无奈的、落后的，而现在更加灵活，更加注重技术能力，更加贴近先进的测试方法。那就让我们一起去看看他们的测试工作现状是什么样的。



### 别人家的 Tester



#### **国内互联网**

目前国内一线互联网，整体来说做法都差不多，只是不同公司，不同岗位因为业务类型差异而侧重不同。我总结下来，目前在做的工作主要包含三个方面，可以用 “**VMPSE**” 来归纳。

**V**：Validation。**测试验证性工作**，诸如我们前边介绍的需求测试、代码 review、测试设计、冒烟测试、测试执行、上线验证测试，这些都属于 validation 的范围。这也是传统意义上测试所要求的工作范畴。

**M**：Monitor。**监控类工作**，包括线上业务的监控，线上数据的跟踪，甚至包括一些波动统计都需要测试人员更多去熟悉、掌握。在一线互联网公司里，由于互联网产品的特殊性，生产上的情况需要无时无刻的跟踪和解决，而测试工作的最终成果也是我们的产品上线效果。

**P**：Productivity。**生产力效率**，简单来说，就是能够节约人力成本和资源成本的工作。这里会包含流程管控规范、敏捷持续集成 / 验证 / 发布、自动化集成、测试工具开发等等。目前在招聘职位中，测试开发岗位的主要职责就是在生产力效率这部分，在我们内部对这类工作有一个特殊的名字，“牲畜”–生产力促进。

**S**： Stability。**系统稳定性**，这里包含很多的稳定性相关测试工作，比如，系统的性能、安全、大数据测试等。这些工作虽然看起来并不关联性能，但对于生产上线的稳定至关重要。当然，这也是人才最稀缺的一部分。

**E**：exploration。**探索研究类的任务**，新技术都在不断发展，无论产生了什么新鲜的方法论，又或者是有什么通用的开源框架，研究工作永远是测试工作里最有意思也最有意义的一部分工作内容。

诚然，我也承认，目前国内很多公司，甚至是一线互联网公司还做不到把测试人员 “一碗水” 端平，所以仍然会有 “**面试造火箭，入职拧螺丝**” 这样的情况，但是面试造的更多是虚拟的模型火箭，而工作里拧的确实真实火箭的螺丝，“不积跬步无以至千里”，只有先拧好螺丝，才能接下去造机身、发动机，最后设计完整的火箭。所以，每个人心中都要以 “造火箭” 为目标，以做到 “VMPSE” 为初心。



#### **国外互联网巨头**

国内的互联网目前发展方向还是比较接近的，但是认真研究测试工作的发展趋势，研究国外互联网大佬们的实践，一定可以有所收获。

**Facebook**

Facebook 目前已经不再有专职的测试人员了。更多依赖于开发人员进行自测，或者交互测试来保证代码质量，保证的方式也从最早的单元测试，到现在有内部的 Java 测试工具 - Jest，也有端到端的 Watir 等自动化测试手段。由于 Facebook 更多的属性还是社交媒体，所以测试人员对于他们来说并不是刚需，释放更多资源去做更有价值的工作。

当然，因此 Facebook 的质量并没有非常高，但是他们采用了另外一种发布策略，被称为 “金丝雀”，把测试战场的战火蔓延到生产环境上去，让一小部分用户去验证他们的修改和新功能。同时，也根据反馈的结果来决定是否放开金丝雀范围、进一步修改或者放弃回滚。

**微软**

Facebook 的方式是符合他们自身的一种测试策略，而微软，他们的测试人员不再称为 QA 或者 Tester，而是叫做 SDETs 测试领域的开发工程师。

![图片描述](http://img1.sycdn.imooc.com/5d804f770001ffd309230123.jpg)
简单来说，SDET 是一个专注于开发自动化测试脚本的技术软件测试人员。通常，它们是敏捷团队的一部分，除了参与典型的测试活动，他们还可以编写自动化集成测试、API 测试和 / 或 UI 自动化测试中的任何内容。微软的测试开发比可以达到 2:3，这是一个非常高的比例，所以，微软由于自身产品的属性，不便于回滚，所以耗费更多的时间和人力去保证产品的质量。

从国内外互联网企业的测试现状来分析，我们能够得出一点结论：自动化测试越来越具有很重要的位置，同时，“测试没通过的东西不能上生产” 这样的 “基本原则” 更是被逐步打破，所以，作为测试人员的我们，也应该从现在开始转变思想，跟上 “别人家的 tester”。



### 浅谈测试行业的发展趋势

先从功能测试说起，网络上流传过一种说法，叫 “功能测试必死”，然而实际上功能测试是不可能消失的，即使是 Google、阿里这样的高技术公司，也仍然并将长期需要功能业务测试，需要业务领域测试专家的存在。所以功能测试会依然存在，但是纯功能测试，会越来越难找工作。不论如何，在一线互联网的带领下，即便未来的功能测试岗位，也会要求必须会各种语言、技术。所以，如果不会些技术、懂些代码，工作会越来越难找。

**UI 自动化测试**与**接口测试**会越来越受重视，而且接口测试会更受青睐。由于快速迭代带来的前端的不断优化，除非有非常优秀的规范和页面设计规划，不然修改 UI 自动化代码的成本将会越来越高。当然，我相信，随着技术的进步，未来一定我们会有更好的方式解耦，所以 UI 自动化测试纯技术层面可以不重要，但是诸如 PO、分层等等的思想还是非常有价值的。

相比之下，投入产出比更高的接口测试，将会在很多公司中大量开展。目前来看，蚂蚁、阿里、腾讯 80% 以上的产品线都覆盖了接口测试，一套完善的接口测试体系，能够在快速迭代中很大程度上提升项目的稳定性。

性能测试呢，我觉得依然是稀缺的。当然，我这里聊的性能测试不是说简单的用 LoadRunner 或者 Jmeter 或者 Grinder 去跑一下几千上万的并发就可以了，性能测试里最重要的部分，在于性能需求的分析、场景的设计以后测试过程后的性能监控与优化。这需要我们有更多的开发能力、系统熟悉度乃至于架构思想。

对于**安全测试**和**渗透测试**这样的，至少在测试领域相对冷门的技术来说，所有能够在这方面有所建树的 tester 一定是一块 “肥肉”。

总结来说，企业需要的 “一专多能” 的人才。“多能” 是指综合性的能力，而 “一专” 则是要求你在一个域内的深耕。人嘛，你可能什么都懂，却很难面面俱精。我总是在我的班上这么跟大家聊，我觉得做测试就是在一片贫瘠干燥缺水的土地上打井，开始你肯定要多找几个地方打井，一旦发现哪个地方比较适合做一口井那么就一定深挖下去，非得要挖出水来不可。

什么才叫 “挖出水” 呢？

举个例子，我说我做性能测试非常专业，我能够在项目设计阶段结合产品需求，和历史同类产品分析出大致的性能要求，并设计出完善的性能场景；发现问题我能够使用一系列工具来监控、定位核心问题，推动开发改动，规范编程行为，预防出现内存泄露、慢 SQL 等问题；通过数据工厂方式进行大数据量模拟；灰度环境进行全流程性能测试，并且在线上进行监控。

OK，这样的例子，如果你能举出来详细在项目中应用的一二三四五以及具体手段，这就叫 “一专”，一定可以成为某领域的专家，不仅仅是 “挖出了水”，还 “挖成了井”，并且保证自己在未来很长一段时间 “有水喝”。



### 总结

今天带大家看了看 “别人家的 tester”，虽然看上去打水的路越来越难，但是无论做任何事情都有这样一个从无到有，从零到一的拼搏过程。也许这个过程会让你痛不欲生，但是熬过去就会轻松很多，所谓 “好的开始是成功的一半”，踏出第一步，等到回头回顾这段路程，相信你也跟我一样，感慨良多。

关于功能测试、学习路线的篇章暂且告一段落，从下一篇开始，我们将进入测试技术的大门。

# **第4章 WEB自动化测试**

## **13 你真的了解自动化测试么？**

通过前边对互联网行业的了解，我们真真切切的认识到自动化测试，对于我们来说非常非常重要。我相信很多同学已经了解甚至编写过自动化测试脚本了，但是请你静下心来想这样一个问题：自动化测试到底是什么？

举一个形象一点的例子，我们俩在同一个公司且座位相邻，这天你跟我说：风落啊，我午休时候很容易睡过头，你能不能每天下午一点时候拍醒我？像我这么善良，又有同情心的人一定是满口答应了，可是一周之后我觉得叫你起床这件事又重复，而且还要每天记得，比较累。怎么办呢？我想了个好办法，花一周时间做了一个机器人，这个机器人每天 1 点固定去你座位上把你打醒。这样我就可以去做其他事情了，解放了我自己的人力来提升效率。

这就是最简单的自动化测试了，归纳成比较官方的表达，就是把人为的测试行为转化为机器执行的一种过程，目标则是节省成本，提高测试效率。尽管这个定义很简单，但是实际上，我们在推进自动化测试的过程中，会产生很多的错误理解，这时候，我们再来想另一个问题：你做自动化测试的预期是什么？或者换个方式：你的项目中，进行自动化测试的目标是什么？

我也就这个问题问过很多同学，我一点都不意外的收获了很多这样的回答：*我不知道为什么要做自动化测试，领导要做，我便做了。*

正是源于根本不清楚自动化测试的目的，也便会漫无目的去进行投入，所以很多公司的自动化测试走上了一条弯路。我曾经去到一个，自称自动化测试覆盖率达到 95% 的公司去做相关咨询，发现他们的自动化是这样的：

- 按照功能测试用例用代码实现
- 通过 Eclipse，选好环境
- 右键 Run As TestNG
- 一个人，甚至是两个人一起目不转睛的盯着显示器
- 步骤执行不成功，回到代码，Debug 找问题，修改代码
- 部分脚本执行过程中卡住了，手动辅助点击，继续执行

看到这里，我几乎崩溃了，这样真的是为了自动化而自动化，即使覆盖率达到了 95%，也并没有真正提升他们的效率，而这，正是他们要我去帮助解决的问题。很无奈的我，抓了一个自动化测试工程师，问他们这样做的原因，回答更是让人吐血：老板要做自动化，自动化不就是写脚本么，这难道不是自动化么？我们觉得这样很好啊。为什么要做自动化，这是领导的决定，我们都是执行的。而且以前都是这么做的啊，也没人说不对啊？

这样的灵魂拷问让我几乎无言以对。这是我们很多公司里都出现的场景，为做自动化而做自动化，而公司上下都并没有理解自动化测试真正的意义，也没有对自动化测试的预期。自动化的真正产出不是代码，而是更好的流程和效率。所以，自动化测试也要考虑 ROI - 投入产出比。

说到这里，又不得不聊我自己的另外一次经历。先前，被邀请到一家小型公司进行自动化梳理，老板给我提出了三大要求：

1. 自动化测试要覆盖 100% 功能测试，后续不需要再招聘功能测试人员。
2. 自动化测试要稳定，不需要太大的维护，他希望未来测试团队只有 2 到 3 名自动化人员。
3. 运行的结果可以自动报 BUG，不需要人工介入。

一般情况下，不太懂自动化的老板或者 VP ，都会对自动化测试，抱有不切实际的幻想，觉得有了自动化测试可以省下很多人力成本，自动化测试能够做一切。这必然是不可能的，不要误认为自动化是万能的，就像我们有一所大房子，想要打扫的时候，我只需要按一个机器人的按钮，它就会自动的去擦桌子、扫地，把房子打扫的一尘不染。实际上自动化只是我们整个工作中的一个辅助性工具，再优秀的测试用例、再稳定的系统也不可能 100% 被自动化的。业务功能、复杂的逻辑、探索性的特殊操作，以及测试人员的经验，都是没有办法被自动化的。

所以，综合这两个角度来看，我们对于自动化测试的期望既不能过低，也不宜过高。那么，让我们回答之前的问题，**自动化测试的意义**到底是什么呢？谨慎来说，是把我们的自动化测试应用到项目中去，在保证质量的前提下，让项目的测试成本低于纯手工测试。

如果真的能满足这个要求，我们就可以认为自动化测试有意义了。接下来，让我们发扬咬文嚼字的风格，一起抠抠字眼，把这个要求细化一下：

首先，第一个关键词就是 “**自动化测试**”。自动化测试的范畴到底有多大，在很多人看来自动化测试，就是那些可视化的 UI 层的自动化，什么 QTP、Selenium、Appium 这些东西，事实上远远不是，更不是在很多人看来，写个脚本就叫做自动化测试了。

```java
#coding=utf-8
from selenium import webdriver
4 driver = webdriver.Chrome()
driver.get("https://www.baidu.com")
driver.find_element_by_id("kw").send_keys("fengluo")
driver.find_element_by_id("su").click()
driver.quit()
```

这是一段很简单的代码，打开浏览器打开百度，输入 fengluo。这当然是个自动化脚本，但是就依赖于它，我们谁都不能说我们就会做自动化了。或者再前进一步，我们能够写很长的脚本，甚至可以实现 Jenkins 的一些持续集成，就算掌握了自动化测试么？

一个好的自动化测试设计，不仅仅要能让用户方便使用，还需要符合一些基本原则。这些原则包括：可复用、易维护、定时处理、持续集成、可调试、测试结果自动通知等等。所以高效的自动化需要优秀的框架，而框架的概念，是一系列的被事先定义好的标准和规范。

在自动化测试中，我们经常提到的对测试需求的解析、脚本设计、测试执行、测试报告、维护管理等等，通过框架将它们串联并封装起来，从而使框架的终端用户，能够更方便地使用。再具体到更细节的框架我们在后边的内容里详细再介绍。

接下来是第二个关键词，“**成本**”。什么才是我们做自动化测试的成本呢？其实我们做自动化，核心的成本在于首次编写自动化脚本的时间成本，再有就是我们每一次迭代、每一次修改过程中维护自动化脚本的成本。就像前边一段说的，越是好的自动化设计，越能够进一步降低在自动化脚本编写和维护上的成本。

最后一个关键字，“**低于**”。既然是个比较级的词，那么势必要用自动化与手工测试进行一番比较。我们的基本要求是让自动化的成本低于手工，所以如果用公式来形容的话，应该是：

收益 = 手工测试成本 (自动化可覆盖部分)- 首次编写自动化脚本成本 - 自动化脚本维护成本

当收益为正的时候，则证明我们的自动化确实卓有成效。但是如果大家写过一些自动化测试脚本的话，就会发现，在瀑布式、不稳定或者是小项目流程下，这个收益很可能为负收益；这就引出了另外一个话题：既然很容易出现负收益，那么为什么要做自动化？或者换个方式，什么项目适合自动化？

放眼望去，国内外大多自动化比较成熟的公司，都有共同的特征：稳定 & 迭代。

所以像淘宝、京东这样的系统，一个版本发布以后要支持很多年，做的大多是 BUG 修改或者小的活动迭代，这样自动化的收益就会比较可观。在这种情况下，公式可以做这样的变更。

收益 = 手工测试成本（自动化可覆盖部分）*迭代次数 - 首次编写自动化脚本成本 - 自动化脚本维护成本*迭代次数

这样我们就会发现，只要我们在每个迭代中的维护成本小于手工回归成本，那么随着迭代次数的提高，收益就会无限增加。从这个公司我们也可以得出另外一点启示：**一个项目的早期不适合自动化**，因为需求的不断变化，业务逻辑的不断调整会使自动化的收益很低甚至为负。同时，并不是每个项目都适用于高度自动化，产品 UI 会频繁变动的，我们可能会用接口自动化来提升自动化覆盖率。

当然，这个公式只能描述大概，并不精确，通过我对很多公司的了解，我发现很多时候，我们的自动化成本中还需要增加一项：

收益 = 手工测试成本（自动化可覆盖部分）*迭代次数 - 首次编写自动化脚本成本 - 自动化脚本维护成本*迭代次数 - 延误成本

什么是 “延误成本”？

这里边我觉得更多的是管理、支持方面带来的困难。我曾经见过很多团队的测试总监，针对一套框架不断的进行会议评审、讨论、架构调整，更有团队 leader 甚至是老板多次更换自动化测试工具，最糟糕的是还有老板要求切换语言，从 JAVA 变成 PYTHON，为什么呢？因为 PYTHON 最近火啊。一旦遇到这种情况，延误成本将变得无穷高，自动化测试的收益和效率自然不必说，只能是一场灾难。最终测试人员工作的不开心，团队领导觉得自动化测试效率低、收益差，要不放弃自动化，要不然变成鸡肋。

自动化还是一个很专业的领域，一个优秀的测试架构对于技术、架构和管理规划都有很高的要求。我毫不怀疑正在看到这篇文章的同学们一定有未来成为测试总监、VP 的大人物，也正像我在各种分享、在各个公司咨询时候，跟各种老板们说的最多的一句话：**无论你懂不懂技术，请尊重自动化测试技术人员和架构的判断，自动化测试并不简单，也不是可以一蹴而就的，信任你的团队，让专业的人做专业的事情。**

零零散散的说了很多，总结一下核心只有下边几点：

1. 不要为自动化而自动化，不是所有项目都需要自动化，自动化一定要保证收益才有意义
2. 自动化测试不仅仅是脚本，而是设计，通过更好的设计来降低成本提升收益
3. 国内大多公司的自动化还在路上，不要用错误的思想去认识自动化，做专业的自动化专家

你是怎么做自动化的呢？有没有什么好的方法介绍？欢迎留言大家一起讨论。

## **14 回溯UI自动化测试工具的前世与今生**

前面我们一起深刻认识了一下**自动化测试**，相信大家一定已经对自动化不再陌生。对于自动化测试的世界来说，UI 自动化测试是很重要的一个组成，可以说很多人听到自动化测试第一时间联想到的都是 UI 自动化测试；对于我自己而言，UI 自动化测试也是我最早接触的测试开发技术。所以，于公于私，今天都想透过我自己的一些经历跟大家分享一下 UI 自动化测试和 UI 自动化测试工具。



### 什么是自动化测试工具

也许面对这个问题，很多同学要说，自动化测试工具很简单啊，可以让我们完成自动化测试的工具就是自动化测试工具呗。我觉得对，也不对。诚然，目前行业上，并没有对所谓的自动化测试工具有什么定义，只要可以执行自动化，都可以这么称呼。

但是，我呢，有一点小小的贪心，希望能在自动化测试工具的前边加上一个 “好” 字。所以，什么可以称之为一个好的自动化测试工具？

我觉得一个好的自动化测试工具，应该具备这么几个特征：

- 支持脚本化语言 (Scripting Language)
- 对程序界面中对象的识别能力
- 支持函数的可重用
- 支持外部函数库
- 抽象层 — 将程序界面中的对象实体映射成逻辑对象
- 支持数据驱动测试
- 错误处理
- 调试器
- 源代码管理
- 支持脚本的命令行 (Command Line) 方式

支持脚本化语言可以让测试人员更好的学习上手；

具备识别能力能够大大提升自动化测试定位的准确性；

可重用、外部函数支持、面向对象编程让我们的自动化有了代码属性，从 **“一锤子买卖”** 的脚本升级为可以复用的框架结构，也给了自动化测试未来以无限的可能性；

支持数据驱动能够让我们更好的扩展测试案例；

而错误处理、debug、源码管理和命令行执行则是便于我们调试和自动执行。

匆匆的制定了一套标准，那么，就让我们按照这样的规则去看看历史上的好自动化测试工具们。



### 第一代 UI 自动化测试工具–录制回放类

我开始工作的时候，正好赶上录制回放类自动化测试工具成为主流的时候，其中最为有代表性的就是 QTP。在那个年代，基本上自动化就等于 QTP，当然，在它之前还有 WinRunner 这样的庞然大物，不过也没有能够像 QTP 一样统治一个测试时代。

![图片描述](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)
不知道还有没有人记得这个熟悉的界面，我们一起来重新认识一下它。

QTP 全称 Quick Test Professional，是一种基于录制回放的自动化测试工具。QTP 的老东家可不是我们现在看到的惠普公司，而是 Mercury Interactive，它的第一个版本发布于 1998 年 5 月，那时候的我还只是个不懂计算机的学生。之前一直声明不显，直到 2006 年被惠普收购又同时发布了 QTP 最经典的版本之一 —QTP9.0，才正式进入世人（至少是我国测试人）的眼球。这是一个商业化、插件化的工具，一如惠普的其他工具。

它的特点可以简单概括成如下：

1. **录制和回放。** 录制和回放是当时自动化测试工具的标配，通过录制回放，可以非常轻松的录制出一套自动化测试脚本，稍加修改就可以使用。
2. **对象库存储。** 这是 QTP 最重要的特征，将元素对象与自动化脚本分离，同时基于内置的 SPY 工具和 Mandatory 定位方式快速获得对象并将对象识别存储，也可以进行复用。
3. **Action。** 这是 QTP 组织测试用例的具体形式，直到现在我在写自动化测试框架的时候还习惯把一些孤立的动作行为称之为 action，可见这个名词对我留下的印象之深。QTP 中的 Action 最重大的意义在于通过 Action 实现了代码的复用，一旦 action 设置为 share 类型，就可以被其他的 Test 使用，大大增加了脚本编写和维护的效率。
4. **通过 DataTale 实现参数化。** 可以基于 excel 维护，这也提升了自动化测试数据维护的容易度，比起当初其他工具通过 xml 维护数据更容易更便捷。
5. **可以引用外部的 VBS 库**，让各种 VBS 库可以为所有的 Action 和 Test 共享。

按照我们前边的标准，QTP 在当时就是自动化测试的标杆，几乎所有的后来者都要以 QTP 作为模板，当年各种商业化工具的介绍语大多都是 “XX 方面可以媲美 QTP”，可见 QTP 在那个时代的统治力。我在写这篇文章的时候，以 QTP 作为关键词简单搜索了一下，发现近几年更多的问题变成了：**QTP 还有人在用么？**

为什么呢？

我回想了一下，在那时候主流测试都是 CS 应用，更多的是 windows GUI 程序，纵然有一些是 web 应用，也非常简单。而现在呢？随着互联网的兴起，重量级的 QTP 已经很难胜任自动化的使命了。

录制和回放无法保证脚本的良好可读性，对象库中录制识别的东西也不同于手写，手写的那是亲儿子，自己一眼便能认识；对象库呢，是别人家的孩子，偶尔夸两句无妨，真要掏心掏肺，完全不认得它是谁；QTP 大型的架构让其运行的速度和性能极其低下，要是用 low 一点的服务器都不好意思动手做自动化。

正是因为这些原因，在互联网大潮来临的日子里，在 2010 年第二个 “双十一” 到来的时候，我毅然决然的抛弃了 QTP 的大本营，加入了第二代 UI 自动化测试工具的大潮。



### 第二代 UI 自动化测试工具–开源编程类

Selenium 比起 QTP 来，可以算是一个新生代了，它是由 ThoughtWorks 一个叫 Jason Huggins 的小伙儿和他的团队发起的，最初的目的仅仅是不想让自己的时间浪费在重复工作上，加上由于身处 ThoughtWorks 不好使用 QTP，所以决定换个思路通过 Javascript 来编写一种工具，这便是 Selenium 1.0 的核心。

说起来好笑的是，由于当时的大势，所有自动化工具都会或多或少的借鉴 QTP 的工作方式，所以 Selenium 提供了一个可以录制的 IDE 组件，更有意思的是 Selenium 的命名完全是由于当时 QTP 是主流公司，而又属于 Mercury 公司，在英文中 mercury 是汞的意思，所以他们选择了另外一种元素 “硒” 来与之对抗，所以命名为硒（Selenium）。

Selenium1.0 是由 Selenium IDE、Grid 和 Selenium RC 组成的，而其中 Selenium RC（Remote Control）是整个 Selenium1.0 的核心所在。我们先可以通过一个图来大概理解一下其内部模块结构：

![图片描述](http://img1.sycdn.imooc.com/5d84a380000101c007300447.jpg)
可以看出来，RC 是由 RC Server 和 Client Libraries 构成的，在 RC Server 中 Core 作为 Javascript 的函数集合，实现界面的元素识别；Proxy 则是通过代理服务器的方式解耦浏览器的同源策略；Laucher 则是两者的融合剂，让我们能够在启动浏览器的瞬间，就完成 Core 的注入和针对代理浏览器的设置。如果要把其工作的方式串联起来，那么 Selenium 官方的这个图最有说服力：

![图片描述](http://img1.sycdn.imooc.com/5d84a39d0001857b07680647.png)
已经描述的非常清晰，所以对于其工作方式，我在这里不再赘述，也由于 Selnium RC 的架构设计，也不可避免另外一个问题，由于无法完全绕过浏览器沙盒的限制，同时也无法调用操作系统级别的模拟用户输入方式。

所以在 2006 年的时候，Google 的工程师发起了 WebDriver 的项目，跳出了 Javascript 的沙箱束缚，提供了更快速、轻量级的原生浏览器模拟器 WebDriver。

2008 年，Selnenium 与 WebDriver 合并，成为了我们现在看到的更强大的自动化测试工具 Selenium 2.0。谈及合并原因，还是 WebDriver 创始人描述的比较好：

> *为何把两个项目合并？部分原因是 WebDriver 解决了 Selenium 存在的缺点（例如能够绕过 JavaScript 沙箱，我们有出色的 API），部分原因是 Selenium 解决了 WebDriver 存在的问题（例如支持广泛的浏览器），部分原因是因为 Selenium 的主要贡献者和我都觉得合并项目是为用户提供最优秀框架的最佳途径。*

所以 Selenium 2.0 开始，前边提到的录制回放功能已经基本作废，相信很多熟悉或者使用过的同学甚至可能从来都不知道 Selenium 还有那么个 IDE，还可以录制和回放。所以到 Selenium2.0 开始，UI 自动化测试进入了新的脚本时代。

当然，到了 2016 年 Selenium 更新了 3.0 版本，除了修改了浏览器调用的核心以及完全舍弃了 1.0 时代的 RC 外，基本没有太大的变化了。Selenium 从 2.0 时代腾飞，到 3.0 已经趋于稳定，而现在，已经成为了最主流的 UI 自动化测试工具。

其实说起来风落自己，最早接触了解 Selenium 却是因为当初提供的简洁的 Firefox 插件 Selenium IDE 所给予的录制回放功能，为此而吸引开始研究。也在研究的过程中，逐步抛弃了录制回放，认识到了脚本编程的好处，认识到了自己能够完全掌控代码的优势，也开始了漫长的自动化测试探索之旅。

ps：第一次使用 Selenium2.0 却是因为 Selenium 的脚本抢马爸爸双十一的红包雨速度可比 QTP 快太多了……



### 2 Plus 时代 — Selenium 后时代

时至今日，Selenium 仍然是 Web 应用程序中，最受欢迎的开源测试框架，包括我在内的很多人都在上边进行封装、修改来设计属于自己的测试框架。所以，一部分非常优秀的自动化的测试工具，比如 Katalon Studio，Watir， Protractor 和 Robot Framework 都是以 Selenium 为底层核心框架的，国内也如是，我知道包括 Holmos、TestWriter 底层也都是基于 Selenium 的。所以，这个时代我们可以称之为 Selenium 后时代。

我敢肯定的说没有哪一个高级测试开发没有在 Selenium 的基础上搭建过测试框架，甚至 6 成以上的测试架构都下手去拆过 Selenium 的源码，到这里，Selenium 如同当年的 QTP 一样，几乎完成了对一个领域的统治。当然，不可否认，UFT（QTP 的升级版）、RFT 等工具仍占据一部分份额，但已经不是主流了。

当然，随着 Selenium 的深入使用，大家开始越来越多的找到一些 Selenium 基于浏览器无法解决的问题，尽管它已经跳出了沙盒的限制，但仍然很难处理一些基于系统的、自定义的处理。比如大家现在随处可见的自定义上传框、系统域账户认证等在 Selenium 中就很难处理。所以，在 Selenium 后时代，我们逐渐也开始寻找到一些可以辅助 Selenium 进行自动化测试的小工具。

我常用的一些小工具包括：

1. **AutoIT**： 一款可以录制回放的小工具，之所以用它而不用 UFT 等工具在于它可以非常简单的生成一个 EXE 文件，供我们在 Selenium 中进行调用。
2. **Sikuli**： 一种新型思路的自动化测试工具，是由 MIT 的研究团队发布的新型图形化编程技术。它以图像检索技术为基础，提供了一套基于 Jython（python 语言在 java 中的完整实现）的脚本语言以及集成开发环境。使用者可利用屏幕截图直接引用 GUI 元素进行编程，完成交互操作。第一次见到 Sikuli 的脚本是这样的：

![图片描述](http://img1.sycdn.imooc.com/5d84a3b70001054b04270520.png)
初看这样的脚本，真的非常惊喜，但是实际使用中仅可作为辅助使用，毕竟对于图像的识别要求过高，在不同的系统、不同分辨率、不同浏览器等等情况下都很难兼容。当然，后边又有 Airtest 这样的可以算是 Sikuli 的后代的工具，是网易出品的一款基于图像识别和 poco 控件识别的一款 UI 自动化测试工具。Airtest 的框架是网易团队自己开发的一个图像识别框架。对于我来说，并没有感觉它比 Sikuli 更好用，仅仅是 IDE 上的功能相对更加强大便捷。



### 总结

谈过了 UI 自动化测试工具的前世今生，现在的我们可以说是站在巨人的肩膀上。“巨人的肩膀上” 既是机遇，也是莫大的挑战。对于知学善进、能踏实研究的你来说，在 Selenium 已经成熟的今天，你可以做的更好。你可以让你的脚本从出生（脚本开发完成）、第一声啼哭（脚本自测）到成长（框架实现）、生存（执行与维护）这每一个阶段都变得更加美好。

也许你还在尝试着自己的第一个脚本，也许你还在沉迷于录制回放的 “常规操作” 之中，也许你已经开始领略到 Selenium 的优势，也许你正在尝试编写自己的第一个框架，我希望有一天，你会非常兴奋的给我留言：风落，我刚刚开源了一套 UI 自动化测试框架源码，欢迎大家都去看看！

那么从今天开始，从自动化测试工具走向自动化测试框架的漫漫长路吧，可以略感欣慰的是，这条路上不只有你，还有陪着你的风落，还有和你一样努力的” 他 “。

## **15 驱动方式PK：数据驱动 VS 关键字驱动 VS 行为驱动**

上一次我们从 UI 自动化测试工具聊到了自动化测试框架，有很多同学就郁闷了：这自动化测试脚本也不是个变形金刚，不能让我们随便一吼脚本就能随时变形状的。更有同学愤怒地告诉我：我还不会写自动化测试脚本呢，风落你就让我开始写框架啊。

当然不是，不会走直接学跑，甚至学飞必然是不提倡的。所以，大家首先要学会如何编写一个完整的 Selenium 脚本，去学习如何使用 Selenium 的一系列 API，如何通过单元测试框架整合并运行起来。

```python
from selenium import webdriver 
import time 
driver=webdriver.Ie() 
#登录xxx.com 
driver.get("http://XXXX.com") 
#等10秒，浏览器打开和网页跳转需要时间 
time.sleep(10) 
#取ID为txtLoginCode的网页元素(用户名输入元素) 
elem_user=driver.find_element_by_id('txtLoginCode') 
#清空输入 
elem_user.clear() 
#键入用户名 
elem_user.send_keys('nice_xp') 
#取ID为txtPwd的网页元素(密码输入元素) 
elem_pass=driver.find_element_by_id('txtPwd') 
#清空输入 
elem_pass.clear() 
#键入密码 
elem_pass.send_keys('*****') 
#取ID为btnLogin的登录按钮 
elem_login=driver.find_element_by_id('btnLogin') 
#点击登录按钮 
elem_login.click() 
exit(0) 
```

上边就是我们经过简单学习以后可以编写出的一个简单登录模块的自动化脚本。就像我在开篇里说的，在这个专栏里我不会带着大家去做很多，我希望能够更多给大家一些指导性的东西。所以我们接下来聊一聊把一个完整的脚本变成更好的框架，到底要做什么？

所以这才是我们今天的主旨，所谓的驱动方式其实就是一个自动化测试架构的体系，是不同自动化测试规则下来规划包括方法、数据源、识别方式、各种可重用模块在内的整套测试框架基础体系。可能这样的概念仍然有一些拗口，换个方式来说，要搭建一套自动化测试框架就好比高考考场上你拿到了一个作文题目，优秀的你可以选择用议论文、记叙文、散文、小说甚至是文言文等各种方式来完成你决定命运的 800 字，这里的不同的文体就是我们现在的驱动方式，或者我们叫设计模式，决定了我们后边该如何去开展。



### 数据驱动与关键字驱动

最早也是最常用的驱动方式就是数据驱动 DDT（Data-driven testing）和关键字驱动 KDT（Keyword-driven testing）。我曾经跟很多已经在做自动化的同学聊了关于这两个概念的异同，结果很多人都对此有困惑，又或者虽然理解明白，但是仍然不清晰二者的关系。

我们先来看一下数据驱动的简单定义：将脚本里的测试数据剥离出来，存储在独立于脚本之外的数据文件（XML， Excel 等）或数据库里，使脚本中的操作指令和数据分离。举个简单的例子，我们或录制或编写了一个脚本叫：风落用拳头打你头 1 下。从数据驱动的角度上看，模块就是 “风落用拳头打你头”，数据是 “ 1 下”，期望可能就是 “你觉得有点疼”。所以我们开始针对不同的数据来进行测试，包括 “风落用拳头打你头 1 下，你觉得有点疼”，“风落用拳头打你头 5 下，你觉得很疼”，“风落用拳头打你头 100 下，你觉得脑震荡了” 等等。输入的数据是结果的决定因素，可以理解为是数据驱动的测试。

再来说关键字驱动：从测试角度来说是把数据驱动再度扩张，将测试逻辑按照关键字进行分解，关键字对应封装的逻辑业务。主要关键字包括三类：被操作对象（Item）、操作（operation）和值（value）。所以按照这样的逻辑，刚才要打你的动作就可以分解为多个关键字：谁要打？用哪打？打谁？打哪儿？打几下？这样就把一个模块拆分的更加细化。所有我们关注的都变成了关键字，可以组成更多更加通用的场景。

那么让我们回到刚才登录模块的场景。在数据驱动的设计下中，就是将脚本中的用户名、密码作为变化的数据，将它提取到数据文件或数据库中，我们就可以用来模拟不同用户的登录过程，在这个测试过程中我们关注的只是数据，只是用户名密码，而对于具体这个模块里我们会先输入哪个，先点击哪个，我们并不关心，这是一个偏黑盒的过程。

而在关键字驱动的设计里，登录脚本是由不同的行为动作组成的，每个动作都会包括被操作对象（用户输入框、密码输入框、登录按钮）、操作（输入、点击）和值（用户名、密码）三者。我们修改关键字就可以改变他执行的动作、顺序，甚至整个登录脚本仅仅是关键字的实现之一，我们可以用同样的一套关键字来进行注册、个人资料修改等等，这是一个更加通用更加白盒的过程。

所以，这样我们通过比较发现：数据驱动和关键字驱动并不是毫无联系的，关键字驱动是更加细化的数据驱动，或者说我们把一切都作为数据，把对象、行为也作为了数据。所以，关键字驱动是数据驱动的细化，数据驱动是关键字驱动的高级封装。这二者之间没有谁更好，谁更优秀，而是视情况而定。

一般情况下，如果我们要使用编码的方式进行程序化编程，就像大家对于开发的了解一样，我们会更多倾向于采用数据驱动，将模块封装起来使用，它的好处在于：

1. **更容易复用**，利用我们再编写代码时模型化的设计，避免重复脚本，减少脚本的维护成本；
2. **脚本更加具备业务属性**，应用程序一旦修改，只需要修改部分业务的脚本而无需调整数据。

当然，这个缺点也很明显，仍然需要测试开发的人员对于自动化测试脚本比较精通，每个脚本也会有多个数据文件，随着项目的进行数据脚本也会越来越多。

如果说数据驱动更加偏向于模块，或者说更利于模型化结构设计的话，一旦我们想要做成一个通用的框架或者平台产品，希望我们的底层能够不受项目的约束，放之四海而皆准，这时候就需要使用关键字驱动的设计思想。

我们可以非常容易地把所有关键字数据存储到数据库或者数据文件中，对于每个动作进行精准匹配，最终产生一个优秀的测试框架或平台。优点很明显的在于自动化测试案例编写者可以不用关注底层实现、不用关注使用了什么语言而是直接按照框架的定义提供各种关键字，让零基础的人员可以快速上手；而当业务逻辑出现改动时，我们也不再需要修改代码，而只是调整关键字就可以达到维护的目标。

因为有了这些优点，所以劣势也更加明显：无法看到底层代码则很难去进行自定义，也很难修改；封装动作时的颗粒度也比较难以把握；同时数据库或者数据文件的复杂度比较高，维护起来可能也比数据驱动更复杂。



### 行为驱动

行为驱动是最近才开始火爆起来的概念，其实把行为驱动拿到与数据驱动、关键字驱动并列的位置上或许并不是太公平，因为行为驱动是一种新式的软件工程实践，所以这里边我们强调的是抛开代码去观察行为。什么是行为呢？就是我们希望测试人员不关注代码实现场景，用一种 “自然语言” 来设计测试用例、设计自动化测试脚本，这样的自然语言形式在行为驱动中被称为：剧本（Feature）。

我们可以来看一个简单的计算器的剧本示例：

```bash
@math
Feature: Web Selenium Test
url:https://cuketest.github.io/apps/bootstrap-calculator/

  Background: calculator
    Given open url "https://cuketest.github.io/apps/bootstrap-calculator/"
    When I click 1 + 1
    Then I click the =
    And I should  get the result "2"
    And History panel should has "1 + 1 = 2" text

  Scenario: history
    When I click the "C"
    Then History panel should be null
```

看上去是不是很清爽简洁？似乎看上去用我们可以轻易理解的语言就设计好的测试用例。实际上呢，我们来看它的底层实现：

```python
///// Your step definitions /////
// use this.Given(), this.When() and this.Then() to declare step definitions
let { Given, When, Then } = require('cucumber')
let { driver } = require('../support/web_driver')
let { By } = require('selenium-webdriver')
let assert = require('assert')
Given(/^open url "([^"]*)"$/, function (arg1) {
    return driver.get(arg1);
});
Then(/^I click the =$/, function () {
    return driver.findElement({ linkText: '=' }).click();
});
Then(/^I should  get the result "([^"]*)"$/, function (arg1) {
    driver.findElement({ id: 'calculator-result' }).getText().then(text => {
        return assert.deepEqual(text, arg1);
    });
});
Then(/^History panel should has "([^"]*)" text$/, function (arg1) {
    driver.findElement({ id: 'calc-history-list' }).getText().then(text => {
        return assert.deepEqual(text, arg1);
    });
});
When(/^I click the "([^"]*)"$/, function (arg1) {
    return driver.findElement({ linkText: arg1 }).click();
});

Then(/^History panel should be null$/, function () {
    return driver.findElement({ id: 'calc-history-list' }).getText().then(function (text) {
        return assert.deepEqual(text, '');
    });
});
When(/^I click (\d+) \+ (\d+)$/, function (arg1, arg2) {
    console.log(arg1, arg2)
    driver.findElement(By.css('[data-key="49"]')).click();
    driver.findElement(By.css('[data-constant="SUM"]')).click();
    return driver.findElement(By.css('[data-key="49"]')).click();
});
```

测试开发会用到自然语言和 JavaScript，自然语言用于描述测试用例，JavaScript 用来编写测试代码。两者之间通过一定的语法关联起来。如果跟前边比起来，可以感觉到似乎这是一种特殊的关键字驱动模式，将关键字驱动中的**关键字**封装成为了剧本语言，从而可以把用户或者客户真正的通过 Feature 文件联系在一起了。各个角色，包括 QA、BA、开发、测试、客户、用户都可以通过这一媒介，将测试用例直接转化为自动化测试脚本。

同时，再扩展一步，更可以作为客户、需求与开发之间的沟通桥梁，从行为驱动测试框架发展成为行为驱动开发，从而达到更高效的沟通。这样，无论谁都可以先编写测试剧本，然后指引开发实现，最后再通过剧本执行自动化验证，这样的好处是：

- 用户故事与用例一体化，减少浪费
- 节省成本
- 减少中间的转达过程，需求更明确



### 总结

其实，三种驱动思想各有千秋，不存在谁好谁坏的分别，在不同的应用场景下，我们可以选择不同的驱动模式。数据驱动和关键字驱动作为架构设计的老牌劲旅，在我们设计测试框架和平台时会起到非常重要的作用，而一旦我们将自动化测试上升为一种新的软件工程实践，行为驱动这样特殊的关键字驱动模式又能够更好地为整个软件工程过程服务。

未来测试行业的弄潮儿们，你们可以从数据驱动开始尝试，不断优化完善自己的框架设计，最终全面掌握三种驱动模式。未来的测试领域，也许还有更多更新的设计模式在等着你发掘、创造，如果你有什么好的想法，欢迎跟大家一起讨论。

## **16 从脚本到框架： PAGE OBJECT模型与分层框架**

如果把搭建一套优秀的 UI 测试框架，比作我们的武功修炼的话，上一节中，我们已经开始从各门武功中选好了，自己想要使用的武器；然而无论我们是选择用刀还是用掌，除了武器外，还需要一套完整的武林秘籍，不管是选择 “降龙十八掌” 还是 “黯然销魂掌”，目标都是为了更好的武装自己。测试框架也是一样，不仅仅需要确定自己的架构体系，还需要完善框架的设计模式。



### 什么是设计模式？

可能测试的小伙伴们对设计模式不太了解，光听这个名词就觉得非常高大上，我在工作中听到这个词最多的地方都是在面试中。

那到底什么是设计模式呢？设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。

所以换句话来说，设计模式就是别人都在用，用了都说好的一套基础方案，毕竟相比起学习别人已经练成的降龙十八掌比自创一套武林绝学 “风落掌中宝” 要容易的多。

在研发领域里，早在 1995 年就由 “四人帮” 收录总结了 23 种设计模式。但是在测试领域，这样的概念随着测试框架的发展才不断被总结、披露出来。近几年来最火的一种测试框架设计模式就是：Page Object。



### PO 模式

所以的 PO 模式其实就是页面对象模式，就是呢我们对每一个页面创建一个类，并且在这个类里对当前页面的属性和操作来构建出一个模型。可以包含页面里按钮啊、输入框的一些属性，也包括点击、输入等一系列动作。比如我们来看这样一个登录页面类：

```python
from selenium import webdriver
from selenium.webdriver.common.by import By
from time import sleep

#创建基础类
class BasePage(object):
    #初始化
    def __init__(self, driver):
        self.base_url = 'https://XXXX.com/'
        self.driver = driver
        self.timeout = 30

#定义打开登录页面方法
def _open(self):
    url = self.base_url
    self.driver.get(url)
    self.driver.switch_to.frame('login_frame')  #切换到登录窗口的iframe

　　#定义定义open方法，调用_open()进行打开
    def open(self):
        self._open()

#定位方法封装
def find_element(self,*loc):
    return self.driver.find_element(*loc)

#创建LoginPage类
class LoginPage(BasePage):
    username_loc = (By.ID, "u")
    password_loc = (By.ID, "p")
    login_loc = (By.ID, "login_button")

#输入用户名
def type_username(self,username):
    self.find_element(*self.username_loc).clear()
    self.find_element(*self.username_loc).send_keys(username)

#输入密码
def type_password(self,password):
    self.find_element(*self.password_loc).send_keys(password)

#点击登录
def type_login(self):
    self.find_element(*self.login_loc).click()

#创建test_user_login()函数
def test_user_login(driver, username, password):
    """测试用户名/密码是否可以登录"""
    login_page = LoginPage(driver)
    login_page.open()
    login_page.type_username(username)
    login_page.type_password(password)
    login_page.type_login()

#创建main()函数
def main():
    driver = webdriver.Edge()
    username = '3494xxxxx'    
    password = 'kemixxxx'    
    test_user_login(driver, username, password)
    sleep(3)

driver.quit()

if __name__ == '__main__':
    main()
```

我们可以看出，整个登录页被我们的 Page 类切割成了多层，包括基础参数：URL、超时、driver 等。页面的元素属性：username、password 输入框和登录按钮，每个页面元素的操作以及整合出带有业务逻辑的登陆操作。而外部呢，也就是我们的 main 函数调用方法，则在更上层使用这个页面对象。

所以总结一下，PO 这种设计模式，就是把自动化测试代码以页面进行组织，将同一个页面上的所有信息，相关操作都放到一个类中；那么每一次测试用例的设计都是把各种页面上的操作进行，简单的调用和集合。如此一来，PO 模式的优势很明显：

- 当页面的元素、属性或者操作发生变化，只需要找到对应页面类中进行修改，维护更容易；
- 提高代码重用性，结构更加清晰。

当然还有一点优势，我隐去了：*在面试时对于 PO 模式的阐述能够为你的自动化经历加分*。为什么这么说呢？刚才的登陆界面很是简单，然而我们通过 PO 模式写了这么洋洋洒洒的一大段，ok，那么我们来试想一下这样一个场景：如果现在的页面中有 10 个、20 个甚至更多元素的时候，PO 模式该如何使用？

一套简单的操作，可能某个页面只需要一个点击事件就可以 hold 住的话，PO 模式会不会有浪费？一个基本的业务，如果横跨非常多的页面，又当如何？一个系统，比如电商网站，包含太多的页面，又该怎么组织？

在这些情况下，看起来清晰明了的 PO 模式会显得过于笨重，而且维护效果很难。我很多次在面试的时候，询问用 PO 模式期望撬开面试大门的同学，几乎成为了话题终结者。所以在我看来，虽然 PO 模 式看起来很高大上，但是和 JAVA 的很多设计模式类似，在实际工作中、大型项目中应用的并不广泛，即便硬要使用，也会发现效果与预期相差甚远。

PS：对于这样的热门思想，你当然可以不用它，但是不妨碍你认识了解甚至精通它。

那么，有没有更好的方式来针对上面的实际问题呢？



### 分层模式

这是我惯于采用的模式，被很多朋友和同学吐槽过：这也太简单、太 low 了吧。曾经有那么一段时间我也这么想，希望把这样的结构模式变得更加绚丽，赋予更突出的意义。直到有一天，和一个朋友聊到 EJB 的没落，为什么如此强大的应用规范，在几年之内就被 Hibernate、Spring 弯道超车呢？结论就是大道至简。越简单的架构设计，越容易理解的框架才能发挥出最大的威力。所以，我让框架回归了原来的样子：

![图片描述](http://img1.sycdn.imooc.com/5d89cdae0001f20807000371.jpg)
我们的封装方式不拘泥于页面，也不拘泥于项目，可以更加灵活的掌握。核心思想在于将公共业务模块和非业务方法底层分离封装，再把元素、数据参数、配置变量分别做为不同类型的数据提取，以最上层的方式进行调用。

其实思路上与 PO 模式也有异曲同工之处，然而具体实现上则大不相同。在这样的模式中，维护更加有针对性：基于页面元素调整就维护 Elment 层，基于业务操作修改则操作 Task 层，用例行为变化修改 TestCase 层，测试数据优化调整 Data 层，有的放矢的进行框架的维护。

当然，篇幅所限，我们不太可能在这样一篇文章里展开来说明每一层应该如何划分，但我相信，聪明的同学可以从这样的模式中 get 到一些，想要更深入了解的话，可以到[这里](https://coding.imooc.com/class/238.html)了解更细节的内容。



### 总结

设计模式就是再一次站在巨人的肩膀上，从前辈总结下来的成熟 “兵法” 中挑选符合你使用的场景。小时候看倚天屠龙记，印象最深的一段就是：

> *张无忌在殿上缓缓踱了一个圈子，沉思半晌，又缓缓踱了半个圈子，抬起头来，满脸喜色，叫道：“这我可全忘了，忘得干干净净的了。” 张三丰道：“不坏，不坏！忘得真快，你这就请八臂神剑指教罢！”*

这是张三丰教张无忌太极剑的场景。为什么要全都忘记，是因为金庸武侠中剑法的最高境界就是 “无招胜有招”。所以，在我看来，设计测试框架最顶尖的状态，也是忘掉自己所学习的设计模式。这样的忘掉不是要你不学不看，而是在学习了已有的设计模式设计以后，将它们都放在自己的思维中，碰到不同的场景和问题，能够因势利导，选择不同的 “打法”，甚至能够在实践中不断磨合改进，创造出属于自己的 “巅峰绝学”。当然，一定不要忘记大功告成的那一天通知我！

## **17 框架提升指南：从持续集成到测试数据收集**

估计大家也看出文弱如我居然还是半个武侠迷，其实远不止，年轻时候（PS：现在也不算老，必须不算！）我也是泡在天涯、起点上从武侠追到仙侠再追到玄幻的 “书瘾” 少年，甚至还曾经尝试去写了一部玄幻的网文，成了一个不知名的 “小扑街”。

不管是在武侠还是在玄幻里，主角们除了得到了非常牛的武功秘籍和心法之外，还需要找到一个非常适合自己的外部环境来修炼，这样方能一日千里。我们的测试框架修炼之路也是如此；除了驱动架构思想和设计模式以外，还需要一个完美的外部环境。

在去构建这样一个外部环境之前，我们先回到最初的问题：我们做自动化的初心是什么？难道是为了秀出高大上的设计思路？

答案当然是否定的，尽管一个高端大气上档次的框架设计能够让我们更加自豪，然而从根本上说，自动化测试终究是为了测试而服务的，它不仅仅是让我们能编码、能有一个高端的工具来做测试，更重要的是为了提升我们的测试效率。一个好的自动化测试框架，不仅仅要能让用户方便使用，还需要符合一些基本原则。

这些原则包括：可复用、易维护、定时处理、持续集成、可调试、测试结果自动通知等等。框架的概念是一系列的被事先定义好的标准和规范。在自动化测试中我们经常提到的对测试需求的解析、脚本设计、测试执行、测试报告、维护管理等等，通过框架将它们串联并封装起来，从而使框架的终端用户能够更方便地使用。

我们可能已经应用了或数据或关键字甚至是行为驱动的架构，也已经选择了分层的设计模式，这当然帮助我们的框架解决了很多问题：我们的自动化测试脚本可以通过公共用例层得以复用，而更多的维护工作也通过不同分层的设计模式将其维护的难度降到了最低，可以说在我们的代码层面上把能够做的做到了最好，所以，我习惯于把在代码内的分层和驱动统称为自动化测试框架的内部架构。

有内自然就有外，所以我们还设计了 “外部框架”。所谓的外部框架，其实就是以 Selenium 为核心，辅以外部第三方框架和工具，用以实现持续集成、自动部署、脚本执行、远程调用、报告优化、邮件发送等功能的框架结构。

**持续集成：Jenkins**

我们就以 JAVA 语言为例，抛砖引玉来聊一聊可以选用的外部框架。目前最流行的持续集成框架毫无疑问就是 Jenkins。当然，Jenkins 只是一个包含丰富插件的平台，持续集成则是一种软件开发实践，更重要的在于思想而不仅仅是工具的使用，持续集成让团队开发成员经常集成他们的代码，而对于测试人员来说，持续集成可以赋予我们两方面的含义：

1. 当我们自动化代码有变更时持续集成，验证自动化测试代码的有效性和结果的正确性；
2. 当研发的代码有更新部署时，我们的自动化测试代码自动执行，重复验证最新版本的测试环境是否符合预期。

持续集成也是在不断进化的，随着 Devops 的发展、随着 Docker 技术的不断应用，Jenkins X 也应运而生，它是个高度集成化的 CI（持续集成）/CD (持续交付) 平台，基于 Jenkins 和 Kubernetes 实现，目的在解决微服务体系架构下的云原生应用的持续交付的问题，简化整个云原生应用的开发、运行和部署过程。

**自动化生命周期建设：MAVEN**

Maven 是什么？了解的同学一定会说，它是一个非常全面和主流的项目管理的综合工具。简单来说，Maven 其实现阶段非常大的程度上简化和标准化了项目建设过程，可以处理打包、编译、依赖管理、团队协作等等。对于我们测试来说，Maven 串联了我们自动化生命周期的各个部分：

- Maven+TestNG 来执行底层的 Selenium 脚本；
- Maven+ReportNG 生成可读性更强的测试报告；
- Maven+JavaMail 来将测试结果作为 HTML 邮件发送给相关人员。

到这里为止，我们构建了一套以 Sejenium 为核心，Jenkins + Maven + Selenium + ReportNG + JavaMail 的集持续集成、自动执行、定时任务、测试结果、邮件发送多位一体的自动化测试底层框架。那么我们还缺少什么呢？

**分布式测试：GRID**

有时候我们会有大量的测试用例需要执行，又或者我们需要针对不同的浏览器、同一浏览器的多个版本进行兼容性测试，再或者我们希望能够尽量减少测试套件运行的时间，这时候我们就需要支付分布式测试，让我们的自动化测试脚本可以在多套环境中、多台测试机器中同步并行执行。

最早的时候，我们的并行模式可以完全通过 TCP 传输回放的模式来进行，但是 Selenium 提供了我们更好的解决方案 ——Selenium Grid。Grid 提供的所谓的分布式结构其实就是由一个主节点（hub）和若干个代理节点（node）组成。Hub 用来管理各子节点的信息和状态，并且通过精准请求专访的方式，然后把请求的命令分派给代理节点来执行。

**测试大数据统计：EXTENTX**

有时候会不会觉得 ReportNG 的测试结果仍然不够简明漂亮？有时候我们需要手动去记录每次自动化执行成功率等数据方便进行统计？针对于这样的思维，所以我们有了一套基于 Sails+MongoDB 的自动化测试结果统计工具，它可以非常便捷的集成到 TestNG 中，将测试结果通过监听的方式发送到我们的 MongoDB 中，并通过 Sails 前端清晰完美的呈现出来。
![图片描述](http://img.mukewang.com/5d89db030001fa2316000849.jpg)
是不是看上去优美了很多，更便于我们的数据归集和统计。呃，作为 ExtentX 的忠实用户，我很伤心地通知大家：ExtentX 已经被废弃。目前有更新的报表服务产生 -- Klov ，提供了对数据的详细分析，能够利用历史数据分析接口测试的执行情况，总体来说样式上的改变并不太大，所以同学们可以使用最新的 Klov Server。PS：请原谅一个 “老者” 仍然在小标题里用 ExtentX 来称呼它。

相信到了这里，一套比较完整的、功能非常强大的 UI 自动化测试框架就在我们的手中诞生了。还是之前曾经说过的，这样一套思路仅仅，是我自己对于自动化测试的认识和摸索，在这里抛砖引玉带领大家一起看看更好的自动化世界，也许今天，也许明天，你或者他，可以带我们走入一个更优美、更易用的自动化测试框架。最后，大家可以一起思考一个问题，自动化测试框架中除了我们提到的持续集成、生命周期建设、分布式管理、大数据统计，还可以赋予什么样更有用的功能呢？



## **18 平台设计深入讨论：技术的进步还是能力的倒退？**

### 为什么要搭建自动化测试平台？

在公司里，如果我们可以根据自己的实际情况，搭建出一套实用的自动化测试框架，并且将之付诸于实际使用的话，才可以说我们已经践行了自动化测试。而我在实际工作中发现：在同一个公司内的不同项目组，由于大家对技术的掌握不同、业务的需求度和封装方式不同，所以出现了在同一个公司内，并行多套自动化测试框架的情况。A 部门擅长 Java，B 部门擅长 Python，我想搞个通用的数据驱动，他想做一个新颖的行为驱动，于是框架难以统一，总是在重复造轮子。

这是对于测试技术比较强的公司存在的烦恼，同样，在我参与过自动化测试建设的很多中小公司中，又存在另外一个极端：由于长期进行的都是纯功能测试，测试团队完全没有代码经验，无论自动化测试框架设计的再容易、再简单，也仍然还是需要测试人员自己去编写一部分代码的。更有不少公司由于人员流动性很强，所以希望能够尽量降低自动化测试的学习成本，能够达到 “来之能用” 的程度。

所以，搭建一个统一的自动化测试平台就可以解决这样的问题，这也是很多公司老板最想要的，对于测试人员来说，不需要再去写代码，直接在一个界面上操作选择一下，输入一点参数，就能达到自动化测试的目的了。而且大家的风格比较统一，自动化脚本呢又不会因为人员变更而丢失，更加便于集中维护了。

于是，最近几年里，我听到的、见到的开始搭建自动化平台的公司，如雨后春笋般不断的出现。但是一个自动化测试平台的初衷，是不是仅仅像上边提到的就够了？



### 自动化测试平台的目标

可以无需代码基础，直接上手自动化，这当然是最基本的目标了。那么除此之外呢？

我们很多时候，还希望自动化测试平台能够解决更多的事情，从接口、UI 再到 APP 自动化可以全面覆盖，通过平台建设完成更多的测试任务，得到更高的测试覆盖率，才能从量变达到质变，让自动化测试更有效地发挥威力。

除了想让平台 “多而好”，我们还希望它运行的速度快。无人值守的自动化测试当然好，但是很多时候，持续集成往往是在工作时间发生，如果能够更快捷的完全冒烟，甚至是系统自动化测试，那自然是极好的。

最后的一点，是我自己的有感而发。自动化测试的确可以提升一部分我们的效率，但是并不是无止境的，我在一家公司中看到整个自动化测试集群达到了 60 台服务器之巨大，规模之大令人叹为观止，其中每台都有非常具体细节的用途。

我仔细跟他们算了一笔账，这 60 台云上服务器每月成本大概在 20w 左右，而经过数据分析，实际上的使用率每台不足 5%，在这里耗费了大量的资源。

所以 “省” 是自动化测试平台的另一个重要目标，硬件软件资源是节约成本的一方面，用最小的代价做最多的事情，所以规划很重要。另外，人力资源也是成本的一部分，所以平台的可用性越高，用户体验越友好，人力成本呢就越低。

说到这里，居然也恰好，符合了我们 "建设社会主义" 的总路线：“多快好省” 的方针 O (∩_∩) O。



### 自动化测试平台的建设思路

我曾经花了不短的时间，研究了目前市面上做的比较好的自动化测试平台，从腾讯的 UTP、阿里的云效、51testing 的 TestWriter 到近几年开源的 AutoLink、LuckyFrame 再到我自己编写的自动化测试平台，所有这些好的平台的架构（王婆：呸，还把自己放进去，不要脸）都有共通之处：

- 整体上的框架思路都分为 Web 端和后台服务端
- 无一例外采用了关键字驱动的思想
- Web 端与服务端分离，Web 端负责把关键字存储到数据库中，服务端负责关键字的解析和自动化的执行
- 服务端的底层大多通过 Selenium、RobotFrame Work 来支持

这就是自动化测试平台的整体建设思路。更细节的话，我们仍可以通过腾讯 UTP 的架构设计略窥一二：

![图片描述](http://img.mukewang.com/5d8dc0c7000178d407370635.png)
总结来说是，以关键字驱动为核心，坚持前后端分离、多模块、大量三方架构服务集成、测试过程结果监控为基本原则的 “测试平台” 初级阶段基本路线。



### 技术的进步还是能力的倒退？

聊了这么多，一直在说我们应该去如何建设自动化测试平台，我想在这里问大家这样一个问题：建设测试平台到底是不是一件好事？

**如果我现在是个老板**，那么我会觉得一套完善的测试平台体系是非常必要的，能够大大节约我的成本，随便找一些应届毕业的小同学，就可以上手做自动化测试了，非常便捷。

**如果我现在是一名测试平台的开发者**，我会觉得非常有挑战，能够很大程度上锻炼甚至提升我自己技术上的能力，给我一个机会探索自动化测试未知的世界，在这个过程中，我会觉得自己在不断进步和成长。

**如果我现在是一名多年的功能测试人员**，我会觉得平台的思路很好，能够减轻自己一部分负担，让自己更专注在探索性测试和错误推测测试中去。

**如果我现在是一个刚出校园的 “小菜鸟”**，我会觉得自动化测试平台并不能让我收获很多，因为我看不到代码也学不到自动化测试的思想，平台对我来说仅仅是一种特殊的进行功能测试的工具，几乎没有太大的学习价值，毕竟，自动化平台没有也很难有一统市场的平台出现。长此以往使用下去，反而会让自己的测试能力和代码能力都倒退一点点。

从不同人不同角度来看，对于自动化平台也会产生不同的理解。所以，对于平台来说，认真对待、无需迷信就是最好的态度。自动化测试平台是把双刃剑，既可以培养优秀的测试开发储备人才，又可以节约成本；同样，也会舍弃掉未来很多 “新人” 的代码探究之路和发展潜力。那么，尽量尝试着去建设好它，使用好它，让它给你的测试之路提供更多的正能量。

那么，你是怎么看的呢？

# **第5章 接口测试**

## **19 从零开始了解接口测试与工具**

前边我们主要介绍了 UI 自动化测试，我在刚刚工作的时候，只要提到自动化测试就是指 UI 自动化。但是在经过了实践之后，我们发现 UI 自动化测试，其实并没有我们想象得那么美好：

- 项目的迭代修改，或者部分功能增强很容易毁掉我们的测试脚本，让我们需要大面积修改；
- 本身基于 UI 的端到端测试，经常出现某些不可预期的问题，导致我们发现脚本运行失败，需要大量时间排查，并且很多时候不是源于程序的问题，而是脚本的某些细节处理和网络原因；
- 无论是用框架或者平台，脚本的编写成本还是比较高的。

所以，基于 UI 的自动化测试，虽然有着这样、那样的优点，但是始终存在着脆弱、**编写成本高**、**失败概率大**等缺陷。Martin Fowler 在非常著名的一篇文章《Test Pyramid》（测试金字塔）中，从敏捷测试的角度，非常详细的描述了测试的金字塔结构。

![图片描述](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)

金字塔模型告诉我们什么呢？首先，在金字塔这样的自底向上结构中，**越靠近底层，测试越稳定**，所以我们投入的也应该越高；同样的，**越是底层，发现问题越早、越高效，修改和维护的成本也就越低**。

所以在金字塔最底层的是**单元测试**，单元测试一般情况下，是由白盒测试工程师，或者更多的由开发人员本人来完成的。单元测试是对于最底层的类啊、方法啊进行的测试，所以能够提供最快的反馈。所以要把单元测试做到最重。

接下来是**接口测试**，Martin Fowler 认为需要引用面向应用程序服务层的中间层测试，称之为 “SubcutaneousTest”（皮下测试）。对于我们来说，皮下测试更多的就是 **API 接口层测试**。API 测试是底层代码到最上层 UI 实现的桥梁，是对外暴露的接口和服务。

最上层就是 UI 自动化测试，是对于用户来说模拟度最高的测试，我们前边也介绍了很多，由于众所周知的缺点，我们把它放在最上层，做是一定要做的，但是在敏捷中重量级要放轻。

OK，这是敏捷时代对于软件测试认识的第一步，据我的了解，很多公司连这一步还没有走出来，持续停留在把重心放到 UI 自动化的阶段。

### 互联网的蛋型模型

我和我的很多小伙伴们都在互联网公司，每次沟通都在聊关于 “TDD” 的进展。虽然用单元测试驱动开发是很好的思想，但是在互联网公司里，无论开发还是测试，都不可能有时间去做全面的单元测试。所以金字塔最底层的 UNIT 大多时候无法保障。

随着互联网微服务架构的流行、前后端分离的实现，我们会发现在测试过程中，即使前端 UI 测试发现了问题，也需要排查具体是哪一层面上出现的 BUG，所以其实微服务架构下，对测试的要求会变得更高。

而所谓的微服务，本质上呢，就是多个服务之间的接口调用，所以把 UI 测试和接口测试分离也成为了测试的重中之重。加上接口测试稳定性高、开发效率高、执行周期短、改动较少的特点，所以在互联网时代，大多数采用的方式是：**轻 UI 自动化、重接口自动化、部分单元测试覆盖的策略**，也就是小标题中介绍的**蛋型模型**。

![图片描述](http://img1.sycdn.imooc.com/5d906d210001ef9404420497.jpg)
PS：图…… 画得的确是一本正经的丑，不过不要 Care 这些细节哈。这样的蛋型结构是基于接口测试的高投资回报比决定的。这时候，有同学又要 diss 风落了：你已经讲了好久接口测试了，到底接口测试是干嘛的？

### 什么是接口测试？

如果你去百度这个概念，那么几乎 100% 会得到这样的结果：

> *接口测试是测试系统组件间接口的一种测试。接口测试主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。测试的重点是要检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等。*

我们换个方式理解：比如我们有个很喜欢玩的小游戏，这个游戏呢，需要我们拿手机登录一个 APP 玩，可是我们是爱岗敬业的好同学啊，工作时间怎么能敢明目张胆的打开手机玩游戏，那怎么办呢？聪明的我们想了个办法，既然游戏是从 APP 里点击触发了很多请求，比如造建筑啊、收金币啊等等，我们为啥不能跳过这个 APP 直接触发呢？这样的思考方式就造就了很多外挂的诞生……

接口测试就是这样，我们直接跳过 UI 层面的操作，直接访问下游系统，给我们暴露出来的服务接口，这个时候我们模仿的就不是客户啦，而是我们的前端，这就是接口测试的概念。

我们同样可以像功能测试一样，按照边界值、等价类等等的设计方法来设计接口的输入参数，同时根据接口的最终返回来进行返回的判断，整个过程仍然是完整的功能测试，只是绕过了前端的解析过程。

> 基于前边说过的接口测试的特点（稳定性高、开发效率高、执行周期短、改动较少），所以使用接口测试来完成持续集成、SmokeTest 等效率是非常高的。
>
> 同时，基于我自己的经验，我觉得接口测试也远远比 UI 自动化测试更简单。

### 怎么做接口测试

就像我们前边说的，接口测试很简单，它忽略了前端，也会忽略很多的业务属性交互，更核心的点就在于三个地方：

1. 接口的入参数据；
2. 模拟接口测试的工具；
3. 验证接口的出参返回。

比如我们有一个这样的 HTTP 接口：

```
https://api.jisuapi.com/areacode/city2code?appkey=bc1147aa2662e4b5&city=XX
```

这个 API 的接口功能非常简单：就是基于城市来查一下城市对应的区号。比如说我的请求是 “city = 北京”，返回的结果就是：

```
{"status":0,"msg":"ok","result":[{"province":"北京","city":"","town":"","areacode":"010"}]}
```

这样的接口就是一个 Restful 风格的 API，最简单的测试方式就是直接把请求扔进浏览器里边去就好了：

![图片描述](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)
我们可以根据请求所对应的参数进行修改和调整，修改我们的入参 city，按照功能测试的方式可以有边界值、等价类等等，再这里就不一一举例分析了。

就这么简单就可以了么？答案当然是否定的，我们对 HTTP 请求都有一定的了解，这是一个 GET 请求，所以我们可以很容易的把它扔进浏览器搞定，那么如果是一个 POST 请求呢？或者我们有更多的要求和参数呢？

### 接口测试的工具

HTTP 请求比较常用的工具有很多，例如：POSTMAN、JMETER、SOAPUI 甚至是 LoadRunner 等工具都可以帮助我们进行接口测试的开发，而且不需要我们有太多的代码基础就可以实现。我相信大家可以飞快地通过 GOOGLE 获得这些工具的用法，所以我不在这里赘述了，按照我的老习惯，咱们用其中之一抛砖引玉一下。

![图片描述](http://img1.sycdn.imooc.com/5d906eb9000199dc05000293.jpg)
Postman 应该就是目前最常用的 HTTP 模拟请求的工具了，我最初使用这个工具的时候还只是一个 Chrome 插件，现在已经是一个完全独立的应用了。我们简单聊一下如何使用它来完成上边请求的接口测试：

1. 选择创建一个新的 Request：

![图片描述](http://img1.sycdn.imooc.com/5d906ef40001488613600362.jpg)
\2. 接下来选择适合的请求方法，输入对应的 URL 地址和参数：

![图片描述](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)
\3. 点击 “Send”：

![图片描述](http://img1.sycdn.imooc.com/5d906f5000018ef313500505.jpg)
这样我们就完成了一次最简单的调用，可以看到返回的 Response 结果展示在下方，并且不需要任何其它格式转换器，可以直接在 Postman 中将结果格式转换为 XML 或者 JSON：
![图片描述](http://img1.sycdn.imooc.com/5d906f740001ca3205390234.jpg)
除了简单的调用，Postman 还可以帮助我们去完成更复杂的结果验证、用例规划等等，接下来我们可以牛刀小试一下。

### 复杂场景的应用

当然，很多情况下由于复杂的业务场景，我们在进行接口测试的时候，不仅仅是单一的接口调用，而是一系列的接口，而且会存在请求 B 需要使用前一个请求 A 中返回的结果的情况，这种情况下我们需要解决的问题，就是如何将多个请求关联起来。

所以我们可以增加一个场景，刚刚我们是通过城市查出了区号，接下来我们再根据查询的结果反查一下城市和地区，接口是这样的：

```
<https://api.jisuapi.com/areacode/query?appkey=bc1147aa2662e4b5&areacode=XXX>
```

那我们在第一个接口的基础上，增加环境变量：

![图片描述](http://img1.sycdn.imooc.com/5d906fab00017cbf13510604.jpg)
在请求 A 中的 Tests 界面进行后续逻辑，将参数存入环境变量中：

![图片描述](http://img1.sycdn.imooc.com/5d906fe40001aebb13280571.jpg)
那么这个变量就可以放到下一个请求中应用了：

![图片描述](http://img1.sycdn.imooc.com/5d906ffc0001d25613240500.jpg)
接下来我们将完整的 collection 执行就可以看到参数传递的结果啦：

![图片描述](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)

![图片描述](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)

那么举一反三，更复杂的场景都可以通过 Postman 的代码编写搞定了。同样的，前边提到的结果验证等也可以通过这里编码的形式完成，自然不用多说。Postman 还有更多的功能等待你去探索。

### 总结

我们搞清楚了几件事：

1. 敏捷测试的金字塔模型和蛋型模型让我们能够合理有计划的规划整体测试架构；
2. 接口测试是什么，我们为什么要做接口测试以及要怎么做接口测试；
3. 接下来我们通过一个简单的查询区号的接口，了解了 API 请求的样子以及简单测试工具 Postman 的使用；
4. 复杂场景下的参数传递如何使用。

所以，接口测试真的很简单，并没有大家想的那么 “高大上” 和复杂。在互联网公司中，接口测试越来越重要，需要大家牢牢掌握。最后，大家可以用 Postman 或其他工具尝试开始接口自动化测试，也欢迎大家把感想发出来一起讨论。

## **20 如何用代码框架实现接口测试？**

在我打过交道的同学朋友中，使用工具来完成接口测试的几乎占到了八成以上，我们前边也看到了诸如 Postman、Jmeter 等工具在接口测试上有着非常强大的能力，但是实际工作中我们会发现，是所谓 “成也萧何败也萧何”，使用这样界面化的工具在维护大量测试案例或者想要执行持续集成又或者希望编辑更多测试场景的时候，界面化又成为了测试的瓶颈，所以我们需要一套更优秀一点的接口测试框架。

其实相关的接口测试框架有很多，不过呢，在这篇文章里我们不谈某一个接口测试框架应该怎么用，而是通过我自己的经历来看看接口自动化测试框架的发展史。



### 一代：基于 Postman 的扩展框架

鉴于最早的时候开始进行接口测试一直在使用的工具都是 Postman，觉得这个工具真的是又便捷又好用，所以在最早想要扩展出一套接口测试框架往往考虑的问题是：能不能在现有的基础上加一点点 “佐料”？

于是便有了 Jenkins+Newman+Postman 这样的一套接口自动化框架。毫无疑问 Jenkins 负责的是持续集成，而 Newman 则是作为 Postman 的命令行集合运行器，可以说 Newman 是完全为了 Postman 而开发的，所以兼容性、可扩展性都是非常 OK 的，同时也具有比较好的文件上传、测试结果展示的功能，可以算得上是开始进行接口框架建设的神器。

这样的一套框架的确在前期解决了我们很多问题，毕竟很多接口脚本就是一直写在 Postman 里边的，但是当我们的接口复杂度不断增大、希望实现的功能越来越多的时候，Postman 这样非开源工具性产品就展现出了它的不足：很难扩展插件、无法与数据库配合、校验方式也比较死板、接口变动修改起来呢也很麻烦。

Postman 天然的封装让我们可以很轻松的进入接口测试，但是不开放的属性就也是让我们为之头疼。



### 一代 PLUS：基于 Jmeter 的扩展框架

提前说明一点，这里边跟大家聊一下 Jmeter 的接口测试框架，并非是基于 Postman 的升级，仅仅是以我个人经历的时间线为准，所以我的标题里加上了 **PLUS**。

这是由于一个比较特殊的项目，项目团队呢一直都在用 Jmeter 进行接口测试，等到我进入项目中已经使用 Jmeter 编写了超过 2000 的测试用例，所以做任何架构和工具上的调整都成为了不可能，唯一我能做的就是基于 Jmeter 之上的封装。唯一值得开心的事情是相比较 Postman 来说，Jmeter 是开源的，这样集成和修改上更容易一些。

所以由此以 Jmeter 为核心构建了 Jenkins+Maven+Jmeter 的简单结构化框架，复用 Jmeter 自身的测试结果来辅助实现。这也实实在在解决了当时 Jmeter 脚本执行的需求，但是尽管 Jmeter 的接口测试封装设计思路非常好，但是它的 UI 设计和实现逻辑实现的实在太复杂，为了通用也做了很多过度设计，所以操作、设计、维护接口上都不是太方便。

在当时我就想到，既然像 Jmeter 的 if 控制器等都已经细节化到这个程度了，我们何不通过代码来实现呢？这个时候我已经搭建了前面谈过了 Web 自动化测试框架，所以在这个基础上，进行了进一步的改进，加入了接口测试的内容。



### 二代：代码实现接口自动化测试框架

让我们一起回忆一下前边介绍过的 UI 自动化测试框架：

**Jenkins + Maven + TestNG+ Selenium + ReportNG + JAVAMAIL+ ExtentX**

所以这里边我们可以做一个简单的改造，讲 UI 的 Selenium 替换为 API 测试的依赖。那我们在 JAVA 里，主要进行接口测试的类为 HTTPClient 或者 URLConnection，于是这个框架就改造成了

**Jenkins + Maven + TestNG + HTTPClient/URLConnection + ReportNG + JAVAMAIL+ ExtentX**

尽管看起来框架的改造并不太大，然而实际上思路上的变化还是有的，我们把框架定位成为：

- 数据驱动设计，无需编写代码实现接口自动化
- 自动化测试用例完全用数据文件编写，简单易用高效

我们来看看这样一套框架的整体架构设计思路：

![图片描述](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)
这就是很多公司内部应用的接口自动化测试框架模式，相对比较成熟，当然，针对不同的公司业务，会有不同的业务上下文和业务属性，所以在这个比较成熟的测试框架基础之上来封装属于自己公司的接口测试框架，让接口测试更加灵活和适配。

我在慕课上也非常详细了分享过这套 UI 框架的代码思路，对于接口也需要一定的修改，然而涉及代码的讲解，可能不是一篇文章可以快速讲清楚的，所以延续着本专栏的模式，更多还是给大家这样的指引。如果有同学说：风落，我不想用 JAVA 啊，只会 PYTHON 怎么办？其实架构思想是不变的，只是组件上会发生一些变化，将上述的核心组件变为 Unittest+Requests，有兴趣的同学可以研究一下哈。



### 三代：开源框架平台的利用

能够自主搭建一套框架当然是很好的，但是一套优秀的框架，从诞生到改进、完善还有很长的路要走，所以搭建框架并不是 “来之能战” 的，最近几年开源的优秀接口框架非常多，也可以利用这样的开源框架进行搭建、改进甚至二次开发，避免重复造轮子，也成功借鉴了前人的经验，同时也可以对自己搭建框架有更强的指导意义，更可以取长补短。



#### HTTPRUNNER

这是一个非常简洁的 Python 接口自动化测试框架，易用性非常高，用例维护主要是基于 `YAML/JSON` 脚本，不仅可以实现接口自动化测试、还包含性能测试、线上监控等多种测试需求。给大家一个官方传送门：

在我接触过的接口框架中，HttpRunner 是最容易上手的，二次开发也比较容易。



#### Rest-Assured

如果要我在所有接触过的接口测试框架中只能选择一个的话，那么 Rest-Assured 一定是我的不二之选。由于越来越多的 Web 应用转向了 RESTful 的架构，很多产品和应用暴露给用户的往往就是一组 REST API。所以针对于 REST API 测试的框架也应运而生，它可以直接编写代码向服务器端发起 HTTP 请求，并验证返回结果；它的语法非常简洁，是一种专为测试 REST API 而设计的 DSL。使用 Rest-Assured 测试 REST API，就和真正的用户使用 REST API 一样，只不过 Rest-Assured 让这一切变得自动化了。直接上传送门：

之所以推崇这样一个框架，主要在于其支持的功能非常完整，几乎可以满足我们对于接口测试 90% 以上的需求。在我自己设计框架的过程中，有不少的功能也借鉴了 Rest-Assured 框架的理念。

有同学要说了：不是说不要重复造轮子么，风落你打自己脸啊！！NoNoNo，作为一名程序猿，就是喜欢重复造轮子，这样才能提高我的代码能力，当然，如果要造，一定要造一个比它更好用更适合你的轮子 O (∩_∩) O



#### 平台

更有一些界面管理化的平台可以支持我们进行更好更容易的接口自动化实施，更进一步减少了对于代码编写的需求。例如前边聊过的开源的 AutoLink、LuckyFrame 都集成了接口测试，同样还有针对于接口测试更专业化的 YApi ，思路上与我们前边聊到的自动化平台建设并无太大的不同。



### 不是结束的结束

接口测试当然越来越重要，所以未来也许还会有四代、五代，也可能会融入人工智能甚至是我们现在看来还不能想象到的技术。无论你是开始基于工具来扩展一套框架，或者是基于开源的框架平台进行应用，又或者是开始自己编写一套适合于自己的新 “轮子”，你都要先这么问自己：

- 我的框架目的是什么？
- 我或者用户想要怎么使用？
- 这是不是最适合我的改进？

然后再动手，自由发挥。没有哪种是最好的解决方案，只有最适合你的方式，所以我在这里并没有指给你哪个最好，也没有给你分析框架应该怎么去写、开源框架 ABCD 应该如何去用，而是展示给大家要设计一个框架，应该怎么去思考。也许今天在看这篇文章的时候你还没有完全理解，没关系，做下去，等到困惑的时候再回来看看，想想，希望能对你有所帮助。

# **第6章 移动测试**

## **21 求同存异：论移动测试与传统测试**

随着手机的重度使用，近几年来再谈到测试，APP 测试是不可或缺的一环，尤其是互联网行业，会把 60% 到 70% 的精力投入到 APP 的研发测试工作中去，所以在面试、在入职工作的过程中，每个人都面临着移动 APP 带来的挑战。

包括我自己在内，在面试过程中也会很多嘴的问一句：有没有做过 APP 测试？觉得 APP 测试跟传统我们在做测试的时候有什么相同和不同之处呢？尽管我们所要做的事情大多数时候与 APP 并无关联，但是仍然很希望我的面试者可以有这方面的思考和认识。

如果你遇到像我这样的面试官问到了这样的问题，你该如何作答呢？

对于这个问题千万不要张嘴就回答：没做过 APP 测试相关的，不太清楚。俗话说 “没吃过猪肉还没见过猪跑么”，作为每天手机不离手的一份子，如果直接说不清楚不会就太差强人意了。

所以先说一下 APP 测试与传统测试的相同点：

1. 测试的流程相同：其实不仅仅是测试流程，整个项目流程也大体一致，从需求到设计再到测试执行，其中的测试活动是没有区别的。
2. 从测试类型来说，APP 测试与传统测试也都需要进行功能测试、性能测试、安全测试、验收测试等各个阶段。
3. 在功能测试设计上也没有太大的变化，我们同样需要通过边界值、等价类、判定表、错误推测等各种方法来设计测试用例。

当然，APP 测试在细节上还是要比传统测试复杂一些的，我们一起来从几个方面看看它与传统测试到底有哪些不同：



### 1. 安装、卸载与升级更新测试

这是我们在传统的 WEB 测试中所不具备的场景，也是移动测试的特殊所在。测试一个 APP 它的安装卸载和更新过程，最基本就要考虑不同的操作系统、不同的系统版本、不同的厂商 UI 的修改以及不同的应用商店带来的影响。

先来说说安装过程，由于移动应用的属性，我们要考虑安装过程中是否能取消；如果过程中出现意外，比如死机了、没电了、自动重启了或者断网了怎么办；再有安装空间不足了会怎样等等。

同样的，升级过程也是一样要考虑到，是否强制升级；新老版本是否兼容；升级过程中意外情况是否正常回滚；升级过程用户的数据、状态的保留；跨版本更新处理等。

相对而言，卸载还是更简单一些的，只是包含卸载结果和工程的意外处理。当然，作为一个手机重度用户我们知道，APP 删除仍然会有部分数据留存，这也是我们要测试的一部分。



### 2. 耗电量和发热测试

我们在使用电脑的时候往往不 care 电量的问题，但是对于移动 APP 来说，耗电量也是决定性的因素。我自己使用的华为手机一旦出现某应用耗电量过大的情况，就会自动给予一个提醒，那么只要不是我自己的重度应用或者有可以替代的应用，我一定会考虑把它卸载。发热也是一样，很多时候这是跟耗电同时发生的。

所以，我们在测试的过程中要额外考虑到 APP 正常运行频繁操作、APP 运行无操作和 APP 后台运行三种情况下耗电量情况。



### 3. 流量测试

其实曾经的我们对于流量的关注更甚于耗电量之上，随着流量费用的降低和无限流量套餐的普及，流量的耗费已经不再是决定性的因素。但是作为 APP 测试而言，我们仍然需要考虑，不应让自己的 APP 产生过多的流量，增加用户有可能存在的流量费用。

通常情况下测试的工具可以 Android 系统的 adb 和 IOS 系统的 Xcode 轻松分析监控，但是监控数据不是目的，我们的目的在于怎样减少流量。



### 4. 兼容性测试

WEB 端测试的时候也需要进行兼容性测试，但是关注的细节不太一样，对于 WEB 来说，最重要的兼容性就是浏览器的兼容，而 APP，要综合考虑到不同操作系统、不同屏幕大小、不同语言设置、不同网络连接、不同主流机型上的兼容性，甚至还要考虑在同一个设备上与其他主流 APP 的兼容性。比如我们开发一款游戏 APP，如果它跟微信、支付宝不兼容，那么想来用户一定是卸载你的 APP。



### 5. 弱网测试

与 WEB 应用更大不同的地方在于移动应用的用户使用 app 产品的过程中，不可能永远都处在 WIFI 满格的情况下。在地铁里、公交上，甚至是电梯、车库、隧道等等的场景里，我们的 APP 会如何表现，这同样是我们的关注的重点。所以，对于移动应用测试来说，要保证能够在网络环境不良的复杂网络环境下的质量。

目前来说主流的弱网测试工具主要有三种：

- Fiddler
- NEWT（Network Emulator for Windows Toolkit）
- ATC（Augmented Traffic Control）

Fiddler 使用简单，但是归根结底还是以抓包为主，不是专业弱网工具；所以我们在专业进行弱网测试的时候还是选择微软的 NEWT 或者 Facebook 的 ATC 更多一点，如果考虑到 ATC 开源的属性，可以把 ATC 当做首选。



### 6. 中断测试

中断测试是说我们在 APP 运行的过程中，由于其他事件影响或者中断了当前应用的相关测试。这是我觉得 APP 测试最异于传统测试的部分，也是我们在测试过程中最容易疏忽的部分。

比如我们都遇到过的情况：APP 正在用，突然来了个电话，或者突然又短信、微信或者其他 APP 的推送；又或者我们同时开着多个 APP，来回切换使用等等，这样的场景会很多，所以需要你在第一时间总结一下可能会出现的中断场景，可以维护到自己的常用测试集中，未来所有的 APP 测试都可以遵循同一套用例完成。



### 7. 手势测试

这是移动端的另一大特性，用户的手势操作需要在 APP 中进行或多或少的适配。



### 8. 权限测试

移动端的权限控制，比如 APP 是否可以使用摄像头、是否可以使用麦克风等对 APP 自身的影响、权限不足时的提示和引导等，这也是我们在 APP 测试时候要关注的方面。



### 9. 客户端性能

一般情况下，在 WEB 端我们更强调的是服务端性能，也就是接口的性能，然而到移动端时候，我们除了要考虑服务端的接口性能，还要同时考虑客户端的性能问题，这包括：CPU、内存、前边提过的耗电量和流量、FPS 等等。不然，一个明明很好的应用，如果只能在高端机上运行，一旦在低端、老手机上边安装就会卡到爆，那也是必然不行的。



### 10. 极限测试

这里我说的极限测试就是移动 APP 在一定临界状态下的行为，比如内存、系统存储占用超过 95%、切换飞行模式、时区切换、持久使用下的内存泄露等等。



### 11. 非功能测试

直到最后，我们才提到非功能测试，或者我们把它叫做用户体验测试。现在是一个 APP 泛滥的时代，没有哪个新的 APP 能够垄断某一个领域，只要一个新的思路登场，立刻出现很多竞品。所以，如果留住用户和吸引其他用户，就需要有更好的体验。用户体验测试在 APP 中显得尤为重要。

当然，体验这个东西是一定有很强烈的主观性的。我觉得好用的功能、我认为好看的建筑、我感觉帅气的打扮也许到了你眼中一无是处。所以一个优秀的用户体验测试，不仅仅要依靠测试人员自己的经验，还要考虑到，真实用户的反馈。这时候就产生了关于用户体验的 α 测试以及金丝雀发布等运维手段。

OK，聊了很多关于移动测试和传统测试的不同，本来是想更加短小精悍的给大家一个面试的答案，但是为了能让大家更好的理解，所以扩展开来聊了这么多。那么，就还请大家自己理解并总结一下，回到开篇的问题：

*如果你被问到：你觉得 APP 测试跟传统我们在做测试的时候有什么相同和不同之处，你该如何作答呢？*

## **22 探索移动自动化的世界**

每次谈起 APP 测试，很多小伙伴就不由自主的联想到 APP 自动化测试，似乎只有自动化测试，才是一个领域里最 “至高无上” 的技术巅峰。然而，我在开篇就要给大家一记重锤：对于 APP 测试来说，掌握上节内容中那些弱网、中断等测试手段和方法是相比自动化更重要的技能。

这也不是说我们不需要考虑自动化测试了，在 WEB、接口、APP 中我自己是最晚才接触 APP 自动化测试的，但是发现其实从自动化的角度上别无二致。自动化测试的原理和设计思路其实在前边 WEB 和接口已经聊过不少了，所以相信大家也理解了自动化的思想，唯一不明确的就是工具的选择。



### “风落” 的 APP 自动化之旅

接下来，又到了我 “现身说法” 的时候了。我刚接触 APP 自动化的时候，由于还在一家小公司，以探索尝试为主，所以先拿来 “祭旗” 的就是 Android APP（PS：穷苦的少年风落一直在用的就是 Android 手机，彼时也还没有获得持有 IPHONE 的老婆的青睐），本着以身正法的信念，加入了刚刚出现的 APP 自动化大军。

最早用的框架自然不用说，自然是 Google 最早提供的 **Instrumentaion** 自动化测试工具类，这算是在当时非常出色的一项技术，当你看到通过代码能够操作各种按键、屏幕操作、滚动等等事件的时候，成就感还是略微超过 WEB 自动化的。但是虽然我自己用起来感觉还可以，但是推广起来却很难，因为进行 Instrumentaion 脚本编写还是要对 Android 相关知识有不俗的了解，加上要配置一个 Android 的 xml 文件，实在是有些复杂。

于是需要探索更新的框架，浮出水面的就是 **Robotium** 和 **UIAutomator** 了。Robotium 虽然是基于 Instrumentation 开发的，但是对常用的操作进行了二次封装，所以脚本编写上也容易了很多，同时速度更快。但是同样的，仍然摆脱不了 Instrumentation 的一些劣势。相比之下 Google 提供的 UIAutomator 框架打破了之前大家自动化一定要 Instrumentation 的束缚，重新定义了 APP 自动化测试。但是它也有自身的缺点，就是库只能支持 JAVA 使用，且对 Android 版本很有要求，老版本的 Android 系统无法支持。当然，在当时，UIAutomator 已经成为了新型 APP 自动化测试工具的代表。

但是很快的，一代 APP 自动化测试框架的**王者**诞生了：**Appium**。我也是在简单研究测试后，很快投入了 Appium 的怀抱。它的优势非常明显：

- 开源
- 跨平台，支持 Android、iOS、Firefox OS
- 不需要源代码，不需要重新编译 App，可以基于现有的执行
- 扩展了 WebDriver，对于测试人员来说几乎无需切换
- 支持多种主流语言编写

从原来上来说，在 Android 端 4.2 以上是用 UiAutomator 作为底层，Android 2.3 ~ 4.1 用的是 Instrumentation，而在 ISO 则是封装 UIAutomation 作为底层，这样拥有了所有框架的优点，很快的成为了 APP 自动化测试的不二之选。

![图片描述](http://img.mukewang.com/5d9d31460001bd5910240512.png)
从上边统计图片中也能看到，Appium 在 APP 自动化测试领域无疑是最佳也是最普遍的选择。所以，后面我将框架再进行 IOS 上的扩展仍然没有考虑过其他底层，复用着 APPIUM，直到今天。

所以对于后来也有很高评价和口碑的工具，诸如 Android 端的 Espresso、Calabash 以及 IOS 端的 XCTest、Frank 都没有再继续深入使用。尤其是 Calabash 和 Frank，行为驱动的模式也从某种程度上改变了自动化的方式，所以大家有兴趣的可以研究一下。

就像我们的 Web 框架、接口框架一样，APP 自动化也有一些开源的框架和集成平台，例如 AppTester、TestBird 等等，目前市面上主流的框架平台也都是基于 Appium 进行的二次封装。

当然，有很多像我一样喜欢重复造轮子的童鞋呢，也可以基于 Appium 来开发搭建属于自己的框架，完全可以跟自己的 Web 或接口框架融为一体。



### 更新的移动自动化技术

随着互联网业务的发展，很多项目里 H5 和小程序的占比越来越多，同时由于互联网 H5 和小程序相对于 WEB 和 APP 来说，迭代速度更快，所以自动化测试也更加迫在眉睫。

尝试使用了一下 Appium，对于 H5 还是可以部分支持的，只是在页面切换稍微有一点问题，对于微信小程序就比较困难了。所以恰到好处的，腾讯开源了 FAutoTest（FAT）框架，重点针对微信 H5 和小程序，使用起来还是相对快捷的，但是有它的限制所在，只对微信相关的兼容比较好，对于支付宝小程序、H5 如果想要支持，还是需要修改一部分源代码的（这是当然的，毕竟是腾讯开源的框架嘛）；同时更重要的就是暂时只支持 Android（同样，也许未来会扩展支持 IOS）。相信未来随着小程序的发展，也会有更好更全面的框架改进或者诞生。



### 自动化前瞻

到这里，我们对于自动化测试的内容就告一段落了，尽管自动化已经发展了很多年，但是我认为还处于未完成成熟的阶段。目前关注的主要在于 “模拟” 和 “自动”，我个人觉得未来的方向有可能如下几个：

1. **行为驱动优化**：目前的行为驱动还是略显不够合理，更多的框架是硬向行为驱动上靠近，也许未来会做更多的行为驱动上的优化和改进，把行为驱动进一步发扬光大。当然，现在的 cucumber 如果使用习惯的话，还是比较出色的。

2. **流量回放自动化**：刚刚说了，现在自动化关注的是模拟。但是模拟的足够么？我觉得还不够，因为模拟的更多还是基于我们自己编写的用例，那是不是有办法可以把客户的行为动作模拟下来呢？这就是流量回放的意义，可以把生产环境的流量完全复制到自动化测试环境。

   现在的阿里已经有了这样的数据平台，叫 DOOM，但是还没有能够完整推广和开源开来，所以现在的流量回放更多是从 TCP 请求上下手，这样不利于我们针对生产数据的清洗，这也有可能是未来自动化测试的发展方式之一。

3. **AI 人工智能测试**：其实现在已经有很多团队开始基于 AI、基于神经网络和图像识别开展完全无需编程的自动化测试了，但是效果还比较有局限性。但是阿尔法狗已经出现了，下一个阿尔法 Tester 会很远么？

# **第7章 性能测试**

## **23 换个角度看世界-从为什么要做性能测试谈起**

### **从功能测试到性能测试**

花了很久的时候跟大家讨论自动化测试，涵盖了从 WEB 端到接口层再到 APP，自动化测试，甚至再进一步发展成为测试开发，当然是很重要的能力，对于现在各个公司来说，也是不得不具备的技能，但是，自动化测试仍然没有跳出传统意义上功能测试的圈子，是我们利用工具、通过脚本来辅助我们进行功能测试的技术。

忘记了是在知乎上还是在哪儿看过的一个比喻：功能测试是什么呢？我们通常做的黑盒测试更多的像老婆逛商场，我在外边车里等着，那商场就是黑盒子，我不知道也不关心老婆在商场里怎么逛、挑了什么、是不是划价了，只在乎的是老婆啥时候出来、买了多少东西、我的工资卡被刷掉了多少。而自动化测试无非是把这个过程简洁一点，我懒得去带着老婆逛了，所以让我家的司机（脚本）带着老婆去商场，告诉司机你要注意观察哪些结果，回头等我下班反馈给我。关注点没有变，还是一样的。而一旦商场里边发生了刷卡有问题、服务员跟老婆发生了争执，就立刻需要我过去解决，这就是 BUG 的排查了。

那么性能测试呢？很可能某个商场在搞啥周年庆活动，老婆不知道从哪里得到了消息，飞奔到了商场，发现人山人海的 “老婆联盟” 开始一起扫货，每天不休息的进行，连续扫了好几天。这时候关注点，就变成了商场是不是还能顶得住，是不是会断货，服务员会不会骂人，当然，也要关注我的银行卡会不会刷爆。

这个类比很形象对吧，性能测试，就是让我们换了一个视角来看问题，所以在测试技术来说，它是与功能测试截然不同的，功能测试考量的是最低标准，也就是 “能不能用”；而性能测试，则需要考虑的是 “怎样用的又快又好”。所以性能测试是建立在功能已经实现的基础之上的。所以，从今天开始，我们换个角度聊聊测试的另一个世界。

### 为什么要做性能测试？

对于性能测试，我有一个印象非常深刻的场景，那是在我刚参加工作不久，去某银行客户现场进行验收测试：银行希望我们的系统能够支持 10 个并发就可以了，于是叫来了 11 个技术人员，其中 10 个人每个人面前都打开同一个界面，而第 11 个人负责发号施令，在一声 “点” 之后，10 个人同时点击某个按钮，另外一个人开始查看数据库、服务器；同时，每个参与点击的人汇报自己的响应情况 —— 有没有卡住，大概几秒操作完成。

这真不是个笑话，而是我亲眼见到的场景。性能测试，虽然当时已经是一门高级的测试技能，但是掌握的人并不多，所以很多传统公司，仍然用这种所谓的 “手工性能测试” 的方法，相比于性能，功能是最重要的需求。

而现在，随着互联网的发展，最基本的 “能用” 的要求，已经不能满足广大用户的需求了，随便的一个网站、一个 APP 除了要满足用户的基本需求以外，还需要考虑到：服务器能不能及时处理大量用户请求、打开一个页面不能让用户等的太久、数据库要能存储到大量的数据、网站和 APP 一直不间断的有人访问，需要承受长时间的运转等等。双十一、618 等各种互联网节日的到来，也体现了，这个时代的与众不同，再随着，近几年移动互联网的崛起，每个人手中都掌控着一部，随时发起各种请求的移动 “发射器”，所以几百、上千、上万的性能并发要求已经变成了小 case，上亿并发的要求都比比皆是，还可能用一亿人个来找一个大嗓门喊 “点” 么？这时候就需要我们的性能测试技术了。

前边聊的都是企业为什么需要，这是告诉我们性能测试的需求是存在的，而且未来会越来越大，那么接下来呢，从我们测试人员自己出发，我们为什么要去做性能测试？

首先，性能测试是测试人员从功能角度、黑盒角度走到架构角度的平稳通道。无论是功能还是自动化，我们可能仍然不会去考虑系统的工作原理，但是性能测试却要求我们从整体的场景设计、架构设计到容量规划、瓶颈分析，这完全基于系统的底层，更贴近于架构。

其次，现在会测试的人很多，能够用一些自动化测试工具、框架来完成自动化测试的人也有不少，但是对于性能，尤其是可以完全掌握性能测试，不仅能够编写性能脚本、设计性能场景，还能向后做到性能的监控、分析和调优，这样的性能测试工程师却是少有并且抢手的。

最后，也是最重要的一点：**性能测试的工资相对比较高。**

所以，无论是从企业的需求上，还是个人的发展上，性能测试都是作为测试人员来说不可获取的能力之一。

### 性能测试的分类

其实，性能测试还是一个相当大的分类，里边会包含多种类型的性能测试，我们从几个最常用的来分析一下：

**负载测试**：通过逐步加压的方式来确定系统的处理能力，确定系统能够承受的各项阀值。举个例子来说，我呢自己开了一家咖啡馆，雇佣了一名服务员（咳咳，有点抠门），负载测试呢就是我不断的扩大经营，咖啡馆越来越大，从无人问津一直做到了最火爆的咖啡馆，同时会有 100 桌客人，这时候我要看看这个服务员，在不断增加的工作量下完成工作的情况。

**压力测试**：如果说负载测试，是要在一个合理范围内看完成工作的情况，那么压力测试则是要看服务的临界点。所以这时候我决定了，不让这个服务员休息，而且不断的增加客人数量，超出了他能承受的极限，那这样我看看这个服务员会不会累坏、罢工或者辞职。

**容量测试**：负载和压力测试，都是在一定压力条件下我们来看服务的性能，而容量测试相反，是在一定性能目标的前提下，系统能够处理的最大能力。通过前边的测试呢，我决定把这个服务员录用了，但是我这个人特别注重用户体验，所以我希望用户点完咖啡以后能够在十分钟内拿到他的咖啡；在这样的条件下，我想知道这个服务员最多能够同时接待多少桌客户。

**配置测试**：这是通过对被测试软件的软硬件配置的测试，找到系统各项资源的最优分配原则。所以服务员还是这个服务员，那么我开始尝试调整座位的摆放、吧台托盘的位置、服务员的行走路线等等，在这个基础上找到最适合的布置方式。

OK，到这里，我相信你已经明白了什么是性能测试、我们为什么要去做性能测试以及性能测试有几种场景分类，最后的最后，如果你决定要学习性能测试了，需要哪些方面的基础呢？

- **掌握接口测试**
- **有简单的编程能力**
- **对网络基础、HTTP 请求、操作系统有一定了解**
- **能够理解并分析系统的架构**
- **有中间件、数据库的知识积累**
- **能进行接口的抓包操作**

这是你要掌握的一些基础技能，接下来，对于性能测试的学习包括：

- **性能测试工具使用**
- **性能场景分析**
- **性能应该关注哪些指标及相应的监控方式**
- **性能测试的结果和瓶颈分析**
- **如何调优的手段**

如果你能够把上边的都一一搞定，那么性能测试基本可以认为是有所大成了。在后边呢，我不会一一去讲解这些知识，而是对一些大家需要注意的、忽略的点给予一些指引。

## **24 比“码脚本”更重要的事：性能场景分析**

### 论性能测试的流程

在聊今天的主题之前，我们先来说说性能测试的流程，毕竟 “无规矩不成方圆” 嘛。上一次，我们先认识了什么是性能测试，了解到性能测试其实是一种非功能测试，但是对于我们测试人员来说，与功能测试一样，性能测试也需要有自己的 “规矩”。
![图片描述](http://img.mukewang.com/5da029db000179d607250228.jpg)
可能很多同学并不太理解性能测试，为什么还要做所谓的需求分析，很多人做性能测试都是拿来就做，直接上工具、码脚本、加压一气呵成，糊里糊涂做完了都不知道自己的结果是什么。再加上市面上确实很多教程、书籍都把重点放到 LoadRunner、Jmeter 等工具的使用上，让很多性能新手觉得 “性能测试 = 性能工具使用”，然而事实并非如此，在我看来，工具的使用只是性能测试的一部分，甚至是一小部分。

所以，接下来我们要聊的就是我认为性能测试过程中最重要的工作：**场景分析**。如果没有合理正确的场景分析，那么性能测试的执行其实是没有任何意义的。



### 性能测试之场景分析

在慕课上关于性能被提问最多的问题就是：风落老师，我要对一个网站做性能测试，应该压多少并发才合适啊？

在没有任何背景、任何可参考数据下直接问这个问题，就如同直接问你：我要炒菜应该炒多久，放多少盐，放多少辣子？再好的厨子，你也要告诉他要炒什么菜？吃饭的人口重还是口淡？是想要微辣还是变态辣？

同样的，想做好一道菜，不仅仅是用料的量，还有刀工、火候、菜品质量、调料选择等等多方面，而性能测试里也是同样，性能测试绝不仅仅是考虑 “多少并发” 这样简单的问题。

![图片描述](http://img.mukewang.com/5da02a130001d37611190829.jpg)
上边这个图是我在慕课上一门性能课程中的实战纲要，算是比较完整的表明了在一个真实项目中应该如何去从零开始进行性能测试。而画红框的部分，就是我们性能测试中需求分析和场景设计的内容，可以很明显的看到，这会占据到我们性能测试完整流程中很大的一部分。

所以，我们再把这部分再精炼一下，其实每一个性能测试的需求场景分析会分成两部分：性能测试指标和基于指标的场景设计。



### 性能测试指标分析

在对任何一个测试系统进行性能测试之前，我们都要对这个系统有一个全面的了解和认识。这就像我现在是一个特级厨师，某个酒店请我帮忙给他们的菜品改造一下，那我可没办法上来就干，怎么办呢？我得知道一下原来的菜单是什么样子，就餐的客人是什么情况？之前的厨师是谁？后厨团队的水平如何？怎么用料火候去做的菜？以前客人的评价怎么样的。这样我才能给出改进措施。

性能测试也是一样，首先，你得了解包括系统是做什么的，面向的客户群体是谁，业务范围和功能是什么；接下来你要清楚整体的系统架构是怎样的，服务器部署方式是什么，用了什么语言、连接的什么数据库、中间件是啥、协议又是什么；再来，如果系统是一个已经上线运行的系统（大多数新系统其实很少有性能测试需求，毕竟初始用户量还不大），你得明确系统历史的运行情况，系统的数据规模有多大，预计未来的规模会有多大。这会对你后续的性能目标评估以及未来的分析调优带来很大的便利。

结束了么？当然不，一个特级厨师再强能力也是有限的，万一这家酒店菜单上有两千道菜岂不是要累死？所以我们的优化部分主要在哪儿呢？一是客人点的多的菜，二是以前评价低的菜，这样才能把原来的骂名变成夸赞，同时出现爆款美食。

那么性能测试工程师，除了基础系统架构信息的调研，还需要对业务属性的信息进行评估。这就包括系统到底有哪些业务，哪些是核心的业务，核心业务的历史交易处理量有多少；哪些非核心的业务访问量也比较大或者有没有哪些场景之前出现过生产的性能瓶颈等等。这样，我们才能确定到底哪些地方要做性能测试，哪些不要以及应该如何场景的设计。

接下来，就是要确定，我们的性能需求指标了。一道菜品，优化到什么程度才算优化合格，都应该有个指标来评估，那做菜很简单，从 “色香味” 三个指标去进行评估，再来观察客人的反应和评价。那性能测试也有自己关键指标的评估点，这些指标重点包括并发数、响应时间、TPS、资源利用率等等。

例如：我们希望系统能够处理 50 个并发查询响应时间最大不超过 3s，或者我们系统可以保证每秒处理 100 个用户的交易，这都是比较明确的性能目标。这个目标应该从哪里获取呢？

1. **开发过程相关文档**：有时候我们厨师对于菜品的优化就源于老板的要求，老板希望这个菜变的鲜美或者香辣、希望摆盘更精美好看等等，同样已有的文档是性能测试需求的基本来源，项目开发计划书、需求规格说明书、设计说明书、测试计划等文档都可能涉及性能测试的要求。通过收集这些资料，可以找到初步的性能需求。但是由于产品人员、需求人员一般不考虑软件性能，所以有可能不会提出很准确的性能要求，所以也需要我们性能测试人员给予专业的引导。

2. **相似项目性能需求**：什么东西好吃都是相对的，所以任何一个好厨子都不是闭门造车的，他要看看自家酒店其他厨子的菜怎么样，甚至还要出去看看别人家的厨子是怎么做的，才能更好的领悟出自己的特色。每个公司的产品线都不是单一的，同时不同公司的产品也不会说完全没有相似的地方。所以历史上的项目、其他公司对外公布的数据都可以作为性能测试需求的参考。比如说公司之前做过一个 618 的活动，那我们可以完全在这个基础上来评估双十一活动的性能需求；或者我们要做的是一个共享单车的产品，完全可以依照市面上已有的共享单车数据量和日处理书作为参考。

3. **业界公认标准** ： 性能测试主要对于响应时间有比较公认的标准。一般情况下，大多数互联网产品采取比较严格的性能响应标准：**2 秒以内，用户感受良好；2 5 秒，用户觉得可以接受；510 秒，用户会觉得烦躁，会无法接受，从而导致频繁地刷新页面；超过 10 秒，用户完全无法忍受，直接离开。** 当然，一些特殊情况下，可以使用宽松一点的标准：8 秒以内，用户可接受；8~16 秒，50% 用户选择离开；32 秒后，90% 用户离开。目前互联网采取前者居多。

4. **80/20 原则**：80/20 原则就是系统在每个工作日有 80% 的业务是在 20% 的时间内集中完成，或者系统 80% 的用户会在 20% 的时间内集中进行应用操作。比如说，系统可能一天处理的业务总量是 10 万笔，每天系统开启的时间是 9 点到 20 点，我们来简单估算一下峰值的 TPS 就是用

   (100000*0.8)/(11*0.2*3600)=10.10

5. **系统日志**：现在日志分析是性能测试需求获取手段中最重要的一种，目前的互联网公司越来越重视日志分析。比如各大电商网站，数据挖掘是怎么分析用户行为的？很重要的一点就是对日志进行分析，评估用户的使用习惯。同样，通过分析日志，可以帮助性能测试人员快速获取系统性能参数，如并发量、响应时间、业务分布情况等。

到这里，通过上边几步，我们基本了解了系统的关键信息和预期的指标，接下来就是将我们的性能指标需求转变成为性能的场景。

**场景设计**

有了前边的准备，对于厨师来说，要进行菜品的优化就显得相对简单了。重点在于到底哪些地方需要进行性能测试、这些场景操作的数据库中有没有存量数据要求、要求有多少、需求分析中需要的并发数、响应时间等指标又是多少。

先来确定下性能测试场景如何去选取：

1. 用户量访问比较大的功能
2. 与金钱相关比较重要的场景
3. 影响业务主流程的场景
4. 开发人员认为可能存在性能问题的场景
5. 应该考虑综合场景，防止线程争用导致现场死锁以及数据库死锁
6. 应该做稳定性场景测试，防止长时间运行导致的内存泄露情况发生

再来，是我们的性能数据量。这个比较简单，例如现有系统的用户量为 1w，我们需要系统支持未来的用户量为 10w，那么登录功能对应的用户数据表存量应为 10w 左右，在这个基础之上来规划我们的测试。同样，比如同一个网站的页面展示，对应现在的数据也进行 10 倍的放大来进行初始性能数据量的估算。

接下来就可以将三者结合起来，把场景、存量数据和性能需求合并起来，形成多个性能测试场景的用例设计。

OK，到这里，一个比较完整的性能场景分析过程就结束了。简单么？恐怕并不。性能的场景分析是我们面对一个性能测试最难以下手的一点，这里不仅仅是我在这里跟大家聊几句就可以的，而是需要大家不断在实践中积累自己的经验，逐步掌握性能测试最重要的一环：场景分析。

## **25 不懂监控与调优，就像白天不懂夜的黑**

大家好，我是风落，是一名测试，也是半个开发，同时还偶尔客串下面试官。很突兀的重复介绍自己一半是怕大家忘记了我是谁，另外一半是想从 “客串面试官” 聊到今天的话题。粗算一下，大概我面试过的早就超过了三位数，但是在面试过程中，尤其是性能测试，给我一种很奇怪的感觉：大多数会用 LoadRunner 或者 Jmeter 的同学，认为自己是熟悉性能测试；而把工具用的比较不错，能截图给出工具的结果，分析下 TPS 的就认为自己是掌握了性能测试。这不是夸张，而是这些面试者真的这么认为，并且也认为性能测试自己能够给出通过或者不通过的结果，剩下的就不关自己事情了。

就像前边说过的，所谓工具使用真的只是性能测试的一部分，甚至是很小的一部分。上一回，我们谈了，我认为最重要的性能场景设计，今天我们来谈另一个话题：监控与调优。既然有了 “最重要”，那么监控与调优，再加上 “第二重要” 的标识并没有什么意思，在我看来，监控和调优能力，是区别于一般性能测试工程师和高级测试工程师最本质的特征。



### 性能测试的本质

再说监控和调优之前，我们先来想一下我们进行性能测试的最终目的是什么？是给出性能结果么？

这当然是我们的目的之一，其实在我看来，本质上的目标主要分两个方面：

1. **有没有足够的能力**。这就是说我们来验证系统是不是符合我们想要的性能要求，比如我们预计的性能指标是 100w 存量用户、1w 同时在线、800 交易并发下能够控制响应时间在 3s 内，性能测试的目的，首先就是要看看现有情况下是否能够满足。
2. **能力的规划**。一般情况下很难一下子就满足，那么这就是怎么样才能让系统达到我们要求的性能能力。是不是可以通过增加服务器、修改配置、优化 SQL、修改程序等方式来提升系统能力，使性能达标。

在这两方面之中，更重要的就是后者，也就是通过监控调优的手段，让系统运行的更好，打破软件硬件方面的瓶颈。



### 系统可能存在的瓶颈

先来说说瓶颈，知己知彼方能百战不殆，再去监控它调试它之前我们先要做的就是了解它，知道什么地方可能出现问题。

从硬件的角度上说，一般可能存在瓶颈的点，包括磁盘空间不足，导致的运行速度下降、CPU、内存、磁盘 I/O 读写速率等方面。

软件的角度就包括多个方面，一方面是服务器方面的配置，比如由于 TOMCAT 或者 Weblogic 等中间件，连接池参数配置不合理会造成瓶颈；另一方面是应用自身，例如程序架构的不合理，代码不当引起的内存泄露、GC 不彻底等问题；最后一方面，应该算得上是性能测试里遇到瓶颈比较多的了，那就是数据库方面。包括数据库的索引、锁、不合理的表空间设计、慢 SQL 等等。

其实说起来应该还有一个地方，就是网络层面，但是由于我们的性能测试一般更多的是在局域网下进行，忽略网络影响，所以在测试过程中可以忽略。



### 性能测试的监控

由于上边提到的各方面的瓶颈，所以我们在进行性能测试的时候，一定要注意对软硬件方面的监控。我这里不去跟大家详细去说监控的细节，大体聊一下常用的监控点和工具。

1. **操作系统监控**：Windows 服务器 - Perfmon；Linux 服务器 - TOP / Nmon /netstat 等
2. **数据库性能监控**：Oracle - Spotlight on Oracle； Mysql - MySQLMTOP
3. **TOMCAT 监控**：Lambda Probe
4. **JVM 监控**： Jmap / Jstack / Jconsole / JProfiler 等

综合这些，可以达到对整个系统的有效监控，包含所有的软硬件数据，结合着性能测试工具里 TPS、响应时间等数据，可以更好的横向对比分析出可能存在的性能问题，并逐步优化解决。



### 性能优化

优化其实是很难说清楚的一个点，也是在性能测试里很需要经验的地方，我们聊几种常见的场景：

**Round 1 ： 响应时间慢**

这恐怕是我们遇到最多的场景，直观上看过去就是响应的非常慢。这个时候我们的调优方式就是把整个的 Response Time（RT）通过日志进行不断的分解，例如，我们现在是把一个 RPC（Dubbo）的服务部署在 Tomcat 中，上游用 Nginx 做反向代理。在这样的架构下，一个完整的 RT 就会包括前端 RT、网络传输时间、Nginx RT、Tomcat RT、Dubbo 服务 RT 和数据库 RT。如果存在问题，我们可以请开发配合在各个局部增加日志，观察具体响应时间慢的点，从而进行后续的优化动作。

**Round 2 ： TPS 波动大**

一般来说，性能测试的 TPS 应该随着并发量的上升而呈跟随上升趋势直至稳定，但是有时候我们会发现，被测系统的 TPS 非常不稳定，上下波动非常大。排除网络可能造成的影响，在实际测试过程中可能遇到最大的可能就是：**被压测服务器上存在其他运行的服务争抢资源或者垃圾回收的问题。**

其中后者的可能性居多，一般都是出现有频繁的 FGC。这就是需要我们结合着对 JVM 监控的数据来进行分析，修改 JVM 内存参数或代码逻辑，达到优化的目的。

**Round 3 ： 开始加压正常，到某一个点突然开始出现错误，并越来越多**

这种情况多数可能是由于服务器、中间件等配置的线程数、超时时间造成的影响，线程数过小，服务端同时可以处理的请求就少，自然到达一定的并发就会等待，最终超时错误。

**Round 4 ： 并发数增加，TPS 不增加，CPU 内存利用率都不高**

这类问题我遇到过的更多时候是由于 **数据库的慢 SQL 或者不恰当的代码或数据库锁机制造成的。** 一般优先排查数据库 SQL 问题，通过数据库日志判断 SQL 执行时间，查看是否需要优化；如果 SQL 没有问题，那么就需要与开发同学一起沟通确认代码中是否有不恰当的同步锁等等。

当然，这都是经过不断总结到的经验来分析出来的常见的性能优化场景。那么如果你碰到一个性能问题，却不知道问题出在哪儿，一般情况下，我们排查问题的顺序是从上到下：先查服务器硬件瓶颈（CPU、内存、I/O），再看是否由于配置问题引起，接下来查看数据库、SQL 是否存在瓶颈，最后是应用代码逻辑、JVM。

同时，一定不要忘记另外一个点：前端性能。当你发现后端请求响应时间一切正常，但是通过前端访问仍然存在性能瓶颈的时候，一定不要忘记前端加载过程带来的影响，而针对前端性能的测试使用 YSlow 是比较方便的。

![图片描述](http://img.mukewang.com/5da146e10001c68b07420288.png)
顺便也介绍一下，前端性能问题最常见的一些优化方式：

- 合并 HTTP 请求，减少请求数量
- 资源压缩
- 使用浏览器缓存
- 图片的优化：雪碧图等方式

当然，这里边只是介绍了一些性能监控与调优要关注的东西和一部分要点，并没有详细去跟大家说到底怎么监控、用什么命令、怎么去看，也没有去细节的讲每个部件到底怎么调优，所以，如果想要真正掌握性能测试，还需要真正上手去实验、去探索、“遇事不决找百度 "，这样才能搞定” 性能 “这座大山。

## **26 站在LoadRunner与Jmeter的十字路口**

之所以把工具放在性能测试的最后，也是因为我觉得相比场景设计、监控分析来说，其实工具并不是太重要。但是 “学习性能测试到底应该学 LoadRunner 还是 Jmeter？”，这个问题仍然持续排在性能测试问题各大榜单排行的前列。所以，也还是跟大家简单聊一聊测试工具。

相信如果给国内常用的性能测试工具做一个排行榜，LR 和 Jmeter 这两款工具一定是赫赫有名，关于两个工具的争论也一直没有停下过。我在这里也不想从什么是否收费、录制功能、安装方式、IP 欺骗、分布式各个方面去比较，因为我觉得没有非常大的意义。

那什么有意义呢？

我觉得首先我们要知道，LR 和 Jmeter 都可以满足我们对于性能测试的各种需求，无非就是本身工具支持，还是代码扩展来支持的问题；其次，二者去做性能测试的原理都是一致的，都是通过脚本，发送请求到应用服务器，监控服务器反馈的结果的一个过程。所以承认二者皆可行是很重要的前提，没必要非要褒一个踩一个。

那么接下来我想说说我用这两个工具的体会：

刚开始做性能接触的就是 LR，后来随着对 JAVA 使用的强依赖逐步开始使用 Jmeter，可以算的上对两个工具都用的还比较深度。比较起来的话，LR 的界面交互使用做的更好，支持协议全，各种功能也比较完整，监控视图漂亮，初学者用起来的文档多，上手快，而且更接近于底层，坑也相对比较少，这是它的优点。缺点嘛，就是 LR 虽然支持分布式，但是因为主节点一般为了 GUI 都是放在 windows 上的，发挥能力有限，同时由于很重，加压能力也比较有限；加上 LR 客户端过大，所以基于云端部署会比较重，对于服务器的要求也比较高。

反过来看看 Jmeter，它的优势当然是轻量级，同时开源社区后续更新也可以期待，如果有一定的代码能力，那么几乎可以完成所有的性能测试工作，缺点就是 GUI 设计太希望小白化，所以过度封装，以至于使用起来觉得并不友好；jmx 脚本对应的 XML 格式太不直观，不方便维护和管理，代码调试也不方便。对于我来说，我认为其最大的优势就是一点，开源。开源可以方便去做二次开发、数据结果也更加开放，完全可以自己去做后续处理，也很容易去做一些全流程、持续集成。大公司目前更多的还是抛弃了 LR 投向各种开源二次开发套路的怀抱，Non-GUI 模式也是大势所趋。

这么比较起来，好像看起来我在推荐 Jmeter，但是其实并不是完全的。如果站在一个性能测试专家的角度，Jmeter 自然是相比 LR 更加符合现代的测试策略，也更加符合 “造轮子写代码” 的希冀。但是对于初学性能来说，我觉得 LR 是更符合性能测试理念的，交互使用也更加便捷，让大家可以循序渐进的去了解性能测试。当你掌握了性能测试的各项精髓，再回过头来看看工具的话，我觉得切换上手都是非常容易的。

不管怎样，回到最初的这句话，性能测试里最重要的是场景设计，其次可以算是监控分析调优，工具其实作用对于性能专家来说只是个加压的信号发生器。所以，工作习惯不同、使用场景不同，对于工具的需求也不同。

目前一些比较大型的公司，也不再局限于 LR 和 Jmeter 的纠结之中，更多的会使用 ngrinder、gatling 这样开源的，虽然不适用于小白，但是对于互联网来说，能够制造更大的并发请求和更便捷的集群搭建。当然还有最近开始展露头脚的 Locust，由于只是简单使用过，所以不好多做评价，但是对于并发请求的数量上也有非常好的支持。

在我看来，未来的理想的性能测试工具，或者不能称之为工具，而是扩展成为解决方案，是应该能够除了满足我们的压力发生器以外，能够集成更多的功能，比如：

- **可持续集成、全流程性能**
- **监控平台化**：目前不管用 LR、Jmeter 或者其他工具都需要到各个服务器节点中，去进行 CPU、内存、连接数、JVM、数据库、中间件等等的解控。如果最理想的方向发展的化，更好的集成所有监控功能，可以集合报表，便于我们定位问题，也更方便我们根据各种曲线图的拐点，来分析特定的指标和应用的 log。
- **历史性能留存和对比**：一套完整的解决方案我们希望能够留存历史的各项性能数据，方便我们跟前一年、上一季度的服务器性能进行比较。
- **数据工厂**：甚至说，我们期望的解决方案，能够完美的将某一时段的线上流量，通过数据清洗后，引入我们的性能测试环境，甚至我们可以在此基础上进行性能数据的增益。比如说：我们希望在当前的系统环境下，模拟去年双十一当天零点到零点三十分的流量模型，看现在是否比去年同期的性能有所提升；考虑到我们的活动会比去年有更大的推广力度，所以我们也可以将去年的流量增大 1.5 倍来进行测试。

现在已经有一些平台基于此做了大胆的尝试，比如阿里的 PTS，在一定程度上解决了性能的很多问题，仍然有很大的提升改进空间，但是已经是阿里云上的标准化性能解决方案了。

聊了这么多，还是最后想说，性能的工具其实是不断进阶、不断变化的，平台化也是性能测试的趋势，对于我们来说，重要的不是掌握什么工具，更不是去辩论孰好孰坏，而是掌握性能测试的思想，学习设计的思路，增强监控分析调优的能力。以我面试的经历来说，只聊工具的或者只会一种工具的，都还只是性能测试的初学者，还有很多的路要走。

总之，性能测试对于我们来说，会随着架构、云端部署、Docker 等等或许我们还不知道的技术而不断改进，所以对于每个人来说，性能测试没有终点，还有很长的路要走，我们共勉。

# **第8章 Web安全**

## **27 世界那么大，我想去看看 - Web安全简介**

这一次，跟大家聊一点敏感词：安全。其实这个词于我自己是有挺多感触的，从 10 年开始，我可能算是最早在网络上进行安全测试公开课分享的那批人，也是很多安全测试的视频让我最早被很多测试人包括一些大佬们所认识，更是作为 “普通白帽子” 亲历了 “袁炜事件”、“乌云事件”，算是某种程度上见证了 “白帽子圈” 的兴衰，所以其实有很多话想说，但是又不知从何说起。

可以说，由于国内互联网的迅速发展，性能测试、自动化测试的技术实力已经提升到了一流与二流之间，那么安全测试毫无疑问可以算是测试领域内的软肋。不管是所谓的测试架构也好、总监也罢，除了一线互联网以外，其他的公司几乎完全没有系统完善的安全测试，最多就是基于工具扫一扫而已。

曾经很多公司还依赖于 “乌云模式” 帮助自己进行一些安全方面的众测，但是随着 16 年的 “乌云事件”，我熟悉的一些 “白帽子们”，甚至还有部分 “核心白帽子”，都已经不再挖漏洞了，我不敢妄议，这是不是安全的倒退，但是，至少在现在，安全已经不再让大家陌生和忽视，就像乌云的联合创始人说过的：

> 之前很长时间，我都以为是乌云创造了历史。但现在我知道，是历史选择了乌云。那个时代互联网爆炸式发展，而网络安全没人重视。网络犯罪行为越来越多，但没人告诉大众，他们究竟是如何被侵害的。面对那个坠落的世界，需要有人站出来 —— 这个喊出皇帝新衣的小孩，恰好是我们。人们总在争论乌云的模式是否极端、披露漏洞是否要授权，但在那个时代里，我们别无选择。

额，似乎说的有一点跑题，也确实是这个主题给了我自己不少的感触，我们书归正传，先来聊聊什么是 Web 安全。

官方一点来说，Web 安全测试，是有关验证 Web 应用的安全服务和识别潜在安全性缺陷的过程。当然，我们可以更简单一点去理解，安全的本质是信任。这就好像说，我们新买了一套房子，因为不信任开发商，我们换了个防盗门，认为屋子里很安全，这是基于我们对防盗门厂商的信任，可是如果我们觉得防盗门厂商可能会留一把我们的钥匙，那就不安全了。

所以几乎所有 Web 安全的产生都是源于我们的系统信任和研发所有客户的输入内容，但是实际上总有一些不怀好意的 “黑帽子们” 是不按常理出牌的。于是便有了如家等酒店开房信息泄露、360 出现任意用户修改密码漏洞、携程网数据泄露、12306 用户数据泄露等等一系列由于安全问题爆出的影响。

似乎看起来比较遥不可及，说个我自己经历过的。大概几年前，我帮某新兴电商网站进行众测，结果非常轻松的用绕过的方式拿 0.01 元买到了价值上万的商品。所以相比较起功能测试来说，生产上有遗留的功能问题，最多就是体验不好，业务失败，损失一些用户，本质上问题还不是非常大；如果有安全漏洞，那往小了说，可能会造成资金的损失，大一点可能服务直接瘫痪，再大一些可能会导致服务器资源被黑客利用，被敲诈勒索，甚至是客户数据的丢失和泄露，很可能直接导致业务完全无法运作，带来巨大的损失。

哪怕 “警惕如我”，都在手上漏掉过通过三方鉴权的安全漏洞，直接被黑客刷走了若干奖品。

生活中与安全息息相关的操作，现在更是层出不穷，比如：

- 为什么我们登录的时候经常要求我们输入一个验证码？
- 在一个网站上长时间没有操作，为什么会 session 失效？
- 为什么很多网站都不支持 “一号多登”，会有顶下来的情况？
- 为什么支付宝之类的支付接口都是 https？
- 为什么银行转账之类的操作都是两步确认？

那么，在 Web 层面都有哪些典型的安全漏洞呢？

我们简单给安全漏洞分一下类，其中最常见的漏洞，就是命令执行类的安全漏洞，这里包含 SQL 注入、XPATH 注入、OS 命令执行、缓冲区溢出等等，再有就是客户端攻击的漏洞，我们前边说过的绕过、大家比较耳熟的 XSS 攻击（跨站脚本攻击），CSRF 攻击等等。这是大家稍微熟悉一点的，另外，有一部分就是大家不太熟悉的，认证授权类的漏洞，这里边覆盖了验证机制和加密授权等各方面的漏洞，这部分虽然出现的漏洞较少，但是比较零散，而且漏洞也会比较严重。还会有一些其他的漏洞，例如设计缺陷、逻辑漏洞等等，都需要我们综合考虑。

可能有些同学对于安全有一些认识和了解，包括很多同事、同行和学员都会有这样一个疑问：既然有一些现成的扫描工具可以用，那我们还需要学习手工安全测试么？直接拿过来结果砸过去不就好了？

实际上，在正式的安全测试过程中，基本上都是自动化审计与人工测试相结合的。一方面，自动化审计的工作也需要安全测试人员利用自己的专业知识，对扫描的结果进行分析和判断，并不是所有扫描结果中的漏洞都是真的安全漏洞，知名如 Appscan、Webinspect 都会有各种错报的现象；另一方面，需要根据安全测试人员的经验，找出一些扫描工具没有办法发现的安全问题，例如，前边提到的认证授权类漏洞、设计缺陷等等。

然后呢，我们往俗气一点说，安全测试是目前互联网行业非常缺少的一项技术能力，虽然在实际工作中，很少需要测试人员全职进行安全测试，但是一旦拥有安全测试的技能，在薪水和级别上都会有一个不错的提升。

最后，我这里需要给大家提个醒，安全测试可以学习，也可以去做，但是不要 “踩过线”。要进行安全测试的实际操作，要不然，用自己搭建一些开源的或是可以用于安全测试练习的系统（WebGoat 等），或者就用自己工作上正在测试的项目，万万不要直接在互联网上觉得哪个网站不错，就任意的去施展自己的攻击才华。

举个可能不太恰当的例子：比如你看到别人家房门没有关，于是你就跑进去了，拿走别人的钱包和手机，并且照个照片，然后在他门上贴个字条告诉对方，你家门没有关啊，你看这个照片就是证明，顺便还评论下别人的钱包现金也太少了，你觉得要让人家情何以堪？所以，纵然安全测试很重要，仍然要约束自己的行为，做一个**合格且合法**的安全测试工程师。

## **28 由“忘记密码”拓展开来 - 揭开安全的神秘面纱**

上一次呢，我们跟大家从整体上聊了聊 Web 安全，认识了这门测试技术对于我们的重大意义，也大体上知道了对于 Web 应用来说，都会有哪些漏洞。但是就像老北京天桥上卖艺的常用的口头禅：光说不练假把式。我们一起来拿一些真实的 “案例” 来看一看最简单的安全漏洞，揭开安全测试的神秘面纱。

我们就用一个非常常见，但是大家又非常容易忽视的点，验证机制下的 “忘记密码” 来谈起。

当前互联网网站大多提供 “忘记密码” 功能，但是呢，这里面往往会存在一些典型的安全问题。核心问题就是忘记密码的流程跳过了身份验证。

如果不考虑通过客服找回密码的话，通常网站设计有三种方式来认证用户：

1. 用户设定的安全问题。
2. 用户注册时留下的安全邮箱。
3. 给预留手机号发送验证码短信。

基于这几种，我们来找些例子看看互联网公司都会犯哪些傻。

![图片描述](http://img1.sycdn.imooc.com/5da6dff600010cdf06000539.jpg)
第一类：记得我们上次说过，安全问题本质上还是信任问题。而有些网站过于 “信任” 用户，过分鄙视用户智商，以为用户都不抓包都不分析表单参数，想写什么就写什么。

第一个小例子是很多年前搜狐邮箱，现在业务已经下线了 O (∩_∩) O ，在它的登录页中有一个找回密码功能，再点击下面的 “网上申诉”，在申诉页面的源代码里，不但有密码提示问题，Hiden 表单里竟然泄露问题答案，可获得任意用户修改密码问题答案，从而轻松修改任意用户邮箱密码。

![图片描述](http://img1.sycdn.imooc.com/5da6e0120001b02c11290770.png)
除了这样的质询问题漏洞，对于忘记密码邮件，也有可能有所漏洞。某网站贴心地实现了 “重新发送找回密码邮件” 功能，结果一起来看一下。

![图片描述](http://img1.sycdn.imooc.com/5da6e0250001688f08820347.png)
以往进行到这步，我们都会很乖的马上登录邮箱查看密码重置链接，这次在 “重发发送” 时使用 BURP 或其他工具把请求拦截下来：

![图片描述](http://img1.sycdn.imooc.com/5da6e03a00013b0e08770187.png)
发现传递了 email 参数，尝试进行篡改，将 email 改成自己的邮箱地址；没想到居然发送成功，登录邮箱，收到了重置其他用户密码的邮件。

![图片描述](http://img1.sycdn.imooc.com/5da6e04d0001a05803220141.png)
当然，还有我们现在最流行的发送手机短信，也是跑不掉的：

![图片描述](http://img1.sycdn.imooc.com/5da6e0600001116004170400.png)
将请求拦截下来，注意观察拦截短信效验码；经过多次试验。发现红色的部分 是拦截到的手机验证码。

![图片描述](http://img1.sycdn.imooc.com/5da6e0730001b16b06540198.png)
![1564729416393](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC)

除了这样简单就拿到了验证码的，也可以像之前邮箱一样，去修改发送的手机号码，扭转乾坤：

![图片描述](http://img1.sycdn.imooc.com/5da6e0840001123806730521.png)
上边的几个小例子是用一些绕过的手段来破坏了验证机制的防守。

我们再来看看另外一种类型： 知道这种明文的不太安全，所以考虑了加密，但是太过依赖 MD5 加密，事实让你知道，大多数时候，MD5 不是神器！

虽然 MD5 是个非常牛叉的非对称加密算法，只能 Encode 没办法 Decode。但是千万不要忘记了劳动人民的智慧，于是网络上搞出了 MD5 的彩虹表，可以破解很多的 MD5 加密，所以曾经的途牛也中招了。。。

![图片描述](http://img1.sycdn.imooc.com/5da6e0950001469106620276.png)
初看这个链接感觉没有太大问题，毕竟还是将关键字符进行了加密，不太容易破解，然而现实总是打脸的：

![图片描述](http://img1.sycdn.imooc.com/5da6e0a70001ade307710190.png)
我们发现居然是 ID 的简单加密，那如果有人想要恶意利用这个漏洞，只需要遍历 id 和 id 对应的 MD5 就可以轻松破译很多的用户了。

这样的例子也不在少数：

![图片描述](http://img1.sycdn.imooc.com/5da6e18100010aca08950523.png)
除了上面两类，常用的手段还包括：

- **暴力破解**，如手机四位验证码的暴力破解，密码提示问题的相关穷举破解等。
- **组合破解**，包括表单参数分析、MD5 decode、暴破综合运用等。

OK，我们简单总结一下在忘记密码，这样一个很容易被忽视的小功能上可能存在的问题：

1. 需要确认应用程序，中是否有隐含的忘记密码功能，或不通过用户名查询即可访问的情况。
2. 如果恢复机制使用质询方式，则确定用户能否枚举用户名来得到质询信息，与猜测密码相比，响应质询更容易。
3. 如果在忘记密码的请求响应中，生成一封包含恢复 URL 的电子邮件，大量此类 URL 并试图分析和预测其发送 URL 的模式，是否可以得到其他未知用户的恢复 URL。
4. 无论是使用邮件，还是发送手机验证码，查看是否可以拦截请求以修改目标邮箱或手机号，从而达到绕过的目的。

我们通过一些简单的例子，就算一个抛砖引玉的作用吧，当然，前文中这些例子呢，都是现实中已经修复并公布的安全漏洞，今天拿出来仅仅让大家引以为戒，更好的认识安全测试，也让 “安全漏洞” 与大家不再陌生。我们也能看到，即便是很小的一个点，也可能有如此的安全威胁，足以见得安全测试的重要性了。

对于安全测试，可能要完整的说下去还有很多，如果想要真的搞清楚安全测试，首先第一步要了解漏洞的原理，接下来才能去学习其测试方法，与其他测试方式不同的是，在功能测试里我们更多只是发现问题、定位问题，而在安全测试里，我们还要掌握安全漏洞的防范措施，真正做到 “教开发人员写代码”，毕竟，目前很多的开发还不太注重代码的安全性。

# **第9章 测试升华**

## **29 到底什么才算测试开发？**

感觉上测试开发这个词是最近几年才火爆起来的，想起来我也不记得到底是从什么时候，因为什么测试开发这个词语被拿出来变成了测试领域的 VIP，于是乎，测试开发开始如雨后春笋不断的出现在各大招聘网站的岗位之中，几乎变成了所有高端测试岗位的代名词，我们随便搜一下：

![img](http://img.mukewang.com/5dad469b000118ca05420462.png)![img](http://img.mukewang.com/5dad46c10001b8e805410519.png)

不难发现，从 10K 到 60K 都有很多岗位名之谓测试开发。这就让很多小伙伴为难了，到底什么才是测试开发？要有什么样的能力才叫测试开发？而测试开发又要做什么？

简单看了一下，很多中小公司以及大公司低级别的测试开发岗位 JD 都是类似这样的：

> ***职位：测试开发工程师***
> *职位描述：*
> *1、参与需求分析、提出需求建议*
> *2、制定测试计划、方案*
> *3、执行、跟踪测试，把控测试进度及质量*
> *4、深入理解系统原理、提出优化建议*
> *5、开发自动化工具、脚本*
> *6、参与性能压测*

我们突然发现这基本上是功能测试 、自动化测试、性能测试的合体，而且很多在相关公司任职的朋友也表示，很多测试开发岗位入职以后其实还是以功能测试为主，只是偶尔接触一些代码相关的测试。这让我有点诧异了，这真的是测试开发么？莫非是城市套路深，非要风落回农村不成。

所以，实际上，在我看来，绝大多数公司所谓的测试开发，更多的追求互联网时代的潮流，这年头似乎自己不叫个测试开发都不好意思出门。这恐怕是最初测试开发提出时大家都没有想到的，当然在这里，我也不好妄言大多公司都错了，那么不如我们把市面上的测试开发分一下级别。

**第一级：“入门级”测试开发**

入门级别的测试开发，我们可以大致认为还是由测试出发的，这样的工作中大体上 90% 以上的工作还是功能测试，不过开始接触一些基本的代码，写一些自动化测试脚本，参与部分的性能工作，开始不断积累。这个阶段我觉得有点像我们玩一些 RPG 游戏时候，可能前十级大家都是拿个棍子砍小怪升级，到了第十级终于可以开始选自己的职业了，在法师、战士、牧师三种经典职业中徘徊不定，最终选择了一个新出的职业“测试开发”，融合了“战牧法”的优点，同样也增加了修炼的难度。

大体上市面上10K左右的测试开发岗位都处于这样的“入门级”，大多数同学进入这样的岗位都是从纯功能测试转型的开始。

**第二级：“专业级”测试开发**

其实到了这个阶段，所谓的测试开发仍然没有完全离开测试，更多的时候是在功能测试之上将自动化测试、性能测试等技术融会贯通，能够开始像我们前边聊的搭建起测试框架、研究各种开源框架平台并且开始应用，偶尔会对 Selenium、Jmeter 等等这些开源的框架做一些二次封装，拥有独立处理测试相关事务的能力，给出各种解决方案。听上去这是一个很高的等级，但我觉得更多还是测试专家，对测试技术非常的精通。

**第三级：“骨灰级”测试开发**

还是要提前说，这里边的分级实在是不得已而为之，测试开发的大旗已起，很难把这个概念再做升华。如果在我看来，只有骨灰级的才有资格称之为测试开发。真正的测试开发，基本上已经脱离了测试范畴。当然，所谓的测试技术一定是深铭于心、践于行，只有在这个基础之上，才能更进一步。那么测试开发的工作是什么呢？

一方面是质量保障工作，但不是要求你简单的监督、甚至执行测试，而是建立在熟悉包括自动化、性能、框架设计、数据监控等测试领域和独立的研发、架构能力基础之上的，对于测试过程、测试健康度、效率上的改进能力。这是最重要，听起来还是很虚，对吧？

我们举个例子：如果是一个很小的公司，之前只有功能测试，他们想招一个测试开发来建设他们的自动化、性能、安全测试体系。那么无论是入门级、专业级还是骨灰级的测试开发，都会第一步开始建立相应的测试框架，开启自动化测试、接口测试、性能测试等等，这样大家是没有区别的。但是当我们拥有一个成熟体系之后呢？你是不是还有能力去评估、发现这套体系中可以优化、提升的地方，是不是可以基于数据的上下行通道来衡量当前测试体系的健康度？或者换个方式，现在不再是一个小公司了，而是把你放到京东、阿里、百度，你是不是有能够衡量和提升他们测试效率的能力？

如果你的回答是 YES，那么这就是达到了“骨灰级”的能力。换句话说，真正的测试开发，不是仅仅“实现”某些能力就能满足的了，就像让一个一直不工作的人开始赚钱和让一个年薪千万的人能够达到年薪过亿的差距是一样的。

刚刚说的是第一方面，还好，这还是基于测试的，还在我们可以认知的范畴之内。那接下来的就是流程优化、技术创新和成本降低了。测试技术一直是在不断提升、不断优化的，也许就在大家看这篇文章的过程中，一项新的技术已经问世了，就像曾经涛叔开源了自己比 Hadoop 快至少10倍的大数据平台，就像 Docker 的不断普及应用，一个优秀的测试开发，需要对技术拥有无限的敏感度，并且能够把好的东西、好的思想为己所用，并且在现在的基础之上继续创新。

至于成本，尤其是降低除测试开发团队外所有其他测试部门的成本，我想应该是所有测试开发追求的终极目标。所以，不仅仅是自动化、性能、安全的测试技术，其他一切可以提升我们效率、降低成本的工作都是测试开发需要考虑的。比如：配合测试的小工具的开发、数据统计的解决方案施行等等，一切能够有利于我们在不降低测试质量的前提下减少测试时间或降低非工作时间耗时的工作都可以看作测试开发的贡献。

接下来最后一点，我觉得一个骨灰级的测试开发需要拥有团队建设的能力，阿里的高级测试开发岗位大多都要求： 负责测试专项能力建设，不断提升测试团队的专业度和深入度。虽然说起来容易，但实现起来却很难。如何让每个人在团队中做最适合的工作、发挥最大的能量应该是所有 IT 人面对的最大难题。

这聊了许多测试开发该做什么，那真正的测试开发需要什么样的能力呢？我们可以简单总结一下：

- 扎实的计算机技术基础
- 良好的代码能力
- 掌握测试领域技术：功能、自动化、接口、性能、安全、手机等
- 一定的架构设计能力
- 质量相关的数据体系和数据分析能力，评估测试质量和过程健康度；项目流程、测试流程优化能力
- 技术敏锐度，善于学习、分析新鲜技术和开源项目
- 技术创新能力
- 团队提升和建设能力

这是我简单把想到的列了一下，实际上我觉得就像现在你去问巴菲特怎么才能赚大钱一样，纵然有天价的“巴菲特午餐”，但是没有谁能够告诉你怎么一步登天，没有谁可以复制谁的成功经历，也许当你掌握了上边的大多数能力以后，就会真的摸索出属于自己的骨灰测试开发之路。生活、工作不是做游戏、完成任务，没有到达了什么条件就可以怎么样，一切都在每个人自己的心中、手中，与汝共勉。

## **30 What the hell！测试也要懂架构设计？！**

我曾经 N 次的跟很多测试朋友聊起这个事情：测试是需要懂架构设计的。很多测试的小伙伴都觉得，架构设计是架构师、开发，甚至是项目经理去背书的，关测试什么事儿？更有很多同学直接跟我说：风落啊，我没有想过要做那么高 Level 的测试，我觉得把自动化性能什么的搞搞好就可以了。甚至有跟我说：你说测试要懂代码我都忍了，居然还让我懂架构？！往往大家都觉得测试与架构是面包与牛排的选择，先抓下来面包吃进肚子里的好，至于牛排，等再看看自己有没有那种能力吧。

其实如果倒退到十年，或者是八年之前可能我也有这个想法，但是走过这几年的路，我发现架构设计在某种程度上对于测试来说是非常重要的，如果完全不懂或者只有一知半解的话，往往会发生意料之外的线上问题。我们一起来看一些实际工作中的场景：

**【场景一】**

缓存在我们的系统架构中是非常常见的中间件，一些频繁操作数据库去读写的数据我们可以放到缓存中加速，但是由于缓存命中很低，导致生产上大部分的用户还是直接读取到了数据库中，带来了非常大的压力，甚至是崩溃。这样在我们自己测试的过程中是很难设计测试用例去覆盖的。

**【场景二】**

还说缓存，如果项目代码中对某一个关键 key 值不断的重写，那么这个缓存实例就可能会过载掉，降低了整体的缓存性能。我们在功能测试过程中也是很难复现的。

**【场景三】**

除了缓存，我们现在在系统设计中还经常用到的组件还有队列。目前在各种系统中的异常设计经常用到队列来进行异步处理，一般正常的异步队列处理逻辑是：

发生异常 →（生产者）产生队列消息 →（消费者）获取队列消息 → 异步处理 → 成功消费队列消息 / 异常将消息推回队列

如果在最后一个步骤程序的错误导致异常没有重新推回队列会怎样呢？

**【场景四】**

我们经常会出现数据迁移的状况，有时候甚至会在不同的数据结构中进行转换，那这时我们就需要程序来进行处理了，但是每次要进行转换的数据量不宜过大，比如我们每次处理 5000 条。那在程序处理上我们简单的排序，然后 LIMIT 就可以取到了。于是我们获取数据的方式：

```
SELECT * FROM table LIMIT 0,5000；
SELECT * FROM table LIMIT 50001,10000；
...
```

在正常测试时候，会很正常，不会发现问题。可是如果数据量很大呢？如果超过 1 个亿、10 个亿呢？由于 LIMIT 执行的性能问题就会执行速度越来越慢，直到数据库崩溃。

**【场景五】**

微服务已经是时代的潮流了，但是在微服务开发过程中的循环依赖问题一直是一个需要小心避开的坑。一旦在进行某次大型迭代的时候，出现了 A 依赖 B、B 依赖 C、C 依赖 A 的情况，在测试时自然不会出现问题，但是生产打包、发布的过程中就很容易由于循环依赖导致无法正常进行。

简单的聊了几个场景，这些场景都是源于我在工作中的实际情况，那么到这里你还真的觉得不懂架构也无所谓么？如果完全不懂的话，你没办法想象一个在你的认知里根本不存在不理解的东西究竟是什么样子，这比盲人摸象更加的虚无缥缈。如果你的意识里系统架构都不存在的话，那么你怎么知道架构在什么情况下会出现异常呢？

所以大家可以把自己的技能点大大的往业务能力上招呼，但是一定不要忘记，学点架构知识，还是非常有好处的，可以避免一部分由于设计上带来的问题。也许你觉得这些问题跟测试没关系啊，但是当领导问你：为什么没测出来？可能很难解释清楚了吧。结合上面的种种，我觉得架构的知识反而是我们想把测试甚至是功能测试做到极致必不可少的一点。

从我自己来说，我养成的习惯是：我要接手的系统，我一定要梳理清楚系统应用到的所有组件、数据流转情况、业务的时序图以及上下游的依赖关系。如果有一个新的需求，涉及到这个系统，首先先自己打一个大体设计的腹稿，并且参与研发的设计评审会议，将研发的架构设计与自己的相比较，并思考与之前的架构设计是否有冲突的地方、是否有不合理之处。最后把架构层面上可能出现的异常，比如队列、缓存、数据库、上下游系统都考虑进来，单独设计异常的测试场景。能够在测试阶段覆盖的尽量去覆盖，如果无法覆盖的就需要进行代码 review 和白盒测试来保证代码实现的正确性。

我相信，听起来虽然复杂，但对于每个人来说，并不算是不可能完成的任务。当然，我没有说每个人都要达到架构师的水平，懂未必达，实际上很难达。在上一节中我们在最后说过，一个真正优秀的测试开发需要有架构设计能力，这里的架构设计不仅仅懂就可以了。我在这里多啰嗦两句，无论测试还是开发领域，想要完成一个优秀的架构设计、成为一个架构师不是简单的把现有东西用起来或者填一填坑就可以的。真正的架构设计不仅仅是靠设计，还要靠演进，这要求我们对技术具有前瞻性，是技术的导演而不是演员，更不能是观众。同时要依托自己的技术能力由浅入深的掌握设计模式、微服务、分布式等等，逐步了解、熟悉、融入架构设计之中，让自己的设计不仅仅能能够很好的支撑现在，而且能够合理的应对未来的趋势和变化。

似乎已经开始要跑题到成为一个架构师上面去了，实际上我今天聊的所谓的懂是可以理解。让你跳出现有的架构去从零做一个产品的架构设计当然很难，可是依托了现有成熟的架构设计、丰富的中间件，即便是测试人员，搞清楚所有组件的作用和工作方式，理解现有的架构设计，评估新需求的架构适配，我觉得还是可以 HOLD 住的。

如果再进一步呢？

这也是我一直努力去做的改变。我希望一方面不仅仅是评估即将到来的修改对当前架构的影响，也能够对当前架构的演进贡献出自己的力量，能够以测试这样一个特殊的角度推动架构设计的前进。另外一方面，提升研发的可测试性架构设计。相比前者，后者其实更难做到。

现在可用的轮子越来越多是不争的事实，所以每个架构师、研发人员都希望做出更有深度和创造力的架构和代码设计，但是往往这时候忘记了一个原则：软件越容易测试，测试的成本就会越少，遗留的缺陷也会越少，软件质量也就会越高。所以回到前边的技术，自动化测试、单元测试、TDD 的前置将会为软件系统的可测试性提供更大的保证。当然，这不是某种技术就可以实现的，而是需要团队所有人都能在研发设计的概念阶段就开始关注它的可测试性，考虑到应该如何测试，更多的是一种思维上的变化。

那么聊到这里，你对于测试眼中的架构设计是不是有了新的认识？

## **31 黑科技：有没有一天，AI（人工智能）会取代软件测试**

自从前几年 Alpha Go 的成功出世，惊呆了一片人的眼球。我曾经是个非常非常深度的围棋爱好者，虽然没有吃到过围棋这碗饭，但是很不幸的受过他们的苦。打谱、背定式、不断磨砺，成了早些年围棋人的家常便饭。如果说之前“深蓝”打遍国际象棋无敌手，还没有那么令人震惊的话，那么 Alpha Go 的未逢敌手确实让很多人有些措手不及。不过讲实话，我一直认为 AI 总有一天会在围棋上战胜人类，虽然从没想过会这么快，但是围棋是一种直线算路的概率性算法。在围棋的世界里没有“对”与“错”，所以尽管计算的难度很大、计算的程度很深，但是计算机迟早是可以搞定的。

铺垫了这么多，回到我们的主题。很多同学随着人工智能的热潮到来，不由得有了这样一个想法：未来是不是有可能由 AI取代了所有的测试工具。既然他们可以学习，那他们为什么不能学习我们的测试设计方法，通过需求文档自动生成测试用例，然后自己执行，产出测试报告？这样岂不是很便捷？

在这里，我作为一个“二把刀”的做过一点神经网络算法的过来人跟大家简单聊一下。我不记得我有没有说过，风叔我大学毕业的毕设是：基于神经网络的车牌识别算法。想起来在当时也算是最尖端的高科技了，想想自己都害怕。神经网络的学习跟我们现在很多的学习算法一样，都是通过不断的标本培养、监督学习最终完成某些字符和数字的识别。大家现在熟悉的 OCR 等图像识别技术，大多也都是来源于神经网络，神经网络的结果不是准确的，而是概率的。比如拿到一个车牌的照片，AI 会对车牌进行分割、图像二值化、识别最终得到第一个数字 80% 是 3、15% 是 8、4% 是 5、1% 是其他。OK，那最终的结果输出是 3。

为什么要说到这个？我也并不是想要去教大家神经网络的算法，而是想告诉大家，AI 也好，神经网络也好，都是机器学习，而机器学习永远是一个概率性的东西，无非只是概率的准确性而已。而测试呢，我认为更多的时候测试是一个评委，它是要去评判错与对的，它需要有理有据的告诉开发：你错了，你是怎么错的。所以我觉得机器学习、人工智能谈取代测试，实在是为时尚早。

回到最前面的铺垫，**AI 更适合用于直线算路的概率性算法**。Alpha Go 的原理其实很简单，就是通过自己强大的学习能力和计算能力来分析，下一步走在哪里会比现在的胜率更高，至少持平。而一旦他无法计算出到底下在哪才能比现在胜率更高的时候，就只能像它与李世石第四局对决中的那样，频繁打将输掉。日本围棋界向来有“神之一招”的说法，也许当你下出”神之一招“的时候，对方无论走到哪里都无法扭转局势。当然，很多时候这是可遇而不可求的，所以我们说 AI 是总有一天能够在算路上战胜所有人的，而测试呢？这是一种深度学习的逻辑，它不是计算，而是比计算更高难度的经验和领悟。测试不讲究概率，而且更多时候是背靠概率而行，我们的安全测试、我们的异常测试哪一个不是顶着低概率逆流而上？就像我们的人脸识别，也是基于概率基于算法的。可惜测试没有概率学，更没有稳定的算法，同时，对测试结果的评判也是随着需求的不同而不同。这就如同给了 AI 一个不断变化的世界和规则，如果围棋的规则不再一成不变，如果国际象棋的走法每局都在变化，那么你觉得现在的 AI 有没有胜算？

这么说也有一些过分，AI 其实在某些细节上可以帮助我们的测试，而还远不是取代。比如在一些安全测试场景下，培养 AI 的学习能力，让其能够自动产生攻击载荷、使用 AI 进行一些数据分类等等，这都是可以实现的。人工智能在测试领域应用一定会有，但是不是现在。所以，测试猿/媛们，还请不要将过多的精力投入到这里边来。当然，愿意学习愿意探索，这是一定欢迎的，但是前提是在测试的领域有所得、有所成以后。即便是 AI 的技术有了长足的推动和发展，也是要以基础、以测试技术为依托的。所以学习 Python、学习自然语言、学习机器学习，这都没问题，但是不要认为这就走上了人生巅峰就好。

我也知道，确实有很多一线大公司开始去研究机器学习，而且有了一定的成效，但是恕我直言，更多还是在探索阶段，或者更进一步到了创造商业价值的阶段，距离 AI 概念的完善和完全商业化还有很长的路要走，指望突然掉头来开始增援测试，我觉得可能更多是黄粱一梦。很多目前领先的一些 AI 测试的平台，比如 Test AI、SauceLabs 等等，更多还是基于自动化测试领域的研究，或者是行为驱动的自动化测试、又或是自然语言+自动化测试的组合体。

如果大家真的有意愿开始投入 AI 测试的研究，我觉得首先是要积累完善大量的测试数据，能够将其特征化，而后推导出测试对应计算的算法，才能够看到纯 AI 测试的曙光。在我看来，开头描述的前途光明的 AI 测试之路，倒不如把它用来从需求直接产生更完美的代码上。你觉得呢？

所以，我个人是非常不推崇网络中的很多培训机构、讲师打着人工智能取代测试的方式召唤大家来学习 python、学习机器算法，甚至带领大家把简历修改成熟悉、精通机器学习和神经网络算法，做出了什么什么。在测试圈子里，技术都是相通的，很难有哪一项技术是你研究超越了一个时代的，真到了这个水平也没有必要再完善简历来找工作了。

聊了这么多，AI 取代测试毕竟还是我们头脑中的幻想，如果让我给大家一个忠告的话，我觉得是要脚踏实地，做自己该做的事情，提升自己本身的能力，多实践多探索才是根本。当然，当你有了很强的技术能力，能够 hold 住大部分测试技术的时候，AI测试的大门是一定朝我们敞开的。我很多时候承认，科学技术进步的速度，有时候会远远超过我们的想象，我其实也相信，在未来，总有一天，AI是能够在测试领域有很大作用的。

上述种种皆为一家之言，欢迎大家一起来与风落探讨，思则清辩则明。

## **32 更高更快更强 - 谈精准测试**

上次的 chat 呢，我们聊了聊虽然让大家热血沸腾，但是很难实现的 AI 人工智能测试，这次，我们聊一聊更接地气更容易实现的“**精准测试**”。

相比较 AI 测试，精准测试这套理论已经在很多公司中落地了，在聊它之前，我想先聊聊我自己发明的一个概念：**预精准测试**。

其实所谓的预精准测试大家也在这个专栏中听了N多次了，简单一点说就是结合代码的测试。由于现在我们的互联网行业过于敏捷，迭代的非常频繁，甚至经常出现多个研发同时编写不同功能的情况，这让我们在做回归测试的时候没办法想清楚到底变动的范围有多大。全量回归吧，太耗时，万一你面对的是像淘宝、京东这样的庞然大物根本不可能实现；按照功能周边回归，又担心把圈子画小了有所遗漏，导致线上问题；有时候想着问问开发，往往开发也不太能说的清楚，那怎么办？

在精准测试的概念和思想出现之前，最好的办法是什么？

最好的办法就是：我们通过比较 GIT 代码的版本变化，结合自己对于代码、业务的清晰了解，分析出所修改代码会影响的范围，然后基于这个范围来挑选相应的回归测试用例，通过或自动化测试或手工测试的方式进行回归验证。

这基本可以算是结合我们自身代码能力和业务能力最好的方式了，所以我把它叫做预精准测试。其实我们已经做了精准测试中的部分工作，但是，是人就会有疏忽，你的代码能力再强、业务再熟悉，都难免有所疏漏。所谓千里之堤溃于蚁穴，往往就是不小心的疏漏，带来了严重的生产问题。

所以我们就想，能不能通过技术的手段来解决这样的问题？

于是，精准测试的理念应运而生。概括的来说，精准测试相比较传统测试、我们刚刚的预处理测试，最大的特征就是融入了“技术”。通过技术手段来对程序进行无死角全方位的观测，将代码变更、自动化测试覆盖与代码之间关系、命中的测试用例、通过程序生成海量的原生态测试数据融入一套可持续集成的框架之中，并且将后续的自动化测试过程和结果展示出来。

这样说似乎有一点难以理解，我们来找一个比较现实的精准测试的链路来说明一下。

例如，现在有开发在 Git 上进行了代码更新，那么接下来我们一起看看优秀的精准测试下会发生什么？

STEP 1 ： Git 代码更新

STEP 2 ： 持续集成监控到代码更新，开始启动新一轮精准测试

STEP 3 ： DIFF 比较当前版本与上一版本代码差异，精确到代码行、方法名

STEP 4 ： 结合覆盖率工具，分析和计算精确到每条自动化测试用例覆盖到的代码行、方法

STEP 5 ： 将 3 与 4 步骤中的统计数据进行集合，确认本次版本修改命中的代码行与自动化测试用例

STEP 6 ： 通过代码分析及配置好的测试策略，为每个自动化测试用例生成大量测试数据

STEP 7 ： 自动化测试执行

STEP 8 ： 测试报告与精准测试结果展示

我们可以看出来，之前预精准测试过程中，我们手动进行的很多操作，在这里都通过技术手段得以了实现，并且实现了完全的持续集成和自动化，对于测试人员来说，回归测试显得并不难，只需要对测试结果进行观察和分析，就可以很准确的评估当前版本的影响。

在这里我们聊几个细节：

1. **针对覆盖率的统计**：如果你用过覆盖率统计的一些工具，那你就会知道，静态的将自动化测试与代码关联是不太现实的。所以往往这时候会将历史的结果做一个留存。方式类似于：

   a. 第一次执行，进行覆盖率插桩，全量测试用例自动化，统计出当前每条测试用例覆盖到的代码行和方法，存储到本地文件或数据库。

   b. 后续每次执行都先按照数据库的结果进行统计关联，并且每次精准测试执行完成后再次统计，更新本地文件或数据库（命中执行的更新，未命中的不进行更新）。

   c. 每隔一段时间或每日闲时（凌晨），触发全量自动化执行，重新统计。

   这样，就可以保证在大多数状态下，覆盖率的统计是相对准确的。

2. **结合覆盖率的考量我们大体可以想到**：自动化测试更多以单元测试和接口测试为主，UI 自动化为辅。所以实际上精准测试更多时候应用于后端测试，针对页面的测试，精准测试未必能起到太大的作用。毕竟修改了某个页面会影响的测试用例命中很难评估。

3. **如何生成大量的合理的数据呢？**这里其实我们大约有两种方式：一是通过测试策略，对一些边界值和常用数据进行生成，但是在精准测试下，其实并不常用。第二种就是通过自建的数据工厂，对历史留存的甚至是生产上的一些数据进行清洗加工，使之成为原生态的数据，引入我们的自动化测试执行。

相信我们大家也发现了，这样的精准测试中所需要的技术沉淀、架构设计都是比较宏大的，目前也只有一些一线互联网公司才开始关注这个领域，因为他们对于回归测试、代码修改影响评估的需求最高。同时，我们也发现了，完善的精准测试体系不仅仅对于测试有着十分重要的意义，同时也对开发有着很大的帮助。比如，我可能要去修改一部分代码，但是我并不清楚修改这部分代码会影响哪些场景，那么只要我在 Git 轻轻的进行提交，通过精准测试的结果马上可以分析出相关联的功能点，也让后续开发和修改过程有了更大的底气和更全面的考虑。

除了对技术、架构的要求，精准测试的理念同样要求我们有比较完善和全面覆盖的自动化测试用例。否则仅仅基于手动，只做上面精准过程的前半部分，那么效果就大打折扣了。

一套完整的精准测试体系，带来的效果是显而易见的。它能够最大程度的减少由于测试人员人为评估不足带来的项目风险，也能够大大减少后期回归测试过程中的成本，还大幅度的帮助我们提高代码质量，与此同时，也能让我们更加深入的去了解被测系统和架构。

不幸的是，由于精准测试的特殊性，很难有某些精准测试的体系是可以完美适应各种公司和代码场景的，所以目前也没有非常完善的精准测试开源框架。真的想要深入去做精准测试，仅仅这样一篇文章当然还是不够的，有兴趣的同学可以更多参考下腾讯的精准测试设计。也可以把技术分块分步骤的着手研究，也许下一个留言让我到他的开源框架项目中 star 的就是你呢？

## **33 打破传统壁垒：容器化与TestOps**

记得在写 AI 测试的时候，刚好有老友到访，老友很诧异：你不是一向支持新技术么，怎么会对一个人工智能这么大的反应？我仔细想了一下，其实我并不是对新技术或者对人工智能有什么不好的情绪，毕竟再智能我也肯定不至于先抢了我的饭碗，大约让我非常有情绪的是测试人或者一些机构对于人工智能的盲目吹捧，觉得测试行业还是需要有人去泼一泼冷水，让大家走回到原本的路线上来。

但是，我对于新技术新事物，其实非但不排斥，反而是希望能够去探索去学习，择其善者而从之，其不善者而改之。所以今天我的主题是：打破传统壁垒。

传统的开发、测试、运维都是各司其职的，但是发现难免发生交集，而且这个交集还很重要，最明显的就是环境。我们就从环境聊起，像曾经我们有超过四套环境，包括归属于开发的 dev 环境，属于测试的 test 环境和属于运维的灰度和生产环境，再加上增加的性能环境、联调环境，多个环境由于环境配置、数据库等等的不同引发了很多问题。印象比较深刻的就是几个方面：

1. 重复测试：每个环境都需要重新进行回归测试才能够放心部署运行
2. 在 A 环境中没问题的程序切换到 B 环境就不正常了
3. 由于需要配置的环境太多，复杂度太高，有了 BUG 也让开发人员难以复现和排查

于是 Docker 出现了。

```
<img src="assets/31-1.jpg" width="40%"  align="left"/>
```

Docker 到底是什么我不想在这里跟大家细细普及，我们主要聊聊 Docker 对于测试的促进作用：

- **环境的统一**：在 Docker 下我们不用再纠结多套环境运维、管理的问题，也更加不用考虑不同环境之间的差异。 Docker 完全可以快速的部署一套清洁的环境，供我们进行各项软件生命周期活动。
- **降低配置的压力**：很多时候应用会依赖于很多配置，比如数据库、防火墙、队列、缓存等等，Docker 呢，就可以通过打包镜像，将这些配置一起打包到镜像中，也进一步保证了环境的统一。
- **资源利用**：由于容器不需要进行硬件模拟、也不需要运行完整的操作系统，所以容器的执行速度、内存消耗都要比虚拟机更高效，性能也更好。
- **问题的复现**：传统的环境配置里，生产上的问题往往很难在测试环境重现，让我们在 BUG 复现上会耽误太多的时间，更难定位问题出现的原因。而 Docker 的特殊性就在于可以快递通过镜像复制出现问题的场景，更快速的定位分析问题。同样的，在对于测试与开发的沟通上亦是如此。
- **持续集成的支持**：传统的持续集成还是停留在应用方向，而配合 Docker，通过 Docerfile 来进行镜像构建，效果更好。
- **环境的迁移**：我们经常遇到某些环境的迁移，比如机房的迁移、平台的迁移等等。传统情况下我们的部署、迁移和迁移后的测试是一个非常大的工程，而有了 Docker，基于 Docker 的兼容性，可以很轻松的进行迁移。如果再辅助后边要聊的 Devops 或者 Testops，就更加快捷和安全了。

所以，Docker 这项技术飞快的被所有的测试开发运维所接受，而配合上我们原本就有的自动化测试和精准测试，这让我们的测试体系更加立体化，更有效率。

在容器化的基础上，运维的思路们也开始发生了变化。在传统方式中，开发和运维当然是各行其是的，所以也经常会阻碍向客户交付高质量的应用，这种方式某种程度上已经没办法适应高速发展和变化的互联网时代。而 DevOps 旨在消除开发和运维之间的这种不协调，加快交付速度，同时也要保证质量。DevOps 的目的就在于消除开发约束，实现自动化，并且在开发与运维之间创造反馈机制。用维基百科的解释就是：

> DevOps（英文 Development 和 Operations 的组合）是一组过程、方法与系统的统称，用于促进开发（应用程序 / 软件工程）、技术运营和质量保障（QA）部门之间的沟通、协作与整合。它的出现是由于软件行业日益清晰地认识到：为了按时交付软件产品和服务，开发和运营工作必须紧密合作。

![图片描述](http://img.mukewang.com/5db65f460001ae6806510526.jpg)
最初的 DevOps 目的就是解决研发、测试、运维之间的那些灰度地带的事情。换句话说在我的理解中，DevOps 就是用一系列的自动化工具改进测试、研发和运维之间的工作流程，保证能够快速、持续又安全的部署。随着微服务时代的到来，指望运维通过手动去部署成百甚至上千的微服务，不现实也不安全。

当然，DevOps 不是万能的，它可以解决流程上的问题，但是不能解决质量细节的问题，所以，以质量为核心的 TestOps 就产生了。由于 TestOps 实际上是有 DevOps 衍生之下的产物，所以也是与 DevOps 成对存在，共同作用改进我们的整体架构。

![图片描述](http://img.mukewang.com/5db65f600001844a06200544.jpg)
TestOps 同样是高度依赖自动化的，在理想的状态下，开发提交代码后，系统开始自动触发静态检查体系，静态检查通过后，开始完成自动的单元测试，确定所有单元测试用例通过则自动打包发布到测试平台，否则将错误信息返回通知相关人员。接下来测试平台发布完成后，测试平台会进行接口及 UI 的自动化，如果都正常通过生成测试报告，如果自动化测试足够完善的话，可以直接接入到 DevOps 开始进行快速部署。

如此看来，TestOps 更多的就是对于测试在整个生命周期中的工作方式的指导，也更加强调自动化测试。为什么要这么依赖自动化呢？我们举个例子，有时候我们生产上出现了一个问题，已经造成了损失，我们不可能直接把服务下线不让客户使用，更不可能放任损失继续扩大。所以我们在第一时间定位问题，紧急修改完成后，很难再给测试两个小时、三个小时的时间去回归了，那么怎样保证这样的紧急修改不会影响其他功能呢？这就是 TestOps 的意义，尽管有时候我们为了抢出 1 个小时的时间需要完善 10 个小时的自动化代码，但是在互联网敏捷时代，这是必须而且还非常重要的。

那么 DevOps 与 TestOps 的关系就是：

DevOps 推动整个测试和运维团队统一整个研发流程，帮助团队更敏捷的提交产品。 TestOps 站在专业的测试角度推动开发和运维一起辅助进行，保证质量。TestOps 和 DevOps 形成了一个完整的持续集成和持续交付体系。

这是一个大的方向，我没有介绍一些技术细节、工具应用，不然可能单单这里就要连载起几个月了，但是核心我们发现了。而对于测试来说，提升自己的综合能力才是最重要的。在这个时代，编程能力、单元测试、接口 UI 自动化、运维技术都要学，不仅仅有炒锅、原料、调味，还要会洗菜、切菜、烹饪，这样才能够把一盘好菜端上桌。不要想一下子做出满汉全席，从小处做起，持续优化。忘记了在哪里看过这么一句话，我觉得很适合作为这一趴的结束语：仰望星空，脚踏实地。

# **第10章 形色职场**

## **34 不打无准备之仗：如何备战面试**

俗话说的好，金三银四、金五银六、金九银十，反正我觉得在互联网这样流动性极大的行业里，时时刻刻都是跳槽季，做为测试人来说，该何去何从？心里有没有底？想要跳槽提前准备什么？面试过程中注意什么？我们分两趴一起来跟大家聊一聊 “面试的那些事 “。这一趴我们先来说说测试的准备工作。

先来谈简历。简历是在求职过程中迈出的第一步，这是一个宣传自己的机会。这里我们得先想明白两件事：

第一：简历是给谁看的？
第二：简历的最终目的是什么？

不知道大家心里有没有答案，事实上，90% 的情况下简历是首先给 HR 去看的，后边在面试过程中会拿到面试负责人的手上；再有，真正意义上简历的最终目的是带来一个面试机会，只有有了机会，才能够真正全方面的展现我们自己的能力，毕竟” 纸上得来终觉浅 “。

有了这样的认识，我也观察过一线大公司 HR 筛选简历的工作状态，由于大公司的岗位放出去会得到从猎头、招聘网站、公司自身人才库的大量简历，大约每份简历都只会被打开看半分钟到一分钟，来评判是否基本符合想要的岗位，并不会认真去品味简历中的内涵。为此，我也跟很多的猎头和 HR 聊过，他们更多关注的不是项目情况，而是你的技能是否匹配、学历学校的情况、过往公司的情况。

所以我们可以把简历再拆分一下：前半段关于教育、个人情况、技能特长这些是写给 HR 们看的，而项目经历这些是写给技术面的面试官去看的。

OK，了解到这些我们得出一个结论：HR 阅读简历的时间短，同时重点放在前半段，目的是看当前简历是否符合待招聘岗位的基本要求。那么简历写的很长很长的同学，自然无法得到 HR 的青睐。我见过有的面试者的简历，长达 7 页，事无巨细，我很难一下子看出来他的能力到底是什么，毕竟，我不是通过简历来录取你，只是决定要不要叫你来面试一下；还有的简历中，把自己的信息写的很详细，比如身高、体重、家人等等，然而，这些无论是 HR 还是技术面试官都并不 Care。

我给大家的建议是：**除非申请的是高级管理岗，否则简历不要超过两页；** 简历简要而全面的表达，在简历的前半页有效的表达自己的优点和能力；准备你的技能与岗位要求匹配列表，并突出这些技能在简历第一页；不要罗列技能，而是将自己擅长的并且匹配工作岗位的放在前边。最后，为了简历让人看得开心，注意一下格式，不要用表格。

另外，多说一句：不要觉得很有创意的去准备视频或者动画简历。也许若干年前，会被人觉得新颖的看完，但是现在，别人很难有时间去认真看你的视频动画，所以小聪明还是要收一收的。**当然，如果你有非常拿的出手的成绩，比如出版过什么书籍、Git 上有你的什么开源框架倒是都可以不吝啬的写进去，可以增色很多。**

刚刚说了简历的前半段是为了 HR 而准备的，那么简历的关于项目经验的部分就是主要给面试官所准备的了，一般来说，面试过程中至少有三分之一的问题是从你的经验经历中衍生而来的。这部分应该如何去写呢？

比较通用的编写方式是依赖于”STAR 法则 “，STAR 法则，是 Situation、Task、Action、Result 的缩写，具体含义是:

- Situation: 情境。项目的背景。
- Task: 任务。你在项目中负责什么。
- Action: 行动。你在项目中做了什么，怎么做的。
- Result: 结果。

由于这个法则被广泛应用于面试问题的回答，尽管我们还在写简历阶段，但是，写简历时能把面试的问题就想好了，会使自己更加主动和自信。同时，也更容易被面试官理解和认识你的价值。

说到这里，其实简历就差不多了，但是大家要注意一下，简历上的任何一个点、一句话都有可能成为日后面试时的重点提问对象，我就是这样的面试官 O (∩_∩) O **所以说，不是说简历上写的越牛越好**，吹破天都没关系，要想到今后，在面试中，你所写的经历万一被面试官 diss，你真的能回答得流利，顺畅，且能通过这段经历，证明自己正是适合这个职位的人吗？**所以最后一个忠告，就是简历里可以对自己的经历略加修饰，但一定要在自己的能力范围之内，万不可过度夸大甚至编造**，毕竟面试官和越来越成熟的背调都不是傻子。

说完了简历，还要说说准备。现在的大小公司对于面试的要求都很高，我也丝毫不否认” 面试造火箭，工作拧螺丝 “现象的存在，但是测试技术的提升却是不争的事实。而测试领域，需要准备的东西也会很多，比较常用的一些技术，像接口测试、自动化测试、性能测试等等这些我觉得几乎没有什么准备的空间，会就是会，有经验的面试官不会因为你提前准备了几天就把你当作大牛，同样，即便巧合的蒙混过关，也很可能在工作中无法顺利应用。但是除了测试技术，一些计算机基础还是有必要准备下的，尤其一些平时几乎不太常用、用时候也可以快速百度到的、但是又非常容易被问到的内容。

从几个角度来准备下：

**数据库**，一般的增删查改自不必说，稍微复杂一点的关联、多表查询、分组、排序这些也要能够掌握，如果遇到了对数据库要求比较高的公司或岗位，那还要对存储过程、数据库设计等又一定的了解。

**语言能力**。这里的语言能力是说编程语言，对于一般的功能测试岗位那一些基本的代码理解、数据类型、i++ 于 ++i 区别等一些常见的程序问题就基本可以 hold 住，不需要太精。但如果是要面试一些测试开发、自动化测试、性能测试等岗位会经常涉及到复杂排序、算法、框架细节都高级一点的东西。我曾经有个学员，为了面试上阿里一个测试专家的岗位，裸辞几个月为了完善自己在代码和算法方面的能力，不得不说，测试人在这方面确实还是有天然缺失的。

**Linux**，其实我在面试过程中是不爱问这种 Linux 命令之类的问题的，我觉得既没有针对性也不够专业，但是架不住确实有不少面试官喜欢在此发问，所以准备一下没坏处。而针对于 Shell 编程的东西，只要有人敢往简历上写，那我是一定会问的，并且会以场景的方式去发问，类似于文件拆分对比方案啊等等。

**软件的测试基础内容**，我就不说了，流程啊、测试方法啊、缺陷管理等等。

**工具方面**，一些常用的工具还是需要具体了解一下的，当然，完全没有用过就可以直接说出来，在我看来说没用过并不减分，除了岗位 JD 上一定要求的一些工具和技术。

**网络知识**，其实有一点点奇怪，安全测试可能还需要一丢丢网络，而测试自身来说并没有那么大的需求，不过不排除有些面试官真的会问你：三次握手、DNC 解析啊，总之还是为防万一，可以准备下。

再加上我们在简历中涉及的内容，就像前边说的，简历的一切都可能成为面试的问题，所以多准备一下是不无裨益的。

聊了简历、聊了面试准备，那么下一趴，我们好好聊聊面试过程里的那些故事。

## **35 面试技巧与经验**

从自我介绍开始的面试历程。

在多年以前，我做为一面面试官，参与了一场让我记忆深刻的面试。当我问出我的第一个问题的时候：请简短的介绍一下自己。对方的回答是：我不都在简历里写过了么，就不用自我介绍了吧。并且当时用一种鄙夷的眼神盯着我，意思像是在说：你丫是不是不认识字。

我不知道是这哥们心大，还是我长得比他高、比他帅，引发了他的嫉妒和对抗之心，后边我大概只问了一两个无关紧要的问题就让他离开了，毕竟我自己的修养有点不允许我直接让他滚出去。

OK，我的意思是，不要认为一份完美的简历、或帅气或美丽的装备就能够让你拥有一个职位，面试过程一向是从头再来，让你重新推销自己。所以，自我介绍永远是我们面试过程中的第一个问题。

想来大家也参加过不少场的面试，那么又要让大家回答一个问题了：简历都写过那么多内容了，为什么还要让面试者重复进行自我介绍？

我在刚毕业的时候，曾经思想简单的认为，之所以要做自我介绍，是因为除了 HR 以外的面试官可能都还没有时间认真看简历，然而实际上并不是这样。面试官希望得到什么信息或者考察你什么能力呢？

- 能力的突出点是否符合职位需求
- 擅长哪方面的事情，技术还是管理
- 性格上有什么优势
- 语言表达能力如何，逻辑能力如何，是不是自信流畅
- 有哪些成就和贡献
- 是否能够客观评价自己
- 压力下的表现

所以，仅仅简历上的内容是远远不够的，面试官希望能够更全面的了解你，包括你的表达能力、条理性和你对自己的总结，当然，顺便也看一下你的表达与简历上是否有出入。所以可以围绕上边几点，但是不要照搬简历上的内容。如果有工作经验的同学，除非你的学校非常有优势，不然其实也没有提的必要。我这里有一个简单的自我介绍的例子：

> 面试官您好，我叫 XXX，来自于 XXX。做软件测试工作也有两年了。在期间也做了不少的项目，也积累了不少的测试经验，能够独立完成软件测试的测试工作，主要做过功能测试、app 专项测试和接口测试方面的工作。对于 linux、数据库、appium、 LoadRunner 的应用都比较熟悉。也用 LoadRunner 做过一些性能测试，最近一段时间也做了自动化测试，主要是用的 selenium 框架实现的，我平常喜欢看看书，有的时候也喜欢打打游戏，这个是我一个简单的自我介绍，您看，我这边还需要做什么补充吗？

当然，除了文字上的组织，要保证表达的内容清晰简洁，不要说话时含糊不清，声音细微。面试就是面试，从介绍就要开始自信起来，没什么可害羞的。

还有的同学，虽然平时表达能力或许不错，但是有时会过于紧张，又或者过于缺乏热情。我之前面试过这样一个小男生，本来在跟我面试的过程中总体表现很好，但是后边遇到 HR 的时候，由于 HR 是个漂亮女孩，所以开始紧张、结巴、不敢与对方眼神沟通。这反而会让面试官觉得你不够自信。可惜的是，我面试过的女孩里却没有看到我结巴的，估计还是长得太不够帅气了。

所以，如果可能的话，面试前准备一个自我介绍的大纲，再发挥。能不背的话，还是不背的好，背的时候会过于明显。



### 描述自己的项目经历

一般情况下，描述自己在项目中的价值是很重要的一环。由于每个面试官可能一天之中面试了太多的人，所以更多时候希望能够尽量简明、精确的命中一些他们的要点。其实这个要点，我已经在写简历时候跟大家聊过了，你完全可以基于 STAR 的原则再描述一下：项目的背景如何，你负责哪部分内容，做了什么，做的如何，结果怎样。如果可以的话，可以补充上你在项目中遇到了哪些困难，你如何解决的。最后补充上项目之后自己的总结、复盘和反思。这样不仅仅让面试官感到了你的结构化描述，同时还展示了自己发现问题、解决问题的能力。

这样比起很多面试时候一定要等到面试官发问才回答的方式，要给人印象好的多。老实说，我对于挤牙膏式面试是特别无感的，一旦面试者没有主动沟通交流的欲望，那我去引导你发言的欲望也会越来越低，最终草草结束。



### 特殊的工作经历

很多同学在简历中会有一些特殊的地方，比如频繁跳槽、空窗期等。

我们先来说频繁跳槽的情况，这是最难处理的。我先表明态度是，建议大家在每次跳槽前一定要想清楚，不要说哪个公司给了稍高一点的薪水或者哪里有做的不如意的地方就一定要跳槽。成年人的世界还是有很多解决问题的方法，一拍两散未必是最合适的解决方式。

当然，在这里我们不聊如何处理矛盾，如果你频繁跳槽，一定要给出强有力的理由。千万不要说钱不够、团队气氛差、离家远、与领导不和。这些理由可以作为某一次的理由，但频繁用这些理由只能说明你自身有问题，或者不够稳定。

事实上我也不太知道如何解决频繁跳槽的问题，我自己也从来没有得到过让我满意的答复，唯一一次让我能够接受的，是这位面试者在三个月内连续跳槽第三次，他这么回答我：

> 之前因为薪资问题在 3 月份跳槽到 A 公司，各方面都比较满意，但是团队老大跟我的理念不太一致，又非常强势，不允许下边有自己的想法，一定要按照他的方式做，于是一个月后我离职跳槽到了 B 公司，没想到半个月后 A 公司的老大也跳槽过来，并且再次成了我的直属上司。经过两个月的努力，仍然没有改变他的思想，所以只好再换一个环境。

我相信这样的巧合不会在每一个人身上发生，所以跳槽时请尽量三思而后行。如果在一个公司工作时间非常非常短，不足一个月，那可以在简历上不展示这份工作的痕迹。不过不建议把正式工作了一段时间的公司就职经历合并，毕竟测试的圈子很小，你的经历总有一天会不经意的被发现。

另外一点就是空窗。很多人喜欢辞职以后来一场说走就走的旅行，或者休息一段时间。我也建议如是，大家的这段时间更可以不仅仅用来休息，更可以用来总结、反思、提升自己。这样，你在回答类似问题时候就可以说：

> 我用了一段时间来总结这份工作过程，发现自己在处理一些事情上仍有不足的地方，同时自身技术还有待提高，这段时间我没有着急找工作，而是学习了 XXX，提升了自己的综合素质和竞争力，希望能够获得更有挑战的职位。

这样的解释会不会好很多？



### 令人胆战心惊的面试问题

技术方面的问题我想还是通过技术的方式解决，就像上一趴我们聊过的，在完善自己能力的基础之上做好完全的准备，应对各种技术问题。这里边没有什么话术可以帮助到你，技术的东西，会就是会，不会就是不会，没有太多可以说的。

非技术类的问题，我们倒是可以多说几句，我在这里分几个典型的类型吧：

**项目深度的问题**

很多时候仅仅介绍了一下项目还不够，可能面试官会问一些更深层次的问题。比如：

*你们项目正在采用的架构？用到了哪些组件？采用这样架构的原因？*

对于有经验的测试员，会涉及上述问题。面试官旨在观察你在项目过程中对开发的关注、对项目的思考、理解和学习能力。

**虚拟类问题**

这类问题是看你对于实际问题，更多时候是面对一些负面情绪的解决方法。比如：

*如果项目需求频繁变更你要如何适应？如果团队使用的工具与你自己擅长的不同你会如何去做？你与开发人员发生了冲突要如何解决？如果项目压力大时间紧，你觉得应该如何去做？*

这类问题我觉得可以从自己真实经历出发，不用为了讨好而特意去说什么。这也避免了真正工作过程中的事与愿违，有时候的一些假设很可能是当前公司的现状，对方也要根据你的回答来看看是否适合这个岗位。

**经历类问题**

这种就是带有压力性的问你一些你不愿回答的问题。例如：

*你在项目中有没有犯过什么错误？你印象最深的一次失败和挫折？你之前公司同事关系不错、待遇也不差，为什么要离职？*

这类问题未必是想要真的难为你，而仅仅是一种问话的方式，所以可以把心中的不舒服先放到一边，静下心来说明回答一下问题。比如：要你说错误和失败，你就先聊错误和失败，然后再说说你自己之后的改进，改进以后的结果，这样就自然的转危为安了。

我记得很多年前我在一个公司面试的时候，遇上这样一个面试官，他问我：*你是不是觉得自己做了很多公开课，还出了本书就特别牛 B 啊？我也就是不想出，不然早就出了。*

这一定不是什么压力面试了，明显是有所针对，我当时也是年轻气盛，所以直接开怼：我自己牛 B 不牛 B 我没这个感觉，但是请你先出本书来看看。接着甩脸子走了。我想如果让我现在再来一次的话，我……

还会这么做。毕竟即便和声细语，面试时候就不给面子的面试官，未来又是你的顶头上司，想必也很难舒服，这样的公司不如不来。既幸运也不幸的是，两年后这家公司就倒闭了，没有给我让他再次 “高攀不起” 的机会。

所以一般所谓的压力面试，都还是客气的去追问一些你不想回答的内容。纯为了找茬的问题，分辨出来就没必要好好跟他说话了。当然，我想也许再过十年，我的选择也会不一样了也不一定。

**其他问题**

比较常见的问题是职业规划方面的问题。主要也是想了解你是否会不稳定，是否有清晰的未来认知。你可以根据自己的实际情况和想法，回答自己是希望在技术架构方向提升，还是在管理方向发挥能力。

再有比较尴尬的问题就是问女生，什么时候结婚？什么时候要孩子？大多这也是考虑稳定性的问题，怕你一来就开始休假。当然，这种情况有时候很难说明白。有时候夸下的海口很可能成为自己的绊脚石，反而阻碍了自己的发展。我觉得不如换个角度来看，我比较欣赏的一个回答是一个女孩跟我的一个 HR 说的：

*你看咱们都是女孩，现在这个行业对女孩还是不太友好，没结婚问什么时候结婚，结婚了问什么时候要小孩，有了一个问准不准备要二胎，有了俩又得问那还有没有精力工作。我觉得其实男孩也一样，天天抽烟喝酒打球，这受伤风险可比我们女孩生一次两次孩子的大多了。*

原话其实我也记不太清了，但是大体是这个意思，当时朋友学给我听的时候惟妙惟肖，还表示了对这个女孩反应能力的佩服。

有些问题是我比较喜欢问的，比如：你印象最深的一个 BUG？或者从手边看到一部手机、一个遥控器直接要面试者根据这些手边的内容即兴来设计一下简单的测试用例和思考方向。这些问题非常开放性，** 其实我没有什么真的要获得的，只是透过这些来看你的组织能力、应变能力以及你自身的技术底蕴。** 不要回答没什么印象深刻的 BUG，我每次收到这样的回答这个面试者的分数就会在我心中开始 “-1”。



### 面试的最后一问

99% 的面试最后一个问题都是：

你还有什么问题么？

我不推荐开口问薪资的，更不推荐说没有问题了。这个问题的答案加分不容易，但是减分却很简单。虽然很开放式，但并不简单。我们一起来看几个我认为可行的回答方式：

1. 关于入职后的工作、后续学习计划。

   更偏向加分的回答方式，希望让面试官看到你的进取心和学习欲望，在自己觉得面试结果可能不太好，但是还能争取的情况下一种无奈加分回答。

2. 您觉得我面试表现怎么样？

   这是我在一个面试者中学到的，而且我还觉得是很不错又直接的回答方式。如果觉得自己面试的还可以，大可以用随意、开玩笑的方式跟面试者聊一下，如果真有表现不好的地方，别人的指出也或许能够给你一些帮助。

3. 能不能参观下工作环境？

   这是我最喜欢的回答方式。既有上边问面试表现问题的作用，也更加委婉，不会太令双方尴尬。一般情况下如果愿意带你转转的话，那么基本上这轮面试通过的概率比较大，如果找个理由推辞的话，那一半以上的可能就是对面试过程还不太满意。

好啦，不知不觉聊了很多，也还是帮大家看看面试过程中的一些套路，希望大家能能够在面试过程中见招拆招，拿下心仪的 offer！

## **36 外包？创业公司？互联网？ 向左走向右走**

除了面试的问题，我想大约能够排到前列的疑问就是 offer 比较了。无论是应届生还是有经验的老测试人，找工作或跳槽的时候都面临一个同样的问题：到底去什么样的公司更好？

之所以起这样一个题目也是从一个学生的问题开始的，我觉得这个场景特别有代表性，所以特意拿出来聊一下：他几乎同时的拿到了一个对美的外包 offer、一个小型创业公司的 offer 和另一家互联网公司拼多多的 offer。没有 offer ，有没有的烦恼，offer 多也有多的烦躁，他反复跟我聊这几个点：

1. 外包薪资最高，但是可以预见的是：加班不少，而且不受重视，客户才是爷爷。
2. 创业公司目前前途未卜，但是愿意给一个技术管理岗位，岗位最高，薪资虽然不高，但是有股权。
3. 拼多多的薪水中等，但是福利最好，也最稳健，但是岗位很低，只是普通的测试工程师。

如果这道选择题摆在你的面前，你会作何选择？

我没有替别人做决定的习惯和爱好，所以我更愿意跟他分析这每个其中的利与弊：



### 外包的职位

首先，外包的职位首先要考虑是外包什么样的公司，如果是很大型的公司与对方企业的正式人员配合工作，那或许可以学到一些东西，比如阿里的外包，虽然很多权限不对外包开放，但是一些思维、工作方式和设计模式还是一定可以对你自己有所帮助的。同样的，弊端就是你不太可能接触一些核心的内容，仅仅负责一些底层的工作。

如果不是这样的大公司外包，那就很有可能是做一些项目外包。我在毕业后不久做过一份对美外包的工作，老实说，回忆并不美好，因为其实不需要太多太强的技术就可以胜任，同时很多时候一人身兼多职，有非常多的工作。从我自己来说，曾经在一个项目里，我既做产品经理，又做开发，同时还去测试自己的代码，经常加班到深夜。但是实际上我觉得却是我自己提升最快的一个阶段，因为身兼多职，所以时间有限，开始不断探索各种能够提升工作效率的方式；因为跟别人打交道的机会很多，所以也无形提升了自己的沟通交流能力；因为尝试了很多自己可能从未想象的职位，所以更多时候提高了自己的眼界。



### 创业公司

再来，说说创业公司，创业公司一般来说都会有一份未必很高的薪水加上期权，当然也有一部分创业公司纯以高薪诱惑没有期权。我们分开来说，先说后者。仅仅有高薪，但是没有更好的激励措施，只有两种可能，一种是创始人没有更开阔的眼界，还不知道如何拉拢团队；另外一种则是对于自己的公司和发展方向非常有信心，不愿意分享自己的股权。不管出于哪一种，都证明对方并没有愿意把你绑上他的战车，所以仅就薪水和工作内容来评判就好。

另外一种情况就是，薪水 + 岗位 + 期权的模式。当然，现在的期权也并不值钱，你要做的也就是拿你的青春赌明天。所以我建议拿到这样的 offer 可以好好分析一下：

一看创始人的背景和履历是否足够强大。在创业公司里，创始人几乎决定了公司的未来。一个或许有背景或许有名企的背景，又或者毕业于某所国外知名高校（当然，前提你确认学历确实真实），这意味着他有着更好的朋友圈和人脉，也有着更大的成功可能。又或许虽然创始人背景并不突出，但有着非同一般的人格魅力（参见马爸爸），也会比普通人有着更大的成功机会。

二看创业型公司的发展方向。如果是跟随型的公司，别人做什么共享单车做火了，我们就开始做共享滑板车、共享三轮车，没有自己的想法，这样的公司一般是没有太大的发展的。毕竟每个行业里第一个吃螃蟹的人虽然有可能成为别人的垫脚石，但是一旦成功也会拿到更大的利益。再有部分创业公司，并不是做产品，而是偏向外包类型的项目，那么这就不用把它放在这一类里边了，可以向上参考外包公司。

三是看公司的现金流状况，或者更简单一点，就看对方的融资情况。如果可以很快的有天使轮、A 轮意向，证明行业和创始人都是被看好的，也更加容易成功。

除了看公司，也当然更要看自己。**创业公司的好处我觉得最主要在于可以非常容易的开展自己的想法。** 无论你想做自动化、性能，不管是想搭建框架还是推行 TestOps，空间是非常大的。毕竟在一片空地上盖一个别墅总要比还要拆一片平房才能盖起来更容易的多。



### 线互联网公司

最后聊聊一线互联网等大公司。这一般都是居中的选择。薪水可能不是最高，但是比上不足比下有余；职位不是最理想，但是也还可以接受。大公司的好处是什么呢？**我觉得就是有比较成体系的解决方案等待你去了解、去学习、去挖掘，同时也会有更多更完善的培训体系，帮助你完善自我的能力，也会有更多的大神可以请教，弥补你自身的不足。** 去大公司就是站在巨人的肩膀上，以后跳槽时候也会有光环加成。

简单分析了一下，而我与这个同学这段话的最后一句是：你现在在这份工作里有什么目标？最主要想要做什么？

他回答：想多学习，多积累。

这就是答案了。如果让我给出更贴切一点的建议的话，我会认为：

如果单纯想要一份高薪，那么选薪水最高的，没什么可以说的；

如果你刚刚毕业，渴望去学习，提升自己的能力，那么大公司是你不二的选择；

如果你可能在一个大中型公司学习了一段时间，急需要做一些独当一面的工作，锻炼磨砺自己，外包公司会是一块很好的试金石；

如果你工作了一段时间，但是自觉没学到太多东西，对于测试的理解也更多在点点点，我觉得大公司尤其是互联网公司是你一个新的起点；

如果你有着丰富的经验和不俗的能力，但是苦于自己的理念在公司无法得到很好的贯彻；又或者你做技术做了很多年，很需要找一个机会转管理；更或者你并不在乎钱，更愿意去奋斗一份属于自己的事业，那么一个合适的创业公司将是你改变自己、改变世界的转折点。

所以，一切都在于你想要什么。或者说，你更看重的是什么。

不要说我既想要高薪，又想要稳定，还想未来获得高收益，甚至还想轻松一点。如果真有这么好的工作，麻烦也通知我一下。

或者有另一个故事很适合这个选择。当你分析了利害以后，那么试着做三个签，分别对应 1、2、3。抽一次，打开它，如果你还想再抽一次的话，那么你就懂了自己的选择了。

最后的最后，做为这次 chat 的结束，我想说，没有十全十美的工作。我认识的朋友中，既有刚刚工作的学生 Plus，也有辛勤奋斗多年的技术高手，更有做到高层的管理者，甚至也有撸起袖子揭竿而起自谋生路的老板，无论是谁，坐下来，几杯酒，口中永远都有无奈和吐槽。

没有什么选择是最好的，我也曾经错过。也许现在的你会后悔当初曾经错过的那辆法拉利，但是再来一次，在那个你饿的不行的夜里，你还是会在法拉利和煎饼果子之中选择后者。好吧，我是天津人，我为煎饼果子代言。

## **37 职业倦怠与技术停滞**

这次想跟大伙聊聊心理。

首先，我很肯定我不是专业的，最多在高中时候听过几节心理课程，记得当时做过一个职业测评，说我自己是红色性格，适合做艺术家，然而现在… 咳咳，有点跑题，今天还是跟大家聊聊工作上的一些心理。

近来吧，很多小伙伴都跟我说：最初开始一份工作时，觉得工作很有趣，做起来还挺有劲的。时间一长，发现工作就不像自己想的那样了，会烦躁，会没有耐心。而更多的人很单纯的就是：

我好烦，好焦虑，我不想去工作。

我不知道是不是所有人都正在处于或者曾经有过这种感觉。在这种情绪的感染下，大家会开始对工作丧失热情，情绪烦躁，容易发怒，工作态度消极，对自己手头的工作越来越没耐心，甚至恨不得把键盘给扔下楼，最后开始准备跳槽，更有严重的，会觉得测试甚至软件这个行业没太大意思，准备转行。

这样的抱怨不仅仅来自那些工资不高的小公司，互联网等大公司的高薪同学们亦然，甚至比重更大。你说好好的一份工作，怎么就越干越没意思了呢？

因为我自己也时不时的沉浸在这种状态下，所以总结了一下我和我身边的小伙伴们之所以产生这样情绪的原因，主要有这么几种情况：

1. 无休止的加班，不知道苦日子什么时候才结束。
2. 手头的工作过多，弦崩的非常紧。
3. 非常大的项目比如 618、双十一上线的前后。
4. 持续一段时间做重复工作。

所以总结下来呢，要不就是因为工作压力过大、要不就是因为精力消耗超支、或者因为重复工作没有提升的焦虑。

还有一种情况，就是今天 chat 的第二个名词：**技术停滞。** 这可能不是由于这个时代的技术所限，实际上新技术层出不穷，而往往是自己的问题。自身的积累或者是技术提升上到达了瓶颈，比如当前的技术框架有余、平台不足，向前看总有种看不到希望的感觉。这也会造成自己的烦躁。

面对着这些很容易发生的状况，我们该怎么**缓解这种倦怠和烦躁的情绪呢**？

首先，我觉得应该从工作中找到乐趣。当然，工作并不是全部的生活，我也怕极了那些把工作当做生活过的人。但是职场必然是生活的一部分，所以尽管它可能不那么如意，但是试着在工作中找到乐趣。比如有些人觉得多找几个 BUG 就很有成就感，多读一些代码就觉得很开心，或者搭一套开源的测试框架，看着它运行起来就感觉自己棒棒哒。

像我自己，我觉得网络上也好、开源的框架中有一些能够让我眼前一亮、可以完善自己知识的点，都会让我觉得此时不虚度。

有同学会觉得：这样非要让我苦中作乐似乎不太合理，有点变态。所以，再来需要调整心态。我呢，是个地地道道的天津人，所以从小熏陶的相声的娱乐思维，还是让我往往能够在工作中保持相对不错的心态，所以工作里时不时的跟别人逗几句，接一接别人的话茬都是不错的方式，别把老板、主管、同事想得太严肃，职场的和谐其实还很需要幽默感。如果实在不行，偶尔的打开 “脉脉”，看看各大互联网公司的热闹事儿，比你还苦逼的有的是，所以自己还是不错的。

而对于一部分觉得由于自己的瓶颈，或者长期点点点的重复工作带来的烦躁，我觉得不如好好利用自己的工作时间，立一些 flag，做一份切实可行并且自己严格遵守的计划，做一些可以预见的或者未来想要学习的内容，最终把学到的技能应用到工作中去，摆脱这种瓶颈的壁垒。

最后，也是我自己最常用的方式就是：放松自己，劳逸结合。

工作不应该成为让你牺牲一切快乐的罪魁祸首。这里还是分享我自己的经验：

- 经常利用周末或其他时间跟其他朋友聚会，喝喝小酒吐个槽或许就能让自己放松不少。
- 晚上不管加班到多晚，回家上楼之前可以自己或者叫上自己的另一半溜达一小圈，聊聊与工作无关的话题。ps：可是木有伤害单身汪的意思，要不边溜达边瞅瞅美女帅哥？
- 软件人都比较容易疲惫，肩颈大多有点小毛病，周末时候去扎个针灸按个摩也是不错的放松。

最后，是我自己保持心态的两个大招：

- **看话剧。** 我大概每个季度都会去看几场开心麻花，让自己能够在一晚上的开怀大笑里或多或少的忘记一些不快乐的事情。
- **旅行。** 不知道还记不记得，我在开篇的时候晒过一个海上的图，那个时候我正在马尔代夫度假。旅游是我从大学保持到现在最大的爱好，每次压力极大的时候我都会找机会扔掉一切，冲到我喜欢的地方好好的浪几天，尝试着重新享受生活、阳光、大海和沙滩。

或许有小伙伴说了，我没有你那样的爱好，我不喜欢溜达、不爱看开心麻花也并不愿意旅游，这我该怎么办？这时候我的建议是找个爱好。也许你会愿意在骑行中扔到挥之不去的烦躁，也许你会在收拾房间的繁重劳动中忘记工作的不快，或许你会在静静的读一本书、听一听音乐的过程中让自己逐渐平静下来，又或者你会在写日记的过程中把让自己不舒服的点点滴滴都留在日记本的每一页里边，再不然你可能也会在一场跑到快抽筋的马拉松赛场上找到自己青春的心跳。总之，找一件你愿意做的或者从来没有尝试做过的事情，放掉一切、全身心的投入到其中。

其实我不知道我分享的办法是不是对每个人都有用，所以我真的不是一个合格的心理专家。不过还好，在很多人的评价中，我应该是一个合适的倾听者。所以，如果你有什么不开心的，欢迎来跟树洞风落吐个槽。

## **38 技术人之中年恐惧**

聊了很久别人的问题，看了许多大家的故事，今天我来聊聊我自己。

都说 “三十而立，四十而不惑”，不知不觉我已经过了而立之年，但是还远没有到不惑的地步。某天晚上在海河边散步，老婆突然扭头问我：40 岁之后你会在干嘛？

我一下子愣了很久，作为 30 多岁的 IT 老人，做过开发、测试，当过项目经理，也做过运维。一直都在忙碌的工作生活中奔波，穿插着制作课程、写书、专栏，偶尔有一些余下的时间，仍然还在孜孜不倦的研究一些框架、平台的设计，研究新开源的东西，也会因为一些新技术的产生而雀跃。

我是很认真的希望：每天的自己都比昨天好一点点。然而，我真的从来没有停下来想过，未来。不知道 40 岁以后的自己是不是还能像现在一样忙碌，是不是还能够在一份自己喜欢、待遇又不错的岗位上坚持。

可能看到这儿有人要说了：聊 40 岁的技术人就像聊为什么在 2019 年的今天，还没有 90 后能够活过 30 岁一样，随着时间的推进都会好的。

可是自家人知道自家事，我没有开天眼，不知道未来如何，至少在现在，从华为清理技术人员、中兴老程序人跳楼事件来说可见一般，就是我自己，也更愿意录用一些有拼劲的年轻人。为什么？年龄越大，工作与家庭的天平越容易失衡，40 岁的自己还能像 20 岁一样去通宵加班么？

所以，在这里我不愿意给大家简单的灌输乐观情绪。可能有很多人看了我们的专栏至此，都发现我还是一个蛮现实的人，所以更想给大家聊聊真实的生活，只有认清了事实和自己，才能更加应对得体。

如何应对中年危机？老实说，因为我还仅仅是自己吓了自己一下，没有经历过人到中年，可能还没办法提供给你真正的经验；我也相信，读到这篇文章的很多同学，都还远没有到中年恐惧的地步。我想，我们有理由也有立场站在一起好好想想未来，想想自己可以做好什么准备。

做管理？这是很多人选择的一条出路。但是管理毕竟还在少数，我也并不觉得管理比技术好到哪里，管人比起管好你的代码，难度更要大的多。

做小生意？我不知道有多少人会成功，技术思维的我们如何应对风云变幻的生意场。

创业？这恐怕需要大量的积累，不仅仅是技术，更是人脉，是社会关系。仅凭一腔热血，除了个把天才，恐怕也很难闯出一片天。

投资？我不觉得我们有被钱砸到头上的运气，恐怕投资更多是在给别人送钱。

这么聊下去，连我自己都感觉悲哀了。但是这就是人生。这个基调不太对，让我们再变化一下。尽管现实很残酷，但是还年轻的我们或许还有补救的机会。不要觉得自己现在 20 多岁、不到 30，这中年危机还距离你很遥远，事实上，俗话说：**时间过得张牙舞爪，光阴逃得死去活来**。不在意今天，就要为未来付出代价。

首先，你当然可以对自己的技术自信，但是不要躺在技术的 “温柔乡” 里，幻想着自己曾经多么多么牛。当你还在沉醉于自己关键字驱动的框架之时，大家早已经玩到了 TestOps。所以，就算你计划成为 40 岁以后人见人爱的架构、专家，也要**保持着自己的敏锐度**。那么，我建议你从今天开始，为自己找一个可以奋斗十年左右甚至更久的目标。不要不切实际，不要说我要成为下一个马爸爸，找一个自己眼前的可以实现的。

一个清晰的目标，才能让你的成长不会走偏，可以围绕着一个核心去积累、提升。不要总是抱怨没有机会，实际上并非如此。我曾经回顾了一下我自己的前半生，如果从现在的角度看上去，生活给了我不下十几次的机会。当然，有些好有些坏。幸运的是，我抓住了其中的几个，而不幸的也是，我错了接近十个可以改变自己的机会。为什么错过？我觉得是因为自己还不够好，当运气到来的时候，并没有把自己准备好。

除了技术，我想说的最重要的是：**学会做人**。我当然知道，技术人的特色就是技术强就无敌，怼天怼地怼空气。事实上，技术仅仅一个工具，它很重要，但是并不能代替一切，所以我还是劝大家，要多开阔自己的眼界，无论是营销方面，还是人性方面。做一个有人格魅力的人。我身边有一个 70 后的 coder，其他的我们不谈，之所以还可以奋斗在这个岗位上，是因为在他的身上有一种说不出的气质，愿意让人们围绕在他周围。于是乎，自身的社会关系，人脉关系也很多，自己想做些什么都很得心应手。

最牛的技术人不是傲，而是谦。

刚刚提到人性，这是技术人的痛点，情商不足。在职场上，未必坚持自我就是好的，有时候只有看清了形势，评估了得失，才有可能更好的坚持自我。这方面不好多说，也很难多说。生活有时候会让你不知不觉的变成你最讨厌的那种人，可是至少你还有自己的底线，还有自己的思想。

所以还是回到了上一节的点上：找一个爱好，坚持它；结识几个未必在同一行业的朋友，多聊聊。**比起做一个技术更牛的人来说，做一个有趣的、有魅力的、有朋友圈的人会对你来说在某些时候更有价值。**

罗里吧嗦了很多，我其实自己都不是完全知道我想要表达什么，各位看官权且当我在聊自己。四十岁的我，应该会活回我自己吧，我想。也许有一天，40 岁的风叔，会回到这篇文章下，默默的留下自己 40 岁的样子，我相信还不会太差。

「懦怯囚禁人的灵魂，希望可以令你感受自由。强者自救，圣者渡人。 — Red」

没在怕的，也许我们不可能成为圣者，那就做一个强者吧。

## **39 结束语 | 始于初心，终于行**

你好，我是风落。不知不觉，就到了该说再见的时候了。

在过去的接近四十篇专栏的时间里，我们在这里探讨了很多有意义的话题。在拿给编辑以前，我把其中的一部分拿给了与软件工作无关的朋友看，他的回复是：原来测试是一份这样的工作。我突然觉得这个专栏写出来还是有意义的。

其实写到这篇结束语的时候，还是很不舍的。连续有接近三个多月的时间，每天的构思和编写，连老婆都说我：每天都熬夜研究什么呢，当初写书时候都没有这么用功啊。比起来写一些很专业的测试技术书籍，或者写几篇技术博客，这次的专栏是对我自己的一个新挑战。

与技术不一样，正像我开头说的，我希望能够做一个不一样的专栏；而我自己的初心，是让大家能够更好的认识测试工作，更好的在测试这条路上走下去；是为了让大家知道测试不是点点点，也是有自己完整的知识体系的。我很严谨的克制了自己想要编代码的冲动，尽自己最大的努力把 “做更好的 Tester” 这个主题贯彻始终。

我希望每个 Tester 能够给大家带来一点点的转变：在自己的测试工作中，能够站在更高的角度来思考，有计划、有目的的解决问题和提升自己。或许对于迷茫、不知所措的小伙伴找到一条更合适自己的路。

三十九篇的内容，覆盖了包括学习方法、技术方向、测试探索、职场心态各个主题提出了一些分析和路线。从内容上来说，我觉得还算是比较完备的，但我不确定是否有哪些点还仍然不够深刻。在这个专栏中，我重点想告诉大家的是：我们想更好，应该做什么？而很多关于怎么去实现的问题，我希望大家能够更有主动性一些，在既有的方向上探索。

来到慕课已经有了很长的一段时间，到目前为止，我收到了很多同学拿到 offer 的感谢，当然，更有很多的同学还在努力的路上。今天也许是这个专栏的终点，但是却是大家行动的起点。希望大家能够在接下来的工作中，找到自己的发展方向，发现新的目标，就像这篇结束语的题目一样：始于初心，终于行，以终为始，持续努力。

最后的最后，我不太想告别也无需告别，我们可以留言区再见。欢迎大家能够继续跟风落交流，把你最真实的感受告诉我。